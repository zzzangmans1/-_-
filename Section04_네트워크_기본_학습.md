# 1. 프로토콜
## (1) 개요
1. 시스템 간에 통신하기 위한 규약
2. 프로토콜은 구문, 의미, 타이밍으로 이루어져 있다.

## (2) 프로토콜의 구성요소
1. 구문 : 송수신 데이터 포맷을 의미한다.
2. 의미 : 데이터의 각 항목이 가지는 의미를 의미한다.
3. 타이밍 : 데이터 송수신 동작 방식을 정의하는 것을 의미한다.

# 2. OSI 7 Layer
## (1) 개요
1. 국제 표준화 기구(ISO)에서 제정한 개방형 시스템 간의 상호연결(OSI: Open System Interconnection) 모델
2. 분산된, 이기종 시스템 간의 네트워크 상호호환을 위해 필요한 표준 아키텍처를 정의한 참조모델
3. 기능에 따라 계층적으로 표준화 되어 있다. 어떤 목적을 수행하기 위해서 하나의 큰 프로토콜을 설계하는 것이 아니라 계층적으로 나누어진 여러 프로토콜을 조합하여 그 목적을 수행하는 방식이다. 이러한 접근 방식을 "분할 정복"이라 한다.
4. 계층별로 표준화를 함으로써 상하위 계층 간에 인터페이스만 충족시켜주면 다양한 제조자들에 의한 독자적인 계층별 프로토콜의 구현 및 발전을 이룰 수 있다.

## (2) 계층별 특징
### 1) Pysical Layer (물리 계층, L1)
#### (가) 개요
1. 물리적 장치의 전기적, 전자적 연결에 대한 명세
2. 디지털 데이터를 전기적인, 광학적인 신호로 변환하여 입출력을 담당하는 계층으로 1계층에는 주소 정보가 없다. 따라서 목적지를 인식할 수 없고 전기적인 신호만을 연결된 모든 노드에 전달한다.
3. 물리 계층의 데이터 단위를 **비트**라 한다.

#### (나) 주요 네트워크 장비
1. HUB(허브) : 들어온 신호를 연결된 모든 포트로 전달하는 중계 장치이다. 이러한 허브를 Dummy Hub라고 한다.(2계층 장비는 Switching Hub로 구별)
    * Switching Hub : Dummy Hub는 연결된 모든 노드에게 신호를 전달하는 반면에 Switching Hub는 목적지 주소(2계층 장비이므로 MAC 주소를 의미)를 식별하여 해당 목적지 노드가 연결된 포트로만 신호를 전달하는 장비를 말합니다.
2. REPEATER(리피터) : 감쇠된 전송신호를 새롭게 재생하여 다시 전달하는 재생 중계 장치이다.

#### (다) 허브(Dummy Hub) 환경에서의 스니핑(Sniffing)
1. 더미 허브는 전달받은 패킷을 단순히 연결된 모든 노드로 전송하기 때문에 허브에 연결되어있는 모든 노드는 스니퍼를 통한 스니핑이 용이하다. 단, 네트워크 카드의 기본동작모드가 자신을 목적지 주소로 하는 패킷이 아니면 모두 폐기하기 때문에 패킷을 볼 수 있는 것은 아니다.
2. 네트워크 카드(NIC)의 동작모드를 **무차별 모드(Promiscuous Mode)**로 설정하면 자신이 목적지가 아닌 패킷도 모두 수신하기 때문에 더미 허브 환경에서 손쉽게 스니핑할 수 있다. 일반적으로 스니퍼가 동작할 때 네트워크 카드의 동작모드를 무차별 모드로 설정한다.

### 2) Data Link (데이터 링크 계층, L2)
#### (가) 개요
1. Node-To-Node Delivery, 인접한 노드 간의 신뢰성 있는 프레임 전송을 담당하는 계층이다. 데이터링크 계층은 인접노드 간의 통신이며 최종 목적지 노드에 도달하기 위해서는 각각의 노드 간에 프레임에 대한 주소설정(MAC 주소)이 이루어진다.
2. 목적지 노드를 찾아가기 위해서는 목적지 노드에 대한 물리적인 주소가 필요하며 네트워크 카드(NIC)의 MAC 주소가 해당 역할을 한다.
3. IEEE 802 표준에서는 LAN 상의 데이터링크 계층을 LLC(Logical Link Control) 와 MAC(Media Access Control) 두 개의 하위 계층으로 세분화한다.
    * LLC (Logical Link Control) : 네트워크 계층과의 연결을 담당하는 계층으로 상위 계층으로 안전하고 정상적인 데이터를 전달하기 위해 데이터 오류 검출 및 상위 프로토콜에 대한 타입 확인
    * MAC (Media Accesss Control) : 물리적 계층과의 연결을 담당한느 계층으로 신호변환을 통해 물리적 계층과 연결하고 MAC 주소를 통해 주소를 확인하여 정상적으로 데이터가 송수신되고 있는지 확인
4. 데이터링크 계층의 데이터 단위를 **프레임**이라 한다.
5. 데이터링크 계층의 대표적 프로토콜로 Eternet, TokenRing, FDDI, X.25, Frame Relay 등이 있다.

#### (나) 신뢰성 있는 전송을 위한 기능
1. 신뢰성 있는 전송이란 데이터의 안전한 전송을 보장해준다는 의미로 이러한 기능들을 일반적으로 데이터링크 컨트롤이라 한다.
2. **흐름제어 (Flow Contorl)** : 송신 노드가 수신 노드의 처리 속도를 고려하여 이를 초과하지 않도록 전송을 제어한다. 이러한 흐름제어는 수신 노드가 수신확인응답을 송신 노드에 제공함으로써 흐름제어를 수행하는데 다음 2가지 방식이 있다.
    * **정지-대기 (Stop and Wait)** : 송신 측에서 프레임을 전송한 후 확인응답(ACK)을 받을 때까지 대기하는 방식
    * **슬라이딩 윈도우 (Sliding Window)** : 송신 측에서 수신 측의 수신확인응답을 받기 전에 수신 가능한 범위 내에서 여러 프레임을 전송하는 방식
3. **오류제어 (Error Control)** : 전송 중에 여러 가지 원인(주파수 혼란, 감쇠, 잡음 등)에 의한 오류나 손실 발생 시 이를 해결하기 위한 제어방식이다. 오류제어 방식에는 다음 2가지 방식이 있다.
    * **후진 오류 수정방식 (BEC, Backward Error Correction)** : 송신 측에서 데이터전송 시 오류를 검출할 수 있는 부가 정보를 함께 전송하여 수신 측에서 이를 점검하여 오류 발생 시 재전송을 요청하는 방식으로 이러한 요청을 ARQ(Automatic Repeate Request)라 한다.
    * **전진 오류 수정방식 (FEC, Forward Error Correction)** : 재전송이 불필요한 방식으로 송신 측에서 데이터 송신 시에 오류의 검출 및 수정까지 가능한 부가 정보를 담아서 보내는 방식
4. **회선제어 (Line Control)** : 점-대-점(Point-to-Point) 또는 다중점 회선 구성 방식 과 단방향, 반이중 및 전이중 등의 전송 방식에 따라 사용되는 전송링크에 대한 제어 규범이다.

#### (다) 주요 네트워크 장비
1. L2 Switch
    * 스위치 장비는 내부적으로 MAC Address Table을 가지고 있다. 이 테이블에는 스위치 포트에 연결된 노드의 MAC 정보를 담고 있다. 이 정보를 참조하여 목적지 MAC 주소의 포트에 연결된 노드에게만 패킷을 전송한다.
    * 스위치 환경에서 특정 포트를 모니터링하고자 한다면 모니터링 포트 또는 네트워크 트래픽을 모니터링할 수 있는 탭 장비를 통해 패킷을 복제해서 트래픽 분석 장비로 전달한다.
    * 스위치 환경에서는 기본적으로 목적지로만 패킷을 전송하기 때문에 스니핑이 불가능하다. 이러한 환경에서 스니핑을 하기 위해서는 스위치 재밍, ARP 스푸핑, ARP 리다이렉트, ICMP 리다이렉트, 스위치의 SPAN/Monitoring Port 이용 등이 있다.
2. Bridge
    * 물리적으로 떨어진 동일한 LAN을 연결해주는 장비

#### (라) 스위치 환경에서의 스니핑 공격 기법
1. **스위치 재밍(Switch Jamming)/MAC Flooding 공격**
   * 스위치 MAC Address Table의 버퍼를 오버플로우 시켜서 스위치가 허브처럼 동작하게 강제적으로 만드는 기법을 말한다. 스위치는 Fail Safe/Open 정책을 따르는 장비이므로 장애가 발생하면 더미 허브처럼 연결된 모든 노드에 패킷을 전송한다.
   * MAC Address Table을 채우기 위해(오버플로우 시키기 위해) Source MAC 주소를 계속 변경하면서 패킷을 지속적으로 전송하는 방식을 사용한다.
2. **ARP 스푸핑 공격**
   * **공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply 패킷을 만들어 희생자에게 지속적으로 전송하면 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보가 공격자의 MAC 정보로 변경된다.** 이를 통해서 희생자로부터 특정 호스트로 나가는 패킷을 공격자로 향하도록 하여 스니핑하는 기법이다.
   * 희생자와 특정 호스트 간의 송수신 패킷을 모두 스니핑하기 위해서는 희생자와 특정 호스트 모두 ARP 스푸핑을 수행한다.
   * **희생자들이 스누핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화**한다.
      * IP Forwarding 기능 : 일반적인 호스트 설정의 경우 자신을 목적지 주소로 하지 않는 IP 패킷을 수신한 경우 모두 폐기하지만 IP Forward 기능을 활성화하면 라우터처럼 동작하여 자신이 목적지가 아닌 IP 패킷에 대해서는 라우팅 테이블을 참조하여 해당 목적지로 전송하게 됩니다.
3. **ARP 리다이렉트 공격**
   * **ARP 스푸핑 공격의 일종으로 공격자가 자신이 라우터/게이트웨이인 것처럼 MAC 주소를 위조하여 ARP Reply 패킷을 대상 네트워크에 지속적으로 브로드캐스트하면 해당 로컬 네트워크의 모든 호스트의 ARP Cache Table에 라우터/게이트웨이의 MAC 정보가 공격자의 MAC 정보로 변경**이 된다. 이를 통해 호스트에서 라우터로 나가는 패킷을 공격자가 스니핑하는 기법이다.
   * 희생자들이 스니핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화한다.
4. **ICMP 리다이렉트 공격**
   * **ICMP Redirection 메시지는 호스트-라우터 또는 라우터 간에 라우팅 경로를 재설정하기 위해 전송하는 메시지**이다. 공격자가 이를 악용하여 특정 IP 또는 IP 대역으로 나가는 패킷의 라우팅 경로를 **자신의 주소로 위조한 ICMP Redirect 메시지를 생성하여 희생자에게 전송함으로써 희생자의 라우팅 테이블을 변조하여 패킷을 스니핑하는 공격**기법이다.
   * 희생자들이 스니핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화한다.
5. **스위치의 SPAN (Switch Port ANalyzer)/Port Mirroring 기능 이용**
   * 스위치의 SPAN/Port Mirroring 기능은 스위치를 통과하는 모든 트래픽을 볼 수 있는 기능으로 특정 포트에 분석 장비를 접속하고 다른 포트의 트래픽을 분석 장비로 자동 복사해주는 기술이다.
   * 관리적인 목적으로 사용하지만, 공격자가 물리적으로 해당 포트에 접근할 수 있다면 손쉽게 패킷을 스니핑 할 수 있다.

### 3) Network Layer (네트워크 계층, L3)
#### (가) 개요
1. End-To-End Delivery, End 노드(종단노드) 간의 라우팅을 담당하는 계층으로 Host-To-Host Delivery라고도 한다.
2. 라우팅이란 라우팅 알고리즘에 의해 목적지로 전송하기 위한 최적의 경로를 설정하고 패킷을 교환하는 기능을 제공하는 것을 말한다.
3. 최종 목적지 노드를 찾아가기 위해서는 노드에 대한 논리적인 주소가 필요한데 TCP/IP 프로토콜에서는 IP 주소가 이 역할을 한다.
4. 네트워크 계층의 데이터 단위를 **패킷**이라 한다.
5. 대표적으로 IP(TCP/IP), IPX(Novel Netware) 등이 있다.

#### (나) 주요 네트워크 장비
1. 라우터 / L3 Switch
   * 라우팅(최적의 경로를 선정해서 패킷을 포워딩하는 기능)을 담당하는 장비
   * 데이터 링크 계층의 브로드캐스트와 멀티캐스트를 포워딩 하지 않으며, 서로 다른 VLAN간에 통신을 가능하게 하고, 기본적인 보안 기능과 QoS관련 기능을 지원하는 장비

### 4) Transport Layer (전송 계층, L4)
#### (가) 개요
1. End-To-End Reliable Delivery, End 노드 간의 신뢰성 있는 데이터전송을 담당하는 계층이다. 좀 더 구체적으로 말하면 각 End 노드의 해당 Process 간 신뢰성 있는 데이터전송을 담당하는 계층이다. (Process-To-Process Communication)
2. 목적지 Node(Process)를 찾아가기 위해서는 Process를 식별하기 위한 논리적인 주소가 필요하며 TCP/IP 프로토콜에서는 Port Address가 이 역할을 한다.
3. 전송 계층의 데이터 단위를 **세그먼트**라 한다.
4. 대표적 프로토콜로 TCP/IP의 TCP, UDP, SCTP와 Novel Netware의 SPX 등이 있다.

#### (나) 신뢰성 있는 데이터 전송을 보장하기 위한 기능
1. **분할 (Segmentation)과 재조합 (Reassembly)**
   * 조건에 따라 원본 데이터를 전송 가능한 세그먼트 단위로 분할하여 전송하면 목적지에서는 이를 재조합하여 원본 데이터를 복원한다.
2. **연결제어 (Connection Control)**
   * 연결지향(TCP) 과 비연결지향(UDP) 방식을 제공한다.
3. **흐름제어 (Flow Control)**
   * 흐름제어를 한다는 것은 상호 간에 수신할 수 있는 만큼만 전송해서 데이터의 손실이 발생하지 않도록 하는 제어방식을 말한다.
   * 종단 노드 간 흐름제어를 수행한다. **데이터링크 계층은 바로 인접한 노드 간에 흐름제어**를 했다면 **전송 계층에서는 양 종단노드 간에 흐름제어를 수행하므로 그 범위가 넓다**.
4. **오류제어 (Error Control)**
   * 종단노드 간 전송 중 오류 발생 시 이를 교정한다.
5. **혼잡제어 (Congestion Contorl)**
   * 네트워크 혼잡도를 계산하여 전송량을 제어한다.

#### (다) 주요 네트워크 장비
1. L4 Switch : SLB (Server Load Balancing) 즉 서버 트래픽 부하분산과 Failover 기능을 제공한다.
   * **장애 조치 (Failover)** : 시스템에 장애가 발생했을 때 예비 시스템으로 자동 전환되는 기능을 말한다.
  
### 5) Session Layer (세션 계층, L5)
#### (가) 개요
1. Application간 논리적인 연결인 세션의 생성, 관리 및 종료를 담당하는 계층

### 6) Presentation Layer (표현 계층, L6)
#### (가) 개요
1. 데이터 표현방식 변환을 담당하는 계층
2. 인코딩/디코딩, 압축/압축해제, 암호화/복호화 등을 담당한다.

### 7) Application Layer (응용 계층, L7)
#### (가) 개요
1. 사용자가 네트워크에 접근할 수 있는 인터페이스를 담당하는 계층
2. 네트워크 서버/클라이언트 프로그램
3. 응용 계층의 데이터 단위를 **데이터**라고 한다.
   * 일반적으로 5,6,7 계층 데이터 단위를 모두 데이터라 한다.

# 3. OSI 모델 데이터 교환 방식
### 1) Encapsulation(캡슐화)/Decapsulation(역캡슐화)
1. 상위 계층의 데이터가 하위계층으로 보내지면, 하위 계층 프로토콜은 자신의 기능 수행을 위해 필요한 부가 정보(헤더)를 추가해서 새롭게 전송 메시지를 완성한다. 이를 캡슐화라고 한다.
2. 수신 측에서는 상위 계층으로 데이터를 보낼 때 해당 계층의 헤더 정보를 확인한 후 제거하고 상위 계층으로 데이터를 보낸다. 이를 역캡슐화 라고 한다.

### 2) Multiplexing(다중화)/Demultiplexing(역다중화)
1. 다중화는 하나의 기능(매체)을 여러 영역에서 동시에 사용하는 기법을 말한다. 상위 계층의 여러 프로토콜이 하위 계층의 하나의 프로토콜을 이용하여 데이터를 전달하는 방식으로 수신 측에서 상위 프로토콜을 구별할 수 있도록 프로토콜 식별자 정보를 헤더에 추가한다.
2. 역다중화는 공유하는 기능(매체)으로부터 개별 영역으로 분할하는 기법을 의미한다. 하위계층의 프로토콜이 여러 상위 계층 프로토콜 중 하나를 식별하여 데이터를 전달하는 방식으로 이를 위해서는 상위 프로토콜을 구별하기 위한 프로토콜 식별자 정보(다중화 시에 헤더에 설정된 정보)를 이용한다.

# 4. TCP/IP 프로토콜
### 1) Application Layer (응용 계층)
#### (가) 개요
1. 네트워크 서버/클라이언트 프로그램을 담당하는 계층
2. 사용자와의 인터페이스를 담당하는 계층

#### (나) 주요 프로토콜
1. HTTP(80/tcp) : Hyper-Text Transfer Protocol
2. FTP(20/21/tcp) : File Transfer Protocol, 데이터 포트(20), 제어 포트(21)
3. SSH(22/tcp) : Secure Shell, 암호화된 원격 터미널 접속 프로토콜
4. SFTP(22/tcp) : SSH File Transfer Protocol, SSH를 이용한 암호화된 파일 송수신 프로토콜
5. TELNET(23/tcp) : TELe NETwork, 암호화하지 않은 원격 터미널 접속 프로토콜
6. SMTP(25/tcp) : Simple Mail Transfer Protocol, 메일 전송용 프로토콜
7. POP3(110/tcp) : Post Office Protocol Version3, 메일 수신용 프로토콜
8. IMAP(143/tcp) : Internet Message Access Protocol, 메일 수신용 프로토콜
9. DNS(53/tcp,udp) : Domain Name System, 도메인명에 대한 호스트 정보를 제공해주는 프로토콜
10. DHCP(67,68/udp) : Dynamic Host Configuration Protocol, 서버(67), 클라이언트(68), 동적으로 호스트 네트워크 설정을 제공해주는 프로토콜
11. TFTP(69/udp) : Trivial FTP, 단순 파일 송수신 프로토콜
12. SNMP(161/udp) : Simple Network Management Protocol, 네트워크 관리 프로토콜

### 2) Transport Layer(전송 계층)
#### (가) 개요
1. Process-To-Process Communication, 프로세스 간 신뢰성 있는 데이터전송을 담당하는 계층으로 신뢰성 있는 전송이란 전송 중에 발생하는 오류, 누락 및 흐름제어, 혼잡제어 등을 적절히 수행하여 데이터의 안전한 전송을 보장함을 말한다.
2. 프로세스를 식별하기 위한 논리적인 주소로 Port(16bit) 주소를 사용한다.

#### (나) 주요 프로토콜
1. TCP(Transmission Control Porotocl) : 신뢰성 있는 연결지향 프로토콜(스트림 기반 전송)
2. UDP(User Datagram Protocol) : 비신뢰적인 비연결형 프로토콜(데이터그램 기반 전송)
3. SCTP(Stream Control Protocol) : TCP와 UDP의 조합형

### 3) Internet Layer(인터넷 계층)
#### (가) 개요
1. Host-To-Host Communication, 호스트 간의 라우팅을 담당하는 계층
2. 호스트를 식별하기 위한 논리적은 주소로 IP(IPv4:32bit, IPv6:128bit) 주소를 사용한다.

#### (나) 주요 프로토콜
1. IP(Internet Protocol) : 비신뢰적인 비연결형 데이터그램 프로토콜
2. ICMP(Internet Control Message Protocol) : 에러 및 상태진단 메시지 프로토콜
3. IGMP(Internet Group Management Protocol) : 멀티캐스트용 프로토콜
4. ARP(Address Resolution Protocl) : 주소변환(논리주소(IP) -> 물리주소(MAC)) 프로토콜
5. RARP(Reverse Address Resolution Protocol) : 역주소변환(물리주소(MAC) -> 논리주소(IP)) 프로토콜

### 4) Network Interface Layer(네트워크 인터페이스 계층)
#### (가) 개요
1. Node-To-Node Delivery, 인접한 노드 간에 신뢰성 있는 데이터전송을 담당하는 계층
2. Node를 식별하기 위한 물리적인 주소로 MAC(48bit) 주소를 사용한다. 물리적 MAC 주소는 상위 24비트와 하위 24비트로 이루어져 있으며 상위 24비트는 제조사(벤더) 식별코드이고 하위 24비트는 제조사가 할당한 일련변호를 의미한다.

#### (나) 주요 프로토콜
1. LAN(Local Area Network) 프로토콜 : Ethernet, TokenRing, FDDI 등
2. WAN(Wide Area Network) 프로토콜 : X.25, Frame Relay, PPP, SLIP 등

# 5. ARP/RARP 프로토콜(TCP/IP 인터넷 계층)
### 1) ARP 및 RARP 프로토콜 특징
1. 논리적인 주소와 물리적인 주소 사이의 변환을 담당하는 프로토콜
2. ARP(Address Resolution Protocol) : 논리적인 IP 주소를 물리적인 MAC 주소로 변환해주는 역할을 하는 프로토콜
3. RARP(Reverse ARP)
   * 물리적인 MAC 주소를 논리적인 IP 주소로 변환해주는 역할을 하는 프로토콜
   * 일반적으로 IP 주소는 시스템의 하드디스크 내 설정 파일에 저장되어 있지만 하드디스크가 없는 터미널의 경우에 초기 가동될 때 자신의 MAC 주소를 담아 RARP 요청을 만들어 자신의 IP 주소 정보를 받아오게 된다. MAC에 해당하는 IP 주소 정보를 관리하는 RARP 서버가 구성되어 있어야 한다.
  
### 2) ARP 동작방식
1. **최초 상대방의 물리적인 주소를 알지 못하기 때문에(논리적인 IP 주소만 알고 있는 상태) ARP 요청 메시지를 만들어 브로드캐스트**한다.
   * ARP 요청 메시지를 캡슐화한 이더넷 프레임의 목적지 MAC 주소를 살펴보면 브로드캐스트 주소인 ```FF:FF:FF:FF:FF:FF``` 로 전송한다.
2. **Target 호스트에서는 ARP 응답 메시지를 만들어서 응답**한다. **응답메시지에는 Target 호스트의 MAC 주소 정보가 담겨있으며 응답자는 요청자의 MAC 주소를 알고 있으므로 유니캐스트 방식으로 응답**한다. Target이 아닌 호스트들은 수신한 브로드캐스트 요청 메시지를 폐기한다.
   * ARP 응답메시지를 캡슐화한 이더넷 프레임의 목적지 MAC 주소를 살펴보면 요청 메시지를 보낸 호스트의 MAC 주소로 설정된 것을 확인할 수 있다.
3. 각 시스템은 ARP Cache가 있고 Cache에 이 정보를 보관해 둔다. 물론 일정 시간 경과 후에는 삭제된다.

### 3) RARP 동작방식
1. **최초 자신의 논리적인 IP 주소를 알지 못하기 때문에(물리적인 MAC 주소만 알고 있는 상태) 자신의 MAC 정보를 담고 있는 RARP 요청 메시지를 만들어서 브로드캐스트**한다.
2. **RARP Server는 요청자의 IP 주소 정보를 담은 RARP 응답 메시지를 만들어 요청자의 MAC 주소로 유니캐스트 방식으로 응답**을 준다.

### 4) ARP cache table 살펴보기
#### (가) 개요
1. ARP 요청을 통해 알아낸 MAC 정보는 OS에 따라 다르지만 통상 1~2분 정도 메모리에 저장한다.
2. arp -a 명령을 통해 ARP cache table을 살펴보면 타입이 dynamic 또는 static으로 지정이 되어 있다. dynamic으로 된 것은 arp에 의해 동적으로 설정된 것으로 일정 시간 동안 유지된다. static으로 된 것은 관리자에 의해 정적으로 설정된 것으로 관리자가 삭제하거나 시스템이 종료하기 전까지 지속적으로 유지된다.

#### (나) 관련 명령어
1. arp -a : 캐시 내용 보기
   * 윈도우의 경우 MAC 주소 구분자 "-" 사용
   * 리눅스의 경우 MAC 주소 구분자 ":" 사용
2. arp -d : 캐시 내용 삭제
   * 윈도우의 경우 arp cache에 저장된 모든 내용 삭제
   * 리눅스의 경우 IP를 명시해야 하고 삭제된 항목은 일정 시간 <incomplete> 상태로 보인 후 삭제된다.
3. arp -s : 캐시 정적 설정
   * 윈도우의 경우 static으로 설정된 정보는 시스템 종료 시까지 유지된다.
   * 리눅스의 경우 PERM으로 설정된 정보는 시스템 종료 시까지 유지된다.

### 5) ARP Spoofing 공격(ARP Cache Poisoning)
#### (가) 개요
1. 공격자가 희생자의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하면 희생자 ARP Cache Table의 MAC 정보가 공격자의 MAC 정보로 지속적으로 변경된다. 이를 통해서 희생자 간의 송수신 패킷을 공격자가 스니핑하는 기법이다.
2. 공격자는 희생자간에 정상적인 통신이 이루어질 수 있도록(스니핑을 눈치채지 못하도록) IP Forward 기능을 활성화한다.
3. **일반적으로 희생자 ARP Cache의 Gateway(Router) 주소를 공격자 MAC 주소로 변조시켜서 외부로 나가는 데이터를 스니핑하는데 이를 특별히 ARP Redirect 공격**이라 한다.
4. **ARP Spoofing은 2계층 주소인 MAC 주소를 속여서 트래픽을 스니핑하는 것이므로 2계층에서 동작하게 된다. 2계층 주소는 서로 다른 네트워크로 라우팅되지 않기 때문에 공격 대상도 동일 네트워크 대역에 있어**야 한다.

#### (나) 실습
1. 희생자PC ARP Cache Table 변조
   * 공격 전 : 첫 번째 "arp -a" 명령 결과를 살펴보면 희생자PC의 MAC 주소가 정상적으로 설정되어 있음을 확인할 수 있다.
   * 공격 후 : 두 번째 "arp -a" 명령 결과를 살펴보면 희생자PC의 MAC 주소가 공격자PC의 MAC 주소와 동일하게 설정되어 있음을 확인할 수 있다. 즉 공격자에 의해 조작된 arp reply 패킷에 의해 cache 정보가 변조되었음을 알 수 있다.
   * 희생자PC에서 패킷 캡처한 결과를 살펴보면 공격자에 의해 주기적으로 arp reply 패킷이 발생하고 있으며 arp 프로토콜의 sender MAC과 IP를 보면 희생자 PC의 MAC 주소가 공격자의 MAC 주소로 조작되어 있다.
2. 희생자 PC ARP Cache Table 변조
   * 희생자PC와 동일하게 공격자PC에 의해 Cache 정보가 변조되었음을 확인할 수 있다.

#### (다) 대응방법
1. ARP 요청 및 응답 과정에서 별도의 인증과정이 없는 ARP 프로토콜 자체의 취약점을 이용한 공격이기 때문에 완벽한 방어는 없다. 일반적인 대응 방법은 ARP 캐시를 정적으로 설정하여 ARP 응답을 수신해도 캐시 정보를 갱신하지 않도록 한다.
2. 캐시 정보는 시스템 종료 시 삭제되므로 시스템 기동 시마다 ARP 캐시를 정적으로 구성해 주어야 한다.
3. 네트워크상의 ARP 트래픽을 실시간으로 모니터링하는 프로그램(ARP Watch 등)을 이용하여 IP와 MAC 주소의 매핑을 감시, 변경 발생 시 즉시 확인하도록 한다.

### 6) GARP (Gratuitous ARP)
#### (가) 개요
1. Gratuitous란 "불필요한"이란 의미이다. GARP는 별도의 프로토콜이 아니고 Sender IP와 Target IP가 동일한 ARP 요청을 GARP라고 한다.
2. 장비가 ARP 요청 브로드캐스트를 통해 다른 장비에게 네트워크에 있는 자신의 존재를 알리는 목적으로 사용되는 패킷이다. 이 패킷을 수신한 장비는 자신의 ARP Cache에 해당 정보가 있다면 이를 갱신한다.
3. 자신의 MAC 정보를 동일 네트워크상의 다른 장비들에 알려 ARP Cache를 갱신하도록 하는 목적이다.

#### (나) 목적
1. IP 충돌 감지
   * IP 충돌 여부를 GARP를 통해 검색한다. 즉 자신과 동일한 IP가 설정된 호스트가 있다면 해당 호스트로부터 ARP 응답이 오기 때문에 충돌 여부를 확인할 수 있다.
   * 일반적으로 호스트 IP를 변경하거나 재부팅 시에 GARP 패킷이 생성된다.
2. 상대방의 ARP Cache 정보 갱신
   * GARP 메시지를 수신한 쪽에서는 자신의 ARP Cache에 Sender IP 정보를 갱신한다.
   * 이 부분이 취약점이 될 수 있다. 즉 상대방을 인증하지 않고 Cache 정보를 갱신하게 되므로 악의적인 목적의 공격자에 의해 MAC 정보가 위변조될 수 있다.

# 6. IP(IPv4) 프로토콜
### 1) 개요
1. 비연결형 프로토콜로 연결 상태를 유지하지 않기 때문에 패킷 전송 순서를 보장하지 않는다.
2. 비신뢰적 프로토콜로 신뢰성 있는 통신을 보장하지 않는다.
3. IP는 목적지 주소를 기반으로 라우팅을 담당하는 인터넷 계층의 대표 프로토콜이다. 라우팅은 라우팅 알고리즘을 통해 최적의 경로를 선정하여 목적지를 찾아가는 것을 말한다.

### 2) IP 프로토콜 구조
1. VER(4 bits) : IP의 버전 정보, 일반적으로 IPv4 사용
2. HLEN(4 bits) : 헤더 길이, 4 bytes 단위로 표현
3. Service type(8 bits) : 서비스 품질(QoS)을 위한 용도이지만 현재 사용하지 않음
4. Total length(16 bits) : 헤더부와 데이터부를 포함한 전체 IP Packet의 길이
5. **Identification(16 bits)** : 단편화/재조합 관련 필드
   * IP 데이터그램을 여러 조각으로 분할하는 것을 단편화라 하고 분할된 단편들을 조합하여 원본 IP 데이터그램을 완성하는 것을 재조합이라 한다.
   * 단편화 전 원본 IP 데이터그램을 식별하기 위한 ID
6. **Flags(3 bits)** : 단편화/재조합 관련 필드
   * 첫 번째 비트 : 사용 안 함(예약)
   * 두 번째 비트 : Don`t fragment bit(1 설정 시 패킷을 단편화하지 말라는 의미)
   * 세 번째 비트 : More fragment bit(1 설정 시 재조합할 단편이 남아 있다는 의미이고 0 설정 시 단편이 더 이상 없다는 의미이다.)
7. **Fragmentation offset(13 bitsx)** : 단편화/재조합 관련 필드
   * IP의 특성상 원본 IP 데이터그램의 단편들이 순서대로 전송되는 것이 아니므로 이를 순서대로 조합하기 위한 현재 단편의 상대위치를 저장한 필드
   * 8 bytes 단위로 표현한다.
8. **Time to live(8 bits)** : IP 패킷의 생존시간을 지정하는 필드
   * 최초에 초 단위로 생존시간을 명시할 의도였으나 시간 측정의 어려움으로 인해 라우터/L3스위치 통과 횟수(hop count라고 함)로 그 의미가 바뀜
   * 패킷이 라우터/L3스위치에 도착하면 TTL값을 1 감소시키고 그 값이 0이 되면 해당 패킷을 폐기한다.
   * TTL을 설정하는 목적은 라우터/L3스위치를 통해 패킷 라우팅을 하던 중 무한 루핑이 발생하여 목적지에 도달할 수 없는 패킷이 무한히 생존하여 네트워크 대역만 차지하는 상태를 방지하기 위함이다.
   * 일반적으로 Linux는 64, Windows는 128, Unix는 255를 설정한다. 운영체제별로 부여하는 기본 TTL값이 다르기 때문에 해당 필드를 "OS 핑거프린트" 목적으로 사용할 수 있다.
9. Protocol(8 bits) : 상위 프로토콜을 식별하기 위한 프로토콜 번호를 저장하는 필드
   * 상위 프로토콜과 다중화, 역다중화를 식별값으로 ICMP(1), TCP(6), UDP(17) 등이 있다.
10. Header checksum(16 bits) : 데이터부를 제외한 헤더 부분의 오류 검사값
11. Source IP address(32 bits) : 출발지 IP 주소
12. Destination IP address(32 bits) : 목적지 IP 주소
13. 주요 IP 옵션 헤더
   * Loose Source Route : Source Route는 라우팅 경로를 라우터/L3 스위치가 아닌 출발지에서 지정하는 옵션으로 느슨한(Loose) 소스 라우팅은 경우에 따라 다른 경로로 라우팅할 수 있다.
   * Strict Source Route : 엄격한(Strict) 소스 라우팅은 출발지에서 지정한 경로로 무조건 라우팅하는 옵션이다.

### 3) IP 단편화(Fragmentation)
#### (가) 개요
1. IP 패킷/데이터그램은 MTU에 따른 단편화가 발생한다.
   * MTU(Maximum Transmission Unit) : 물리적인 네트워크 프로토콜 프레임의 데이터부의 최대 크기를 말한다.
   * 물리적인 네트워크 프로토콜들은 각자 물리적인 특성에 맞게 정의된 MTU를 가진다. IP 패킷이 LAN 또는 WAN의 다양한 프로토콜의 상위 프로토콜로 사용할 수 있는 이유가 이 단편화를 이용한 패킷 크기 조절이 가능하기 때문이다. 가장 많이 사용하는 이더넷의 경우 MTU는 1,500바이트이다.
   * IP 패킷이 프레임으로 캡슐화되기 때문에 MTU를 초과하는 크기가 될 수 없다. 예를 들어 대표적인 이더넷의 경우 MTU가 1,500바이트이기 때문에 IP 패킷이 이보다 크다면 1,500바이트 이하의 크기로 단편화하여 전송해야 한다.
2. 단편화는 최초 출발지뿐만이 아니라 라우터/L3스위치 중계 구간의 MTU에 따라 추가적으로 발생하지만, 단편화된 패킷은 통신 효율을 위해 중계 구간의 MTU가 달라진다고 해도 재조합되지 않으며 최종 목적지에만 재조합된다.

#### (나) 동작방식
1. 첫 번째 단편을 살펴보면 데이터부는 1480byte(IP 헤더 20byte를 포함하여 1500byte)이고 두 번째 단편이 있기 때문에 "More fragments bit(3번째 Flag)"가 1이고 Offset은 첫 번째 단편이기 때문에 0으로 설정되어 있다. 모든 단편이 동일한 원본 IP 데이터그램의 단편이기 때문에 단편 ID가 22666으로 동일하다.
2. 두 번째 단편을 살펴보면 데이터부는 1480byte이고 세 번째 단편이 있기 때문에 "More fragments bit(3번째 Flag)"가 1이고 두 번째 단편은 첫 번째 단편 다음에 위치하기 때문에 1480으로 Offset이 설정된다.
3. 세 번째 단편을 살펴보면 데이터부는 48byte이고 마지막 단편이기 때문에 "More fragments bit(3번째 Flag)"가 0이고 세 번째 단편은 두 번째 단편 다음에 위치하기 때문에 2960이 Offset으로 설정되어 있다.
4. tcpdump의 IP 단편화 관련 출력 형식은 다음과 같다.
```
(frag:"단편 ID":"단편의 크기(IP 헤더 제외)"@"오프셋"+)
+ 있음 : 추가 단편 있음(More Fragments bit : 1)
- 없음 : 마지막 단편(More Fragments bit : 0)
```

### 4) IP 라우팅
#### (가) 라우팅 규칙
1. 첫째로 목적지 주소가 자신과 동일한 네트워크에 있다면 직접 전송한다.
2. 둘째로 목적지 주소가 자신과 동일한 네트워크에 속하지 않는다면 직접 전송이 불가하기 때문에 1차 경유지 주소를 라우팅 테이블을 참조하여 찾는다.
   * 라우팅 테이블은 임의의 목적지로 가기 위한 경로 정보를 저장하고 있는 자료구조이다. "netstat -rn" 명령을 통해 호스트의 라우팅 테이블 정보를 확인할 수 있다.
3. 셋째로 목적지 주소와 자신의 주소가 서로 동일한 경우 목적지가 자신이므로 상위 계층으로 데이터를 전달한다.

#### (나) 라우팅 테이블 검색 방식 및 우선순위
1. 검색 방식 : IP 패킷의 목적지 IP와 라우팅 테이블의 netmask/genmask를 bit and(&) 연산 수행 후 라우팅 테이블의 destination 필드와 비교, 일치하는 경로를 선택하여 패킷을 전송한다.
   * 패킷의 목적지 IP와 netmask/genmask간에 bit and 연산을 한다는 의미는 목적지 IP에서 네트워크 ID 부분만을 추출하기 위한 과정이다.
2. 검색 우선순위
   * 먼저 목적지 호스트 주소와 일치하는 경로를 찾는다.
   * 목적지 호스트 주소와 일치하는 경로가 없으면 목적지 네트워크 주소와 일치하는 경로를 찾는다.
   * 일치하는 경로가 없으면 default gateway(0.0.0.0)로 보낸다.

#### (다) 실습
1. 라우팅 테이블 설정 일부(netstat -rn 명령)
   * Dstination : 목적지 호스트 또는 네트워크 주소
   * Gateway : 목적지로 전송하기 위한 Gateway 주소
   * Genmask : 범용 목적의 마스크로 다음과 같은 역할을 한다.
      * 목적지 Host를 식별하기 위한 마스크 : 255.255.255.255
      * 목적지 Network를 식별하기 위한 마스크 : 넷마스크를 의미
      * default gateway를 식별하기 위한 마스크 : 0.0.0.0
   * Flags : 해당 경로에 대한 상태정보 플래그
      * U(route is Up) : 경로가 활성화되어 있음
      * G(use Gateway) : gateway를 사용함
      * H(target is a Host) : 목적지가 호스트를 의미
2. 라우팅 경로 계산 I : 10.0.96.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.96.100)와 첫 번째 행의 Genmask(255.255.255.255) 간에 bit and 연산 수행
   * 연산 결과(10.0.96.100)와 해당 Destination 주소(10.0.96.100)가 일치하므로 해당 경로의 Gateway(10.0.160.1)로 전송
3. 라우팅 경로 계산 II : 10.0.122.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.122.100)와 세 번째 행의 Genmask(255.255.192.0) 간에 bit and 연산 수행
   * 연산 결과(10.0.64.0)와 해당 Destination 주소(10.0.64.0)가 일치하므로 해당 경로의 Gateway(10.0.160.3)로 전송
4. 라우팅 경로 계산 III : 10.0.192.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.192.100)와 모든 행의 Genmask 간에 bit and 연산 수행 결과 일치하는 Destination 주소가 없으므로 default gateway(10.0.160.5)로 패킷 전송

### 5) IP Spoofing
#### (가) 개요
1. IP 스푸핑은 IP를 속이고 통신하는 공격으로 1995년 '캐빈 미트닉'이 이를 이용하여 실제 해킹을 시도함으로써 널리 알려진 공격방식이다.
2. 시스템 간의 트러스트 관계를 이용, 트러스트 관계가 맺어진 서버와 클라이언트를 확인한 후 신뢰 관계가 있는 클라이언트를 연결 불가능한 상태로 만들고 공격자가 클라이언트의 IP로 위조하여 서버에 접속하는 공격방식이다.
   * 트러스트 관계 설정은 아이디, 패스워드 기반의 로그인이 아닌 신뢰 관계에 있는 IP를 등록하여 해당 IP로 접근하는 것을 허용해주는 방식이다. 즉 IP 주소로 인증하고 로그인 없이 접속할 수 있도록 해주는 방식이다.
   * 트러스트 설정은 다수의 시스템을 관리하는 관리자의 입장에서 아이디와 패스워드를 관리해야 하는 어려움을 해결하고 접속과정에서 아이디, 패스워드가 스니핑되는 위험성을 차단하지만, IP 스푸핑에는 매우 취약하기 때문에 보안상 사용하지 않는 것을 권장한다.

#### (나) 실습(리눅스 환경)
1. 트러스트 설정
   * 유닉스, 리눅스 시스템에서 트러스트 관계 설정 파일로 /etc/hosts.equiv와 $HOME/.rhost 파일이 있다. hosts.equiv 파일은 시스템 전체에 영향을 주는 파일이고 .rhost 파일은 사용자별로 설정하는 파일이다.
   * 설정 방식은 다음과 같다.
|레코드 형식|의미|
|-|-|
|host_name|해당 호스트(IP 또는 호스트명)의 접근 허용|
|host_name user_name|해당 호스트에 해당 사용자로 접근 허용|
|+|모든 호스트의 접근을 허용(계정은 아이디, 패스워드 인증 필요)|
|+ user_name|모든 호스트의 해당 사용자로 접근 허용|
|-host_name|해당 호스트의 접근 차단|
|host_name -username|해당 호스트에서 해당 사용자만 접근 차단|
|+ @group|모든 호스트에서 해당 group 사용자로 접근 허용|
   * 설정 방식을 보면, 앞에 있는 것이 호스트명, 띄어쓰기 후 나오는 것이 사용자명(계정명)이다. +는 모두 허용한다는 의미이고 -(호스트명 또는 계정명)는 차단한다는 의미이다.
   * 만약 "+ +"로 설정한다면 모든 호스트에 대해서 모든 계정을 신뢰한다는 의미이므로 매우 취약한 설정이다.
2. rlogin 서비스 활성화
   * r 계열 서비스(rlogin, rsh, rexec 등)는 인증 없이 신뢰 관계에 있는 시스템들의 원격 접속을 허용해주는 서비스들이다. rlogin의 경우 telnet과 유사하지만, 인증 없이 접속할 수 있다.
   * xinetd 데몬의 rlogin 서비스를 활성화한 후 xinetd 데몬을 재기동한다. netstat 명령으로 소켓 상태를 확인해보면 513/tcp(login 서비스) 포트가 리슨 상태에 있는 것을 확인할 수 있다.
3. rlogin 클라이언트 명령을 통한 원격 접속
   * 원격 클라이언트에서 "rlogin 서버IP" 명령을 통해 접속하면 아이디, 패스워드 확인 없이 바로 연결되는 것을 확인할 수 있다.
4. 공격자는 신뢰 관계에 있는 클라이언트를 사용 불능 상태로 만든 후 해당 클라이언트의 IP로 위조하여 서버에 접속할 수 있다.

#### (다) 대응책
1. 시스템 간 트러스트 설정을 사용하지 않는다.
2. 반드시 사용해야 할 경우에는 트러스트된 시스템의 MAC 주소를 정적으로 구성하여 단순히 IP만을 위조한 접속을 차단한다.

#### (라) $HOME/.rhosts, hosts.equiv 사용금지(시스템 취약점 분석,평가 항목)
1. 개요
   * r 계열 서비스(rlogin, rsh, rexec 등)를 통한 원격 접속은 보안상 매우 취약하여 서비스 포트가 열려있을 경우 중요 정보 유출 등 침해사고의 원인이 될 수 있다. 따라서 r 계열 서비스를 허용하지 않는다.
   * 만약 불가피하게 사용할 경우에는 트러스트 관계 설정 파일인 $HOME/.rhosts, hosts.equiv에 적절한 보안 조치를 해야 한다.
2. 보안조치
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일 소유자를 root 또는 해당 계정으로 변경한다.
      * (예시) ```chown root /etc/hosts.equiv```
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일 권한을 600 이하로 변경한다.
      * (예시) ```chmod 600 /etc/hosts.equiv```
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일에서 "+"를 제거하고 반드시 필요한 호스트 및 계정만 등록한다.
  
### 6) IPv6 살펴보기
#### (가) 개요
1. IPv6는 IPv4 주소가 고갈되는 문제를 해결하기 위하여 새로운 128비트 체계로 2^128개의 주소를 갖는 인터넷 프로토콜 주소를 말한다.
2. IPv6 주소는 16비트 단위로 구분하며 각 단위는 16진수로 변환되어 클론(:)으로 구분하여 표기한다.
3. 128비트의 IPv6 주소에서 앞의 64비트는 네트워크 주소를 의미하고 뒤의 64비트는 네트워크에 연결된 통신장비 등에 할당되는 인터페이스 주소를 의미한다.

#### (나) IPv6의 장점
|구분|주요 내용|
|-|-|
|확대된 주소 공간|주소길이가 128비트로 증가하여 2^128개의 주소 사용 가능|
|단순해진 헤더 포맷|IPv4 주소 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능|
|간편해진 주소 설정 기능|IPv6 프로토콜에 내장된 주소 자동 설정 기능을 이용하여 플러그 앤 플레이 설치가 가능|
|강화된 보안성|IPv6 주소에서는 IPsec 기능을 기본 사항으로 제공|
|개선된 모바일 IP|IPv6 주소 헤더에서 이동성 지원|

#### (다) IPv6 전환 기술
1. 듀얼스택(Dual Stack)
   * IPv4와 IPv6 프로토콜을 동시에 설정하여 통신 상대에 따라 선택적으로 사용할 수 있도록 하는 방식
   * 호스트, 라우터 등에 듀얼스택을 적용하여 IPv4와 IPv6 패킷을 모두 처리할 수 있도록 해준다. 장기적으로 보았을 때 가장 추천되는 방식이다.
2. 터널링(Tunneling)
   * IPv4 네트워크를 경유하여 IPv6 네트워크 간 통신을 위한 방식으로 IPv4 네트워크를 통과하는 가상의 경로를 만들어 통신하는 방식을 말한다.
   * 터널링 기술은 호스트와 라우터에서 IPv6 패킷을 IPv4 패킷으로 캡슐화하여 전송함으로써 캡슐화된 IPv6 패킷이 IPv4 네트워크를 통과하게 하는 기술이다.
3. 주소 변환(Address Translation) 또는 헤더(Header) 변환
   * 주소변환 방식은 IPv4 주소를 IPv6 주소로 변환하거나 IPv6 주소를 IPv4 주소로 변환하여 통신하는 방식을 말한다.
   * 패킷의 앞부분에 변환 헤더를 추가함으로써 주소를 변환하여 송신하고 수신측에서 변환 헤더를 제거하는 방식으로 통신한다.
   * 소수의 IPv6 사이트가 대규모의 IPv4 인터넷에 연결되는 전환의 초기 단계와 소수의 IPv4 사이트가 대규모의 IPv6 인터넷에 연결되는 전환의 마지막 단계에서 사용할 수 있다.

# 7. ICMP 프로토콜
### 1) 개요
1. 3계층의 IP 프로토콜은 신뢰할 수 없는 프로토콜이다. 즉 전송상태에 대한 관리가 이루어지지 않는다. 이러한 IP 프로토콜의 단점을 보완하기 위한 프로토콜 ICMP 프로토콜이다.
2. IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공해준다. 정리해보면 아래와 같다.
   * Error-Reporting Message 기능 : 전송 중 오류 발생 시 에러 메시지를 생성하여 응답
   * Query Message 기능 : 네트워크 상태를 진단하기 위한 쿼리 요청 및 응답메시지 생성
3. ICMP 메시지는 메시지의 유형을 의미하는 Type 필드와 유형별 세부 내용을 담고 있는 Code 필드로 구성이 된다.

### 2) ICMP 프로토콜 구조
1. Type(8 bits) : ICMP 메시지의 유형/용도
   * 예) Type 3 : Destination Unreachable(목적지 도달 불가)
2. Code(8 bits) : Type의 세부 내용으로 Type과 Code가 조합되어 ICMP 메시지의 목적과 용도를 나타낸다.(Code가 없는 Type도 존재)
   * 예) Type 3의 Code 3 : Port Unreachable(UDP 포트가 열려있지 않음)
3. Checksum(16 bits) : ICMP 메시지 오류를 검사하기 위한 값
4. Rest of the header : Type과 Code에 따라 추가되는 헤더
5. Data section : 데이터가 위치하는 영역

### 3) 주요 ICMP Error-Reporting 메시지
#### (가) Destination Unreachable(Type 3)
1. 해당 목적지에 도달할 수 없음을 의미한다.
2. 목적지 도달 불가 사유에 따라 다양한 Code(상세 유형)로 구성이 되어 있다. 주요 Code를 살펴보면 다음과 같다.
   * Code 1(Hosts Unreachable) : 최종 단계의 라우터가 목적지 호스트로 패킷 전송에 실패한 경우
   * Code 2(Protocol Unreachable) : 목적지 호스트에서 특정 프로토콜을 사용할 수 없는 경우
   * Code 3(Port Unreachable) : 목적지 호스트에 해당 UDP 포트가 열려있지 않은 경우, TCP의 경우에는 포트가 열려있지 않으면 TCP RST 패킷을 반환한다.
   * Code 4(Fragmentation needed and don\`t fragment was set) : IP 패킷의 단편화가 필요하지만, IP 헤더의 Don\`t fragment was set) : IP 패킷의 단편화가 필요하지만, IP 헤더의 Don\`t fragment(DF) 플래그가 설정되어 단편화할 수 없는 경우 라우터에 의해 반환된다.

#### (나) Redirection(Type 5)
1. 라우팅 경로가 잘못되어 새로운 경로를 이전 경유지 또는 호스트에게 알려주는 메시지이다.
2. ICMP Redirect 공격 시 이용하는 메시지이다.

#### (다) Time Exceeded(Type 11)
1. 타임아웃이 발생하여 IP 패킷이 폐기되었음을 알리는 메시지이다. 타임아웃 사유는 Code를 통해 알 수 있다.
   * Code 0(Time To Live exceeded in Transit) : IP 패킷이 최종 목적지에 도달하기 전에 TTL 값이 0이 되어 해당 패킷이 폐기되었음을 알리는 메시지이다.
   * Code 1(Fragment reassembly time exceeded) : IP 패킷이 재조합 과정에서 타임아웃이 발생하여 해당 IP 데이터그램이 모두 폐기되었음을 알리는 메시지이다. 일반적으로 IP 데이터그램의 일부 단편이 전송과정에서 손실될 경우 재조합에 실패하여 발생한다.
  
### 4) 주요 ICMP Query 메시지
#### (가) Echo Request(Type 8) and Reply(Type 0)
1. ping 유틸리티 프로그램에 사용되는 메시지로 종단노드 간에 네트워크 및 호스트 상태진단을 목적으로 사용한다.
2. 별도의 Code는 없으며 이외의 쿼리 타입들은 거의 사용되지 않는다.
3. Echo Request 메시지 캡처 예
   * ICMP 기본 헤더 이외에 전송한 Echo Requestg 메시지를 식별하기 위한 Identifier(ID) 필드와 메시지 순번을 식별하기 위한 Sequence number 필드가 추가된 것을 볼 수 있다.
   * TTL 값이 128(윈도우 기본 TTL) 이하인 것으로 보아 윈도우 시스템에서 보낸 메시지임을 추측할 수 있다.
4. Echo Reply 메시지 캡처 예
   * Echo Request 메시지 전송 시 설정한 id와 sequence number가 동일하게 설정되어 있는 것을 볼 수 있다.
   * TTL 값이 64(리눅스 TTL) 이하인 것으로 보아 리눅스 시스템에서 보낸 메시지임을 추측할 수 있다.

### 5) ICMP 리다이렉트 공격
#### (가) 개요
1. ICMP Redirect 공격이란 ICMP Redirection 메시지(Type 5)를 이용하여 패킷 경로를 악의적으로 재설정하는 공격을 말한다. ICMP Redirection 메시지를 수신한 호스트는 자신의 라우팅 테이블에 특정 목적지로 나가는 gateway 주소를 변경하는데 공격자는 이를 이용하여 자신이 원하는 형태의 ICMP Redirection 메시지를 만들어 특정 목적지로 가는 패킷을 공격자로 향하도록 한다.
2. ARP Redirect와 ICMP Redirect 공격의 차이점을 살펴보면 ARP Redirect는 희생자의 ARP Cache Table정보를 변조하여 스니핑하는 것이고, ICMP Redirect는 희생자의 라우팅 테이블을 변조하여 스니핑 한다는 차이점이 있다.

#### (나) 공격결과
1. ICMP Redirect 공격 시 희생자 PC 패킷 캡처
   * 공격자에 의해 조작된 ICMP Redirection 메시지(Type : 5, Code : 1)가 희생자에게 전달되고 있다. ICMP Redirection 메시지는 게이트웨이/라우터만이 보낼 수 있으므로 공격자는 출발지 IP를 희생자의 게이트웨이 주소로 위조하고 있다.
   * ICMP Redirection 메시지를 분석해보면, 목적지 주소에 대한 gateway 주소를 공격자의 주소로 조작한 것을 알 수 있다.
2. 공격 후 희생자PC의 라우팅 테이블 정보
   * 희생자PC의 라우팅 테이블 정보를 살펴보면 8.8.8.8 목적지의 경로가 정상적인 gateway 주소가 아닌 공격자의 주소로 변경된 것을 확인할 수 있다.
   * 따라서 희생자PC에서 8.8.8.8 목적지로 패킷 전송 시 공격자 PC로 패킷이 전달되어 공격자는 스니핑이 가능하게 된다

#### (다) 대응방법
1. ICMP Redirection 메시지에 의해 라우팅 테이블이 변경되지 않도록 ICMP Redirect 옵션을 해제한다.
2. 현재 대부분의 OS에서 보안상의 이유로 ICMP Redirect 옵션을 기본적으로 해제하고 있다.
   * 리눅스 커널 파라미터 중 ICMP Redirect 설정인 accept_redirects를 0(허용안함)로 설정한다.

# 8. TCP 프로토콜
### 1) 개요
#### (가) Connection Oriented Protocol (연결 지향 프로토콜)
1. 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정해서 통신하는 방식으로 가상의 연결통로를 가상회선이라 한다.
   * 가상회선방식 : 물리적으로 전용회선이 연결되어 있는 것처럼 논리적으로 동작하는 방식을 말한다.
2. 논리적인 연결통로를 통해 데이터를 주고받음으로써 데이터의 전송순서를 보장해준다. 이를 순서제어라고 한다.
3. 스트림 기반의 전송방식을 사용한다. 즉 데이터를 정해진 크기로 전송하는 것이 아니라 임의의 크기로 나누어 연속해서 전송하는 방식을 사용한다.

#### (나) Reliable Protocol (신뢰할 수 있는 프로토콜)
1. 흐름제어(Flow Control) 수행
   * 흐름제어란 **상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송하는 것**을 말한다.
   * 흐름제어를 위해 슬라이딩 윈도우 제어방식을 사용한다. 이는 상대방이 수신 가능한 크기 내에서 데이터를 연속해서 전송하는 방식으로 세그먼트 전송 시마다 수신확인응답(ACK)을 수신한 후 전송하게 되면 왕복시간(RTT: Round Trip Time)이 길 경우 단위 시간당 데이터 전송량이 매우 떨어지므로 효율적으로 전송하기 위해 상대방이 받을 수 있는 범위 내에서 연속적으로 전송한다.
2. 오류제어(Error Control) 수행
   * 오류제어란 **데이터의 오류나 누락없이 안전한 전송을 보장해주는 것**을 말한다.
   * 오류 또는 누락 발생 시 재전송을 수행하여 이를 보정한다.
3. 혼잡제어(Congestion Control) 수행
   * **혼잡제어란 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어하는 것**을 말한다.
   * 혼잡 정도에 대한 판단기준은 데이터의 손실 발생 유무로 판단한다. 전송한 데이터에 누락이 발생하면 네트워크가 혼잡한 상태로 판단하여 전송량을 조절한다.

### 2) TCP 프로토콜 구조
1. Source Port(16 bits) : 출발지(송신) 포트 번호
2. Destination Port(16 bits) : 목적지(수신) 포트 번호
3. Sequence Number(32 bits) : 송신 데이터 순서번호
   * 송신 시 전송하는 데이터의 시작 바이트 순번을 담는다. 바이트 순번은 전송하는 데이터의 바이트 단위로 부여하는 연속된 번호를 의미한다.
   * 연결설정 단계에서 초기 순서번호(ISN: Initial Sequence Number)를 상호 간에 주고받는다. 초기 순서번호는 0부터 시작하는 것이 아니라 임의의 수를 할당해서 사용한다.
4. Acknowledgment Number(32 bits) : 상대방이 다음에 전송할 순서번호
   * 수신 확인 응답(ACK)과 함께 해당 필드에 상대방이 다음에 전송할 순서번호를 담아서 보낸다.
5. HLEN(4 bits) : 헤더의 길이
   * 4 bytes 단위로 표시(20~60 bytes)하며 헤더는 기본 헤더 20 bytes와 옵션 헤더 최대 40bytes로 구성된다.
6. Reserved(6 bits) : 예약(사용하지 않음)
7. Control Flags(6 bits)
   * URG(Urgent pointer is valid) : 긴급 데이터(OOB: Out Of Band) 설정
   * ACK(Acknowledgment is valid) : 수신 확인 응답(ACK) 설정
   * PSH(Request for push) : 송수신 버퍼에 있는 데이터를 즉시 처리
   * RST(Reset the connection) : 연결 중단(강제 종료)
   * SYN(Synchronize sequence numbers) : 연결 설정
   * FIN(Terminate the connection) : 연결 종료(정상 종료)
8. Windows Size(16 bits)
   * 수신 측에서 송신 측에 보내는 Receiver Windows size로 수신버퍼의 여유 공간 크기를 의미한다. 송신 측에서는 상대방의 여유 공간 크기를 통해서 흐름제어를 수행할 수 있다.
   * 따라서 **송신 측에서는 상대방의 윈도우 크기 범위 내에서 수신 측의 수신 확인 응답을 기다리지 않고 연속적으로 전송할 수 있는데 이를 슬라이딩 윈도우 제어방식**이라 한다.
9. Checksum(16 bits)
   * 헤더를 포함한 전체 세그먼트에 대한 오류를 검사하기 위한 필드
10. Urgent Pointer(16 bits)
   * 세그먼트가 긴급 데이터(URG 플래그 설정)를 포함하고 있는 경우에 사용되는 필드로 긴급 데이터의 위치값을 담고 있다.

* well-known port(0 ~ 1023) : 잘 알려진 서비스에 예약된 포트
* registered port(1024 ~ 49151) : 제조사가 IANA에 용도를 등록해서 사용하는 포트
* dynamic port(49152 ~ 65535) : 동적으로 사용하는 포트로 일반적으로 클라이언트 포트로 사용
* privileged port(0 ~ 1023) : 관리자 권한으로 사용 가능한 포트
* unprivileged port(1024 ~ 65535) : 일반 사용자 권한으로 사용 가능한 포트

### 3) TCP 분할과 재조합
1. MSS(Maximum Segment Size)
   * TCP 세그먼트 데이터부의 최대 바이트 수를 의미하며 연결 설정 과정에서 상호 간에 MSS 정보를 주고받는다.
   * MSS는 Frame의 MTU에 영향을 받는다. MTU 크기에서 IP 헤더(20byte)와 TCP 헤더(기본 20byte)를 빼면 MSS 크기를 알 수 있다.
2. Application 계층에서 전달된 데이터는 TCP 계층에서 MSS 크기에 따라 분할이 발생한다. 분할된 세그먼트는 수신 측에서 재조합되어 Application 계층으로 전달된다.

### 4) 연결 설정 과정(3-Way Handshake)
1. 첫 번째 단계
   * 최초 클라이언트는 서버와 연결설정을 위한 연결 요청 패킷을 보낸다. 연결 요청을 위해 능동적으로 포트를 열고 있는 상태를 "Active Open", 연결 요청을 수용하기 위해 수동적으로 포트를 열고 있는 상태를 "Passive Open"이라 한다.
   * SYN은 synchronize(동기화)의 줄임말로 상호 간에 순서번호를 동기화하자는 의미이다. 상호 간의 초기 순서번호(ISN)는 0부터가 아닌 랜덤한 값으로 시작한다.
   * 최초 SYN 패킷을 보낸 TCP 상태를 "SYN_SENT" 상태라 한다.
2. 두 번째 단계
   * 클라이언트의 연결 요청(SYN 패킷)에 대한 수신 확인 응답(ACK)과 함께 서버에서 클라이언트로 연결 요청을 보내 상호 간에 연결 요청을 수행한다.
   * 수신 확인 응답을 하게 되면 반드시 Acknowledgment Number를 설정하는데 그 의미는 상대방이 다음에 보낼 패킷의 순서번호를 의미한다. 위 예를 보면 Ack.Num:1001로 설정되어 있는데 그 의미는 1000번까지 수신 완료했고 1001번을 보내라는 의미가 된다.
3. 세 번째 단계
   * server의 연결 요청(SYN 패킷)에 대해 수신 확인 응답(ACK)을 전송한 후 최종적으로 연결설정이 완료된다.
   * 연결설정이 완료되면 TCP 상태는 "ESTABLISHED" 상태가 된다.

### 5) 데이터 송수신 과정
#### (가) 재전송 과정
1. TCP는 모든 세그먼트 전송 시마다 재전송 타이머가 동작한다. 재전송 타임아웃(RTO: Retransmission Time Out)동안 상대방으로부터 ACK 응답이 없으면 송신자는 해당 패킷이 누락된 것으로 판단하여 재전송을 수행한다.
2. 위 예를 보면, 클라이언트가 Data-B 전송 후 재전송 타임아웃이 발생하여 Data-B를 다시 전송하고 있다.
3. 재전송은 일정 시간/횟수 동안 발생하며 더 이상 상대방으로부터 ACK 응답이 없으면 연결을 종료한다.
4. 혼잡제어 관점에서는 재전송 타이머 만료에 따른 재전송이 발생하는 상황은 매우 혼잡한 상태로 판단한다.

#### (나) 빠른 재전송 과정
1. TCP는 수신 측이 기대했던 순서번호가 아닌 그 이후 순서번호의 세그먼트를 수신하면 즉시 기대하는 순서번호의 세그먼트를 요청하는 ACK 패킷을 전송한다.
2. 위 예를 보면, 클라이언트가 전송한 세그먼트 중 B 세그먼트의 손실이 발생했으며 그 이후 순서번호를 가진 C, D, E 세그먼트가 도착할 때마다 서버는 B 세그먼트를 요청하는 ACK 패킷을 클라이언트에 즉시 전송하고 있다.
3. 클라이언트는 중복 ACK가 두 번 발생할 때까지는 일시적으로 서버에 전달한 세그먼트의 순서가 맞지 않는 상태로 판단하다가 세 번 발생하면 해당 세그먼트가 누락된 것으로 판단하여 재전송을 수행한다. **재전송 타임아웃 발생 이전에 중복 ACK가 세 번 발생하면 즉시 재전송을 수행하므로 이를 빠른 재전송**이라 한다.
4. 혼잡제어 관점에서는 중복 ACK 3회 발생에 따른 빠른 재전송이 발생하는 상황은 재전송 타이머 만료에 따른 재전송에 비해 덜 혼잡한 상태로 판단한다. 이는 일부 세그먼트의 누락은 발생했지만, 나머지 세그먼트는 정상적으로 수신되었기 때문에 덜 혼잡한 상태로 본다.

### 6) 연결 종료 과정(4-Way Handshake)
#### (가) 연결 종료 단계
1. 첫 번째 단계
   * 클라이언트는 서버와의 연결설정을 종료하기 위한 연결 종료 패킷(FIN+ACK 패킷)을 보낸다. 능동적인 연결 종료 수행을 "Active Close", 수동적으로 수행하는 것을 "Passive Close"라 한다.
2. 두 번째/세 번째 단계
   * 클라이언트의 연결 종료 요청에 대한 수신 확인 응답(ACK)을 보낸다.
   * 서버는 해당 서버 애플리케이션에서 TCP 연결 종료를 할 때까지 대기한 후 종료되면 클라이언트에 연결 종료 패킷(FIN+ACK 패킷)을 보낸다.
3. 네 번째 단계
   * 서버의 연결 종료 패킷을 수신한 클라이언트는 즉시 연결을 종료하는 것이 아니라 서버에 마지막 ACK를 보낸 후 2MSL(Maximum Segment Lifetime) 시간 동안 대기한다.
   * 2MSL 동안(통상 1~4분) 대기하는 이유는 마지막 ACK 응답이 안전하게 상대방에게 전송됨을 보장해주기 위한 것으로 만약 서버가 마지막 ACK를 수신하지 못했다면 FIN+ACK 재전송이 발생할 것이고 이를 처리하기 위해 일정 시간 대기한다.

#### (나) 연결 종료 단계의 TCP 상태
|상태|설명|
|:-:|:-|
|FIN_WAIT_1|첫 번쨰 FIN+ACK 패킷에 대한 ACK를 대기하는 상태|
|FIN_WAIT_2|첫 번쨰 FIN+ACK 패킷에 대한 ACK 수신 후 두 번째 FIN+ACK 패킷을 수신할 때까지 대기하는 상태|
|TIME_WAIT|마지막 ACK 전송 후 2MSL 동안 대기하는 상태|
|CLOSE_WAIT|상대방의 첫 번째 FIN+ACK 패킷에 대한 ACK 응답 후 두 번째 FIN+ACK 패킷을 전송할 때까지 대기하는 상태|
|LAST_ACK|두 번째 FIN+ACK 패킷 전송 후 마지막 ACK를 대기하는 상태|
|CLOSE|종료된 상태|

### 7) 연결 요청 거부(강제 종료)
1. 클라이언트 TCP가 연결을 위해 SYN 요청을 전송했으나 서버에 해당 포트가 준비되어 있지 않으면 "RST+ACK" 패킷을 클라이언트에 전송하여 연결 쵸엉을 거부하게 된다.
2. "RST+ACK"를 수신한 클라이언트 TCP는 즉시 종료(CLOSED) 상태가 된다.

### 8) 연결 중단(abort)
1. 연결 상태에 있는 클라이언트가 연결을 즉시 중단해야 할 필요가 있을 경우 "RST+ACK" 또는 "RST" 패킷을 서버에 전송할 수 있다. TCP 표준(RFC 793)에 따른 차이점은 다음과 같다.
   * RST 플래그만 설정하는 경우 : 상대방으로부터 수신한 세그먼트에 Acknowlegment Number 필드가 설정되어 있는 경우 RST 플래그와 Sequence NUmber 필드를 설정하여 응답한다.
   * RST+ACK 플래그를 설정하는 경우 : 상대방으로부터 수신한 세그먼트에 Acknowlegment Number 필드가 설정되어 있지 않은 경우 Sequence NUmber 필드를 0으로 설정하고 Acknowlegment Number 필드를 수신한 세그먼트의 Sequence Number와 세그먼트 길이의 합으로 설정하여 응답한다.
2. "RST+ACK" 또는 "RST" 패킷을 수신한 서버 TCP는 즉시 종료(CLOSED) 상태가 된다.

### 9) TCP 세션 하이재킹
#### (가) 개요
1. 세계적으로 유명한 해커 "케빈 미트닉"이 사용했던 공격 방법의 하나로 TCP의 세션 관리 취약점을 이용한 공격이다.
2. TCP는 연결설정 과정을 통해 상호 간에 세션을 생성한 후 다음 식별자를 통해 상호 간에 인식하게 된다.
   * 출발지 IP와 Port,목적지 IP와 Port
   * Sequence Number와 Acknowledgment Number
3. TCP 세션 하이재킹은 위와 같은 세션 식별정보를 공격자가 위조하여 세션을 탈취하는 공격이다. 즉 **공격자는 정상적인 사용자의 출발지 IP와 Port로 위조하고 sequence Number를 예측하여 세션을 탈취**하게 된다.

#### (나) 실습
1. 실습 환경
   * Telnet Client : 192.168.159.134
   * Telnet Server : 192.168.159.141
   * 공격 툴 : Hunt
2. 정상적으로 클라이언트와 서버가 통신하고 있는 상황
   * 공격자는 클라이언트와 서버 사이에서 ARP 스푸핑을 통해 둘 사이의 TCP 식별정보를 탈취하기 위한 스니핑을 진행한다.
3. 패킷을 스니핑하던 공격자는 정상적인 클라이언트의 IP 주소로 위장한 TCP 패킷에 정상적인 클라이언트의 TCP 식별정보를 담아서 서버로 전달한다.
4. 서버는 공격자의 위조된 패킷에 대해 정상 응답을 준다. 해당 응답은 공격자뿐만 아니라 정상 클라이언트에게도 전달되고 클라이언트 입장에서는 데이터를 보내지 않았는데 Acknowledgment Number가 증가한 응답을 받게 되는 상황이 발생한다.
5. 잘못된 응답을 받은 정상 클라이언트는 이를 교정하기 위한 ACK를 보낸다.
6. 서버 입장에서는 정상 클라이언트가 보낸 잘못된 ACK 패킷을 다시 교정하기 위해 ACK 메시지를 보내게 된다. 이러한 과정이 반복적으로 대량 발생하게 되는데 이를 "ACK STORM"이라 한다.
   * 공격자에 의해서 해당 세션의 Sequence Number와 Acknowlegment Number가 조작된 것이기 때문에 정상 클라이언트와 서버 간에는 아무리 교정을 위한 ACK를 보낸다고 해도 이를 해결할 수 없다.
7. 공격자는 최종적으로 정상 클라이언트에게 RST(강제 종료) 메시지를 전달하여 연결을 강제 종료하고 자신은 서버와의 세션을 유지한다.

# 9. UDP 프로토콜
### 1) 개요
#### (가) Connectionless Protocol (비연결형 프로토콜)
1. 논리적인 연결설정 과정이 없으므로 데이터그램 전송 시마다 주소정보를 설정해서 전송한다.
2. 데이터의 순차적 전송을 보장해주지 않는다.
3. 데이터그램 기반의 전송방식을 사용한다. 즉 데이터를 정해진크기로 전송하는 방식을 사용한다.

#### (나) Unreliable Protocol (신뢰할 수 없는 프로토콜)
1. 신뢰성 있는 TCP와는 달리 흐름제어, 오류제어, 혼잡제어 등을 수행하지 않는다.
2. 실질적으로 IP 기반에 포트 정보를 이용하여 상위 송수신 애플리케이션(IP/Port를 통한)을 식별해주는 역할 정도만 수행한다.

#### (다) UDP 프로토콜의 장점
1. 단순하고 가벼운 프로토콜로 전송속도가 빠르다.
   * TCP의 경우 내부 처리 메커니즘에 의해 프로토콜이 복잡하고 무거운 반면에 UDP의 경우에는 상대적으로 가볍고 단순한 프로토콜로 빠른 전송이 장점이다.
2. 비신뢰적인 특성으로 인해 대량 데이터의 송수신은 부적절하며 주로 한 번의 패킷 송수신으로 완료되는 서비스에 많이 사용된다.
   * 예) DNS 서비스(53/udp), NTP 서비스(123/udp), DHCP 서비스(67,68/udp) 등

### 2) UDP 프로토콜 구조
1. Source Port(16 bits) : 출발지(송신) 포트 번호
2. Destination Port(16 bits) : 목적지(수신) 포트 번호
3. Total Length(16 bits) : 헤더와 데이터부를 포함한 전체 길이
4. Checksum(16 bits) : 전체 데이터그램에 대한 오류를 검사하기 위한 필드

# 10. 네트워크 관리 명령어
## (1) ping 명령어
### 1) 개요
1. 종단 노드 간에 네트워크 상태를 관리하기 위한 명령어
2. Target 시스템에 대한 접근성, 해당 구간에 대한 네트워크 속도 및 품질(손실률)을 검사하기 위한 명령어
3. ICMP Echo Request(Type\:8)와 ICMP Echo Reply(Type\:0) 메시지 이용

### 2) 실습
1. 윈도우 ping 명령 테스트

![image](https://github.com/zzzangmans1/boangisa_practice/assets/52357235/1c7627cc-bf1b-458b-9954-24d2241294f3)
   * -n : 패킷 전송 횟수 설정(default 4회)
   * -l : 패킷 크기(bytes) 설정(default 32 bytes)

2. 리눅스 ping 명령 테스트
   * -c : 패킷 전송 횟수 설정(default 무한)
   * -s : 패킷 크기 bytes 설정(default 56 bytes)

## (2) traceroute/tracert 명령
### 1) 개요
1. 종단 노드 사이에 있는 여러 중계 노드(L3장비/라우터) 각 구간에 대한 네트워크 상태를 관리하기 위한 명령어로 네트워크의 라우팅 문제점을 찾아내는 목적으로 많이 사용한다.
   * 최종 목적지 노드에 도달하는데 경유하는 중계 노드(L3장비/라우터)의 개수, IP 주소, 응답시간 등을 파악할 수 있다.
2. 각 구간에 대한 접근성 및 네트워크 속도를 검사
3. 유닉스/리눅스의 경우 traceroute 명령어를 사용하고 윈도우의 경우 tracert 명령어를 사용한다.

### 2) 유닉스/리눅스 traceroute 동작방식
1. 각 중계 노드(L3장비/라우터) 구간에 대한 상태를 측정하기 위해 IP의 TTL 필드를 1로 설정한 UDP 패킷을 보낸다.
   * 라우터는 패킷의 생존 기간을 계산하기 위해 패킷을 수신하면 TTL 값을 1 감소 시킨 후 그 결과 0이 되면 TTL 초과로 판단하여 해당 패킷을 폐기한 후 ICMP Time Exceeded(Type 11) 패킷을 최초 출발지로 보낸다.
   * 따라서 TTL값을 1로 설정하면 첫 번째 라우터에서 패킷이 폐기되고 ICMP 응답이 오기 때문에 이를 이용하여 출발지 호스트와 첫 번째 라우터 간의 네트워크 상태를 판단한다.
   * 보안상의 이유로 라우터에서 ICMP 응답을 주지 않는 경우가 많다. traceroute 명령 수행 시 응답시간이 \*로 표시되는 경우가 응답이 없는 경우로 보안상의 이유이거나 실제 해당 구간에 문제가 발생한 경우로 볼 수 있다.
2. TTL 값을 1씩 증가시키면서 UDP 패킷을 지속적으로 전송하여 다음 중계 구간에 대한 네트워크 상태를 판단한다.
3. **최종 목적지에 UDP 패킷이 도달하면 해당 UDP 포트(33434/udp 이상 포트 사용)가 닫혀있으므로 ICMP Destination Unreachable(Type 3) 패킷이 반환되며 최초 출발지 호스트는 이 정보를 이용하여 최종 목적지 호스트에 도달했음을 알 수 있게** 된다.

### 3) 윈도우 tracert 동작방식
1. 각 중계 노드(L3장비/라우터) 구간에 대한 상태를 측정하기 위해 IP의 TTL 필드를 1로 설정한 ICMP Echo Request(Type 8) 패킷을 보낸다.
   * 라우터는 패킷의 생존 기간을 계산하기 위해 패킷을 수신하면 TTL 값을 1 감소 시킨 후 그 결과 0이 되면 TTL 초과로 판단하여 해당 패킷을 폐기한 후 ICMP Time Exceeded(Type 11) 메시지를 최초 출발지로 보낸다.
   * 따라서 TTL 값을 1로 설정하면 첫 번째 라우터에서 패킷이 폐기되고 ICMP 응답이 오기 때문에 이를 이용하여 출발지 호스트와 첫 번째 라우터 간의 네트워크 상태를 판단한다.
   * 보안상의 이유로 라우터에서 ICMP 응답을 주지 않는 경우가 많다. tracert 명령 수행 시 응답시간이 * 로 표시되는 경우가 응답이 없는 경우로 보안상의 이유이거나 실제 해당 구간에 문제가 발생한 것으로 볼 수 있다.
2. TTL 값을 1씩 증가시키면서 ICMP 패킷을 지속적으로 전송하여 다음 중계 구간에 대한 네트워크 상태를 판단한다.
3. 최종 목적지에 ICMP Echo Request(Type 8) 패킷이 도달하면 ICMP Echo Reply(Type 0) 패킷이 반환되며 최초 출발지 호스트는 이 정보를 이용하여 최종 목적지 호스트에 도달했음을 알 수 있게 된다.

### 4) 실습
1. 윈도우 tracert 테스트
   * 기본 옵션으로 실행 시 구간별로 3번의 ICMP 패킷을 전송하고 응답시간을 보여준다.
   * "*"는 지정한 시간 내에(default 4초) 응답이 없음을 의미한다.
  
### 5) 윈도우 리눅스 차이점
* 리눅스는 최종 목적지에 도달하여 33434/udp 포트가 닫혀 있으므로 ICMP Destination unreachable(Type 3) 이 반환되어 목적지에 도달한 것을 알 수 있고 윈도우는 최종 목적지에 도달하면 ICMP Echo Reply(Type 0) 응답이 와서 목적지에 도달한 것을 알 수 있다.

## (3) netstat 명령
### 1) 개요
1. 시스템의 네트워크 관련 다양한 상태정보를 관리할 수 있는 명령어
2. 주요 제공정보는 다음과 같다.
   * 옵션 없음 : 모든 연결된(ESTABLISHED) 소켓 상태정보
   * -a 옵션 : 모든 소켓 상태정보
   * -i 옵션 : 네트워크 인터페이스 정보
   * -r 옵션 : 시스템 라우팅 테이블 정보
   * -s 옵션 : 프로토콜별(TCP, UDP, ICMP, IP 등) 통계정보
  
### 2) 실습(Linux)
1. 소켓 상태정보 확인하기
   * netstat -t : "t" 옵션은 TCP 소켓을 출력하라는 옵션이다. 따라서 TCP 소켓 중 연결된(ESTABLISHED) 소켓만을 출력한다. ("u" 옵션은 UDP를 의미)
   * 각 필드의 의미를 살펴보면 다음과 같다.

|필드|설명|
|-|-|
|Proto|사용한 프로토콜의 종류|
|Recv-Q|원격 호스트로부터 수신 버퍼에 저장한 데이터의 크기|
|Send-Q|원격 호스트로 전송하기 위해 송신 버퍼에 저장한 데이터의 크기|
|Local Address|로컬 호스트의 소켓 주소(IP : 포트)|
|Foreign Address|원격 호스트의 소켓 주소(IP : 포트)|
|State|소켓 상태|

   * netstat -at : TCP 소켓을 모두 출력한다. 모두 출력한다는 것은 연결된 상태(ESTABLISHED)뿐만이 아니라 연결 대기(LISTEN), 연결설정 및 종료 중인 소켓도 모두 출력한다는 의미이다.
   * netstat -ant : "n" 옵션은 네트워크 주소를 숫자 형식으로 출력하는 옵션이다. 따라서 숫자 형식의 네트워크 주소로 연결된 소켓과 연결 요청 대기 중인 TCP 소켓을 모두 출력한다.
   * netstat -antp : "p" 옵션은 해당 소켓의 프로세스명/pid 정보를 출력하는 옵션이다. TCP 소켓을 열고 있는 프로세스를 확인하는 데 유용하게 사용한다.
2. 네트워크 인터페이스 정보 확인하기
   * ```netstat -i```
   * RX-OK/RX-ERR/RX-DRP/RX-OVR : RX는 수신한(Received) 패킷 수를 의미한다. OK는 오류 없이 수신한 패킷 수, ERR는 오류가 발생한 수신 패킷 수, DRP는 폐기(Drop)된 수신 패킷 수, OVR은 과도한 양의 수신 패킷에 의한 오버플로우 발생으로 폐기된 패킷 수를 의미한다.
   * TX-OK/TX-ERR/TX-DRP/TX-OVR : TX는 전송한(transmitted) 패킷 수를 의미한다. OK는 오류 없이 전송한 패킷 수, ERR는 오류가 발생한 전송 패킷 수, DRP는 폐기(DROP)된 전송 패킷 수, OVR은 과도한 양의 전송 패킷에 의한 오버플로우 발생으로 폐기 수를 의미한다.
3. 시스템 라우팅 테이블 정보 확인하기
   * ```netstat -rn```
4. 프로토콜별 통계정보
   * ```netstat -s```
   * 시스템이 부팅된 이후부터 현재까지 누적된 프로토콜 통계정보를 출력한다.

## (4) ifconfig 명령(리눅스/유닉스)
### 1) 개요
1. 유닉스/리눅스 시스템에서 네트워크 인터페이스 설정 정보를 조회하거나 IP 주소나 서브넷 마스크 등의 설정을 변경할 때 사용한다.

### 2) 실습 I (Linux)
1. eth1 Link encap:Ethernet HWaddr 00\:0C\:29\:0C\:A6\:C6
   * eth1 이더넷 인터페이스가 연결되어 있고 MAC 주소 정보(HWaddr)를 보여주고 있다.
2. inet addr:192.168.197.133 Bcast:192.168.197.255 Mask:255.255.255.0
   * IP 주소(inet addr), 브로드캐스트 주소(Bcast), 넷마스크(Mast) 값을 보여주고 있다.
3. UP BROADCAST RUNNING MULTICAST MTU:1500 Metric\:1
   * UP은 현재 인터페이스가 활성화 상태임을 의미하며, BROADCAST는 인터페이스가 브로드캐스트를 지원하고 있음을 의미한다.
   * RUNNING은 인터페이스가 실행 중임을 나타내고 MULTICAST는 멀티캐스트를 지원하고 있음을 나타낸다.
   * MTU는 1500 bytes(이더넷)이고 메트릭 값은 1이다. 메트릭은 라우팅 경로의 효율성(우선순위)을 나타내는 값으로 이 값이 클수록 비용이 크다.(우선순위가 낮아진다)
  
### 3) 실습 II (Linux)
1. 인터페이스(eth1)에 Promiscuous 모드 설정
   * ```ifconfg eth1 promisc```
   * 인터페이스가 promiscuous 모드로 동작하게 되면 "PROMISC"로 표시
   * /var/log/messages 로그 파일에 eth1 인터페이스가 promiscuous mode로 전환되었음을 보여주고 있다.
   * 외부 침입자에 의한 불법적인 스니핑 목적의 모드 전환이 발생할 수 있으므로 주의가 필요하다.
2. 인터페이스(eth1)에 promiscuous 모드 해제
   * ```ifconfig eth1 -promisc```
   * ifconfig "인터페이스 명" -promisc 명령을 통해 해당 인터페이스에 설정된 promiscuous mode 설정을 해제할 수 있다.
   * /var/log/messages 로그 파일에 eth1 인터페이스가 promiscuous mode에서 해제되었음을 보여주고 있다.

# 11. 포트스캐닝
## (1) 개요
1. 포트 스캐닝은 공격자가 침입 전 대상 호스트에 어떤 포트(서비스)가 활성화되어 있는지 확인하는 기법으로 침입 전 취약점을 분석하기 위한 사전 작업 중 하나이다.
2. 포트 스캐닝을 통해 대상 호스트의 동작 여부와 제공하는 서비스 등을 확인할 수 있다. 일반적으로 포트 스캐닝을 수행하기 위한 포트 스캐너로 nmap을 많이 사용한다.

## (2) nmap 포트 스캐너 사용법
|문법|nmap [scan type] [options] <target>
|:-:|:-|
|Scan Type|-sS TCP SYN(Half-Open) Scan : TCP 포트 오픈 여부를 확인하는 스캔 </br>-sT TCP Connect(Open) Scan : TCP 포트 오픈 여부를 확인하는 스캔 </br>-sU UDP Scan : UDP 포트 오픈 여부를 확인하는 스캔 </br>-sF TCP FIN Scan : TCP FIN 제어비트 패킷을 이용한 스캔 </br>-sX TCP Xmas Scan : TCP FIN, PSH, URG 제어비트를 조합한 패킷을 이용한 스캔 </br>-sN TCP NULL Scan : TCP 제어비트 설정이 없는 NULL 패킷을 이용한 스캔 </br>-sA TCP ACK Scan : 방화벽 룰셋(필터링 정책)을 확인하기 위한 스캔 </br>-sP Ping(icmp/icmp echo) Scan : Ping을 이용한 호스트 활성화 여부를 확인하는 스캔 </br>-D Decoy Scan : 실제 스캐너 주소 외에도 다양한 주소로 위조하여 스캔하는 방식 </br>-b TCP FTP Bounce Scan, -b \<FTP bounce Proxy\>|
|Port Options|-p 22 : 22번 포트 스캔 </br>-p <service> : 특정 서비스명(e.g. ssh)으로 포트 스캔 </br>-p 20,25,80 : 20,25,80 포트 스캔, 여러 포트 스캔 </br>-p 1-1023 : 1-1023번 포트 스캔, 일정 범위로 포트 스캔 </br>-pT:21,23,110,U:53 : TCP 21,23,110번 포트와 UDP 53번 포트를 분리하여 포트 스캔|
|Output Options|-v : 상세 내역 출력 </br>-d : Debugging </br>-oN <file> : 결과를 일반 파일 형식으로 출력 </br>-oX <file> : 결과를 XML 파일 형식으로 출력 </br>-oG <file> : 결과를 Grepable(grep, awk등으로 분석하기 편한) 파일 형식으로 출력 </br>-oA <Directory> : 일반(.nmap), XML(.xml), Grepable(.gnmap) 파일로 출력|
|기타 Options|-O : 영문 대문자 O, 대상 호스트의 운영체제 정보를 출력 </br>-F : 빠른 네트워크 스캐닝 </br>-T0 ~ T5 : T0 아주느리게 ~ T5 아주 빠르게|
|Target|-hostname 지정 * ex) www.algisa.com </br> IP address, Network 등 가능 </br> * ex) 192.168.159.151 : 특정 IP 지정 </br> * ex) 192.168.159.0/24 : 192.168.159 대역 지정 </br> * ex) 192.168.159.100-150 : 특정 범위(100-150) 지정|

## (3) TCP Connect(Open) 스캔
### 1) 개요
1. 일반 사용자 권한으로 TCP 포트 오픈 여부를 확인하기 위해 connect 시스템 호출(system call)을 이용하는 방식으로 스캔 대상 포트별로 정상적인 TCP 연결설정을 수행하여 스캔하는 방식이다.
2. TCP 등 프로토콜 패킷 자체(raw packet)를 사용자가 직접 조작하여 생성하기 위해서는 관리자 권한이 필요하다. TCP SYN 스캔 등 대부분의 스캔 방식들이 관리자 권한으로 패킷을 직접 조작해서 스캔하는 방식이며 이러한 관리자 권한이 없을 경우에는 일반 사용자 권한으로 사용할 수 있는 시스템 호출을 이용하는 TCP Connect 스캔을 이용한다.
3. 포트 스캔 과정에서 connect 시스템 호출을 통해 TCP 연결설정 과정을 완전하게 수행하여 Target 호스트의 포트에 직접 연결되기 때문에 Open 스캔이라고도 하며 시스템 로그에 스캔한 흔적이 남는 특성이 있다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 SYN 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **SYN+ACK 응답을 수신한 후 ACK 패킷을 전송하여 TCP 연결을 완료**한다.(connect 시스템 호출 동작 방식)
   * 포트가 닫힌 상태 : **RST+ACK 응답을 수신**한다.
2. 대상 포트가 열린 상태에서 연결설정이 완료되고(3-way handshaking 과정) 나면 **포트 오픈 여부를 확인했기 때문에 연결을 즉시 중단하기 위해 RST+ACK 패킷을 전송한다.
3. TCP 연결 설정이 이루어지기 떄문에(이를 TCP 세션이 성립된 상태라고도 표현함) 대상 호스트의 시스템 로그에 스캔을 시도한 IP 주소가 남는 특징이 있다.
4. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 Connect 스캔(-sT) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열려있고 http(80/tcp) 포트는 닫혀 있는 것을 확인할 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 SYN+ACK 응답이 왔으며 ACK 전달 후(연결 설정 완료) RST+ACK로 연결을 즉시 중단하고 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.
  
#### (나) Filtered 상태
1. Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable)응답을 받을 수 있다. 방화벽 필터링(차단) 정책은 보안상의 이유로 응답을 하지 않도록 설정하는 것이 일반적이다.
   * iptables 방화벽의 경우 DROP 차단 정책을 사용하면 해당 패킷을 폐기한 후 아무런 응답을 하지 않고 REJECT 차단 정책을 사용하면 해당 패킷을 폐기한 후 설정된 ICMP 에러 메시지(Destination Unreachable)를 응답한다.
2. 실습
   * 스캔 결과를 살펴보면 Target 호스트의 ftp(21/tcp) 포트가 방화벽에 의해 차단(filtered)된 것을 알 수 있다.
   * (wireshark) 21/tcp 스캔 시 방화벽 룰세(필터링 정책)에 의해 차단되어 방화벽 차단 정책(REJECT(icmp-host-prohibited))에 설정된 ICMP 에러 메시지(Type: Destination Unreachable, Code:Host administratively prohibited) 응답이 온 것을 볼 수 있다.
  
## (4) TCP SYN(Half-Open) 스캔
### 1) 개요
1. 관리자 권한으로 TCP 패킷 자체(raw packet)를 직접 조작하여 TCP 포트 오픈 여부를 판단하는 스캔방식이다.
2. 포트 스캔 과정에서 TCP 패킷 헤더의 제어비트(control bit)를 조작, TCP 연결 설정 과정(3-Way handshaking)을 완전하게 수행하지 않기 때문에 Half-Open 스캔(반만 오픈하는 스캔) 이라고도 한다.
3. **스텔스 스캔(Stealth Scan)** 방식 : TCP 세션이 완전히 성립되지 않은 상태에서 (TCP 연결 설정 미완료 상태) 대상 시스템의 포트 활성화(오픈) 여부를 알아내는 스캔방식으로 TCP 연결설정이 완전히 이루어지지 않기 때문에 스캔 대상 시스템에 로그가 남지 않아 공격자는 자신의 IP를 노출시키지 않으면서 스캔할 수 있는데 이렇게 흔적을 남기지 않는다는 의미에서 스텔스 스캔이라 한다.
   * 대표적인 스텔스 스캔방식으로 TCP SYN Scan, TCP FIN Scan, TCP NULL Scan, TCP Xmas Scan 등이 있다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 SYN 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **SYN+ACK 응답을 수신**한다.
   * 포트가 닫힌 상태 : **RST+ACK 응답을 수신**한다.
2. 대상 포트가 열린 상태이면 Target 호스트로부터 SYN+ACK 응답이 오고 **해당 응답만으로도 포트가 열린 상태임을 알 수 있기 때문에 연결을 완료하지 않고 패킷 조작을 통해 즉시 중단하기 위한 RST 패킷을 전송**한다.
3. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 SYN 스캔(-sS) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열려 있고 http(80/tcp) 포트는 닫혀있는 것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 SYN+ACK 응답이 왔으며 연결 미완료 상태에서 RST로 즉시 연결을 중단하고 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (나) FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (5) TCP FIN/NULL/Xmas 스캔
### 1) 개요
1. 관리자 권한으로 TCP 패킷 자체(raw packet)를 직접 조작하여 TCP 포트 오픈 여부를 판단하는 스캔방식이다.
2. TCP 세션(연결)을 생성하지 않고 스캔하는 **스텔스 스캔**방식으로 TCP 패킷 헤더의 제어비트(control bit)를 비정상적으로 설정해서 스캔한다. 스캔방식에 따른 제어비트 설정 방식은 다음과 같다.
   * TCP FIN 스캔 : **FIN 제어비트만 설정**하여 스캔하는 방식으로 TCP 표준에서 연결 종료 패킷은 FIN+ACK 제어비트를 사용한다.
   * TCP NULL 스캔 : **제어비트 설정하지 않고 스캔**하는 방식으로 TCP 표준에서 사용하지 않는 설정이다.
   * TCP Xmas 스캔 : **URG, PSH, FIN 제어비트를 설정**하여 스캔하는 방식으로 TCP 표준에서 사용하지 않는 설정이다.
3. TCP 표준(RFC 793)의 다음 특성을 이용하여 포트 오픈 여부를 확인한다.
   * 닫힌(CLOSED) 포트로 RST 이외의 패킷을 수신한 경우 RST 패킷으로 응답한다.
   * 열린(OPEN) 포트로 SYN, ACK 또는 RST 이외의 패킷을 수신한 경우 이를 폐기하고 응답하지 않는다.
   * 따라서 위와 같은 TCP 표준 동작방식을 준수하는 시스템이라면 **SYN, ACK 또는 RST 이외의 패킷을 수신한 경우 닫힌 포트에서는 RST 패킷으로 응답하고 열린 포트에서는 응답하지 않는다.**

### 2) 동작방식
#### (가) TCP FIN 스캔 : OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 FIN 제어비트만 설정한 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 FIN 스캔(-sF) 수행
   * 스캔 결과를 살펴보면 Target 호스트이 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 http(80/tcp) 포트는 닫혀 있는(closed) 것을 알 수 있다.
   * 23/tcp 포트가 open|filtered 상태로 보이는 것은 응답이 없는 경우가 해당 포트가 열린 상태(open)뿐만이 아니라 방화벽에 의해 차단되는(filtered) 경우에도 응답이 없을 수 있기 때문이다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (나) TCP NULL 스캔 : OPEN/CLOSE 상태
1. 먼저 Target 호스트의 대상 포트로 제어비트를 아무것도 설정하지 않은 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 NULL 스캔(-sN) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 httpd(80/tcp) 포트는 닫혀 있는(closed)것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.
  
#### (다) TCP X-mas 스캔 : OPEN/CLOSE 상태
1. 먼저 Target 호스트의 대상 포트로 URG, PSH, FIN 제어비트를 설정한 패킷을 전송한다. Xmas라고 이름을 붙인 이유는 크리스마스트리처럼 제어비트를 반짝거리게 설정했다는 의미이다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 Xmas 스캔(-sX) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 http(80/tcp) 포트는 닫혀 있는(closed)것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (라) TCP FIN/NULL/Xmas 스캔 : FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (6) TCP ACK 스캔
### 1) 개요
1. Target 호스트의 포트 오픈 여부를 판단하는 것이 아니라 방화벽 룰셋(필터링 정책)을 알아내기 위한 스캔방식이다.
2. Target 호스트의 대상 포트로 **ACK 제어비트만 설정한 패킷**을 전송하면 방화벽 룰셋(필터링 정책)에 따라 다음과 같은 응답을 확인할 수 있다.
   * 방화벽에 의해 차단(filtered)된 상태 : **방화벽으로부터 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 수신**한다.
   * 방화벽에 의해 허용(unfiltered)된 상태 : **Target 호스트로부터 포트 오픈 여부와는 무관하게 RST 응답을 수**신한다. TCP 표준에 따르면 열린 포트에 ACK를 수신한 경우 RST로 응답하고 닫힌 포트에 ACK를 수신한 경우(RST 이외의 패킷)에도 RST로 응답한다.
3. 방화벽에서 허용된 경우, Target 호스트의 포트 오픈 여부에 상관없이 RST 응답을 수신하기 때문에 TCP ACK 스캔은 포트 오픈 여부를 판단할 수 없다.

### 2) 동작방식
1. 먼저 Target 호스트의 대상 포트로 ACK 제어비트만 설정한 패킷을 전송한다. 전송 후 방화벽 룰셋(필터링 정책)의 차단/허용 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 차단(filtered) 상태 : 방화벽으로부터 **응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 수신**
   * 허용(unfiltered) 상태 : Target 호스트로부터 **RST 응답 수신**
2. 실습 환경
   * Target 호스트의 방화벽 설정을 살펴보면 telnet(23/tcp), http(80/tcp) 포트를 허용하고 그 이외의 접근에 대해서는 차단(REJECT)하고 있다.
   * Target 호스트의 포트 오픈 여부를 살펴보면 telnet(23/tcp) 포트만 열려있고 나머지 포트(21/tcp, 22/tcp, 80/tcp)는 닫혀있다.
3. 실습 결과
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 21, 22, 23, 80 TCP 포트(-p)에 대한 ACK 스캔(-sA) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 ftp(21/tcp), ssh(22/tcp) 포트는 방화벽에 의해 차단(filtered)되고 있고 telnet(23/tcp), http(80/tcp) 포트는 방화벽에 의해 허용(unfiltered)되고 있는 것을 알 수 있다.
   * (wireshark) 21/tcp, 22/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 차단되어 ICMP 에러 메시지(Destination Unreachable) 응답이 온 것을 볼 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 허용되어 Target 호스트로 탐지 패킷이 전달되고 23/tcp 포트는 열려있지만, 정상적인 연결 요청을 위한 SYN 패킷이 아닌 ACK 패킷이기 때문에 RST 응답하는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 허용되어 Target 호스트로 탐지 패킷이 전달되고 80/tcp 포트는 닫혀있기 때문에 RST로 응답하는 것을 볼 수 있다.

## (7) UDP 스캔
### 1) 개요
1. Target 호스트의 UDP 포트 오픈 여부를 판단하는 스캔방식으로 닫힌 UDP 포트로 패킷 수신 시 **ICMP 에러 메시지(Type3: Destination Unreachable, Code3:Port Unreachable)로 응답**하는 특성을 이용한다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 UDP 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 확인할 수 있다.
   * 포트가 열린 상태 : **UDP 응답을 수신하거나 응답 없음**
   * 포트가 닫힌 상태 : **ICMP 에러 메시지(Type3: Destination Unreachable, Code3: Port Unreachable) 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.100 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 53, 123 UDP 포트(-p)에 대한 UDP 스캔(-sU) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 dns(53/udp) 포트는 열려(open)있고 ntp(123/udp) 포트는 닫혀(closed)있는 것을 알 수 있다.
   * (wireshark) DNS(53/udp) 포트 스캔 시 Target 호스트로부터 DNS 응답이 온 것을 볼 수 있다. 만약 포트 스캔 시 UDP 요청 패킷이 해당 서비스에 적절한 요청이 아닐 경우 응답 없음이 발생할 수 있다.
   * (wireshark) NTP(123/udp) 포트 스캔 시 Target 호스트로부터 ICMP 에러 메시지(Type3: Destination Unreachable, Code 3: Port Unreachable) 응답이 온 것을 볼 수 있다.

#### (나) FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (8) Decoy 스캔
### 1) 개요
1. Decoy 스캔은 다양한 포트 스캔을 수행할 때 스캔을 당하는 Target 호스트에서 스캐너 주소를 식별하기 어렵도록 실제 스캐너 주소 외에 다양한 위조된 주소로 스캔하는 방식을 말한다.
2. 다양한 IP로 스캐너 주소를 위조하여 Target 호스트의 관리자가 스캔을 누가 하는지 알아채기 어렵도록 한다.

### 2) 동작방식
1. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * ```nmap -T4 -sF -p 23,80 192.168.56.100 -D RND```
   * Decoy(-D) 옵션을 통해서 공격자 IP(192.168.57.80) 외에 임의로 부여한(RND) 위조된 IP로 TCP FIN 스캔(-sF)을 수행
   * (wireshark) Source IP가 Scanner 호스트 IP(192.168.57.80)외에도 위조된 IP(26.7.176.84)로 스캔하는 것을 볼 수 있다.

## (9) 기타 옵션
### 1) 출력(Output) 옵션
1. -oN : 스캔 결과 일반 파일 형식으로 출력
2. -oX : 스캔 결과 XML 파일 형식으로 출력
3. -oG : 스캔 결과 Grepable(grep, awk 등으로 분석하기 편한) 파일 형식으로 출력

### 2) 기타 옵션
1. -O : 영 대문자 O, 대상 호트의 운영체제 정보를 출력

# 12.서비스 거부(DoS:Denial Of Service) 공격
## (1) 개요
1. 서비스 거부 공격은 공격 대상 시스템(Target)이 정상적인 서비스를 할 수 없도록 서비스를 마비시키는 형태의 공격을 말한다. 따라서 **서비스 거부 공격은 공격 대상 시스템의 서비스 가용성(Availability)을 떨어트리는 것이 공격의 목적**이다.
2. 서비스 거부 공격은 크게 다음 세 가지 유형으로 구분할 수 있다.
   * 파괴 공격 : 디스크, 데이터, 시스템 파괴
   * 시스템 자원 소진 공격 : CPU, 메모리, 디스크 등의 자원에 과도한 부하를 발생시키는 유형
   * 네트워크 자원 소진 공격 : 과도한 트래픽으로 네트워크 대역폭을 소진시키는 유형
3. 서비스 거부 공격(DoS: Denial Of Service) Vs 분산 서비스 거부(DDos:Distributed Denial Of Service) 공격의 차이점
   * 서비스 거부(DoS) 공격 : 공격자가 **단일 컴퓨터를 이용하여 공격**하는 형태
   * 분산 서비스 거부(DDoS) 공격 : 공격자가 **분산된 다수의 컴퓨터(좀비 PC) 또는 장치(좀비 Device)들을 이용하여 공격**하는 형태
  
## (2) Ping Of Death Attack
### 1) 개요
1. **ping 명령을 통해 ICMP(또는 ICMP Echo Request) 패킷(메시지)을 정상적인 크기보다 아주 크게 만들어 전송하면 MTU(Maximum Transmission Unit)에 의해 다수의 IP 단편화(fragment)가 발생**하게 한다.
   * MTU는 물리적인 네트워크 프로토콜 프레임의 데이터부(Payload)의 최대 크기를 의미한다.
   * 이더넷의 경우 1,500byte, 즉 IP 패킷의 최대 크기가 1,500byte이기 때문에 IP 헤더부(기본 20byte)를 제외하면 ICMP 패킷은 최대 1,480byte의 크기로 생성된다.
2. 수신 측에서는 단편화된 패킷을 재조합하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 한다.

### 2) 대응책
1. Ping of Death 공격의 핵심은 Ping 패킷의 데이터 크기를 매우 크게 하여 패킷을 몇 개만 보내도 수십 개로 분할하여 목적지로 송신되는 것이다. 보통의 ICMP 패킷은 분할하지 않으므로 패킷 중 분할이 일어난 패킷을 공격으로 의심하여 탐지하는 방식을 사용한다.
2. 현재 대부분 시스템은 Ping of Death 공격을 받을 때 반복적으로 들어오는 일정 수 이상의 ICMP 패킷을 무시하게 설정되어 있다. 만약 여전히 취약점을 가지고 있다면 패치가 필요하다

### 3) 실습자료
1. 실습환경
   * Attacker : 161.X.X.210 , Target : 192.X.X.131
   * 최대 크기 65,535byte의 ICMP 패킷을 대량으로 희생자에게 전송
2. 패킷 캡처(Wireshark)
   * 다량의 단편화된 IP 패킷이 희생자 측에 발생하고 있음을 확인할 수 있다.

## (3) Land Attack
### 1) 개요
1. land는 착륙하다. 나쁜 상태에 빠지게 한다는 의미가 있다. 따라서 해당 시스템을 나쁜 상태에 빠지게 하는 도스 공격 기법이라 할 수 있다.
2. 공격자가 **출발지와 목적지 IP가 같은 패킷**을 만들어 공격 대상 시스템에 보냄으로써 수신자가 자기 자신에게 응답을 보내 무한 루프 상태에 빠지도록 하여 시스템 자원을 소모시키는 형태의 도스 공격을 말한다.

### 2) 대응책
1. 현재 대부분 운영체제는 Land Attack에 대한 보안패치가 적용되어 있다. 미적용 운영체제라면 **보안패치를 적용**한다.
   * 패치 적용 시 출발지와 목적지 IP 주소가 동일한 패킷의 경우 모두 폐기(Drop) 처리한다.
2. **침입차단시스템(방화벽), 라우터 등 패킷 필터링 장비를 통해 출발지 IP와 목적지 IP가 같으면 차단하도록(필터링하도록) 설정**한다.

### 3) 실습자료
1. 실습환경
   * Target IP(192.168.197.133)로 출발지 IP를 스푸핑한 ICMP 메시지 전송
2. 패킷 캡처(tcpdump)
   * Target IP와 동일한 출발지 IP의 패킷이 Target 측에 발생하고 있음을 확인할 수 있다.
  
## (4) Smurf Attack
### 1) 개요
1. 스머프 공격은 출발지 IP를 희생자 IP로 위조한 후 증폭 네트워크로 ICMP Echo Request를 브로드캐스트 함으로써, 다수의 ICMP Echo Reply가 희생자에게 전달되어 서비스 거부를 유발시키는 공격 기법이다.
2. Directed Broadcast
   * IP 주소의 호스트 ID 비트를 모두 1로 설정하여 브로드캐스트하는 방식을 Directed Broadcast라고 한다.
   * 원격지 네트워크에 broadcast를 해야 할 경우에 원격지 주소의 호스트 ID 비트를 모두 1로 설정하여 전송하게 된다. 이때 원격지 라우터의 Directed Broadcast가 활성화되어야 가능한데 일반적으로 보안상의 문제로 허용하지 않는다.
3. Amplifier(Bounce) Network(증폭 네트워크)
   * ICMP Echo Request 브로드캐스트 메시지를 받아서 희생자에게 다수의/증폭된 ICMP Echo Reply를 전송하는 네트워크를 말한다.

### 2) 대응책
1. 스머프 공격의 특성상 공격이 시작되면 단시간에 다수의 ICMP Echo Reply 패킷을 희생자에게 전송한다. 따라서 동일한 ICMP Echo Reply 패킷이 다량으로 발생한다면 해당 패킷들을 침입차단시스템으로 모두 차단(Drop)시킨다.
2. **증폭 네트워크로 사용되는 것을 막기 위해 다른 네트워크로부터(외부로부터) 자신의 네트워크로 들어오는 Directed Broadcast 패킷을 허용하지 않도록 라우터 설정**을 한다.
   * 라우터 명령어 : (config-if)# **no ip directed-broadcast**
3. 브로드캐스트 주소로 전송된 ICMP Echo Request 메시지에 대해 응답하지 않도록 시스템 설정을 한다.

### 3) 실습자료
1. 실습환경
   * 희생자 IP로 출발지 주소를 위조한 대량의 ICMP Echo Request 메시지를 브로드캐스트
2. 패킷 캡처(Wireshark) : 공격자 호스트 관점
   * 브로드캐스트 주소(192.168.56.255)로 희생자 주소(10.10.10.20)로 위조한 대량의 ICMP Echo Request 메시지가 전송되고 있음을 확인할 수 있다.
3. 패킷 캡처(Wireshark) : 희생자 호스트 관점
   * 브로드캐스트 주소(192.168.56.255)의 다양한 호스트로부터 희생자 주소(192.168.57.20)로 ICMP Echo Reply 메시지가 수신되고 있음을 확인할 수 있다.

## (5) Teardrop Attack
### 1) 개요
1. IP 패킷의 재조합 과정에서 **조작된 단편의 오프셋 정보로 인해 수신시스템에 오류나 부하가 발생**하도록 만드는 도스 공격을 말한다.
2. 공격자는 IP fragment offset값을 **서로 중첩되도록 조작하여 전송하고 이를 수신한 시스템이 재조합하는 과정에서 오류나 부하가 발생**, 시스템의 기능을 마비시키는 공격 방식이다.
3. 패킷의 fragment 관련 헤더 값을 조작하는 유사한 공격으로 Bonk, Boink가 있다.

### 2) 대응책
1. 운영체제의 보안패치를 모두 적용하여 OS의 취약점을 해소한다.

## (6) IP 단편화의 취약점을 이용한 우회 공격
### 1) 개요
1. IP 단편화의 취약점을 이용하여 **패킷 필터링 장비(방화벽, 침입탐지시스템 등)를 우회하기 위한 대표적인 공격 기법에는 "Tiny Fragment(작은 단편) 공격"과 "Fragment Overlap(단편 중첩) 공격"** 이 있다.
2. Teardrop 공격처럼 IP 단편의 오프셋을 조작하는 공격이지만 **도스 공격이 아닌 침입차단시스템 등을 우회하여 허용하지 않는 공격 대상 시스템의 서비스에 접근하기 위한 공격**이다.

### 2) Tiny Fragment (작은 단편) 공격
1. TCP/UDP 헤더가 2개의 IP 단편에 나누어질 정도로 최초의 단편을 아주 작게 만들어서 패킷 필터링 장비를 우회하는 공격 기법을 말한다.
2. 공격 원리
   * 공격자는 TCP/UDP 헤더가 2개의 IP 단편에 나누어질 정도로 작게 쪼개서 첫 번째 단편에는 목적지 포트가 포함되지 않고 두 번째 단편에 포함되도록 한다.
   * 패킷 필터링 장비는 첫 번째 IP 단편에 필터링할 정보가 없어 통과시키고 이후 두 번째 단편은 첫 번째 단편이 허용되었으므로 통과시킨다.
   * 목적지 서버에서 단편들이 재조합되어 공격자가 원하는 목적지 포트로 연결된다.
3. 정리하면 첫 번째 단편화에는 목적지 포트 정보가 없고 두 번째 단편화에는 목적지 포트 정보가 있다. 첫 번째 단편이 허용되었으므로 두 번째 단편도 통과

### 3) Fragment Overlap (단편 중첩) 공격
1. IP 단편의 오프셋을 조작하여 첫 번째 단편의 일부분을 두 번째 단편이 덮어쓰도록 함으로써 패킷 필터링 장비를 우회하는 공격 기법을 말한다.
2. 공격 원리
   * 공격자는 두 개의 IP 단편을 생성한 후 첫 번째 단편에는 패킷 필터링 장비에서 허용하는 목적지 포트(e.g. HTTP 80번포트)가 포함되도록 하고 두 번째 단편에는 공격자가 연결하기를 원하는 목적지 포트(e.g. Telnet 23번포트)가 포함되도록 한다.
   * 두 번째 단편의 목적지 포트가 첫 번째 단편의 목적지 포트를 덮어쓸 수 있도록 두 번째 단편의 오프셋을 조작한다.
   * 패킷 필터링 장비는 첫 번째 IP 단편에 있는 허용하는 목적지 포트 정보를 확인한 후 통과시키고 이후 두 번째 단편은 첫 번째 단편이 허용되었으므로 통과시킨다.
   * 목적지 서버에서 단편들이 재조합되어 공격자가 원하는 목적지 포트로 연결된다.
3. 정리하면 첫 번째 단편화에는 허용 가능한 목적지 포트 정보가 있고 두 번째 단편화에는 첫 번째 단편화의 목적지 포트 정보를 덮어쓸 원하는 목적지 포트 정보가 있다. 첫 번째 단편이 허용되었으므로 두 번째 단편도 통과되고 재조합 되는 과정에서 원하는 목적지 포트로 연결된다.

### 4) 대응책
1. **단편화된 패킷들을 재조합하여 IP 단편화를 이용한 우회 공격의 탐지가 가능한** 패킷 필터링 장비를 적용한다.

# 13. 분산 서비스 거부(DDoS:Distributed Denial of Service) 공격
### 1) 개요
1. 분산 서비스 거부 공격은 분산된 다수의 좀비 PC/디바이스에 의해 공격대상 시스템의 서비스를 마비시키는 공격 형태를 의미한다.
2. 일반적인 공격 구조를 살펴보면 다음과 같이 크게 4가지 구성 요소로 이루어져 있다.
   * **공격자(Attacker)** : C&C 서버에 공격 명령을 전달하는 해커의 컴퓨터를 말한다. 봇 마스터(Bot Master)라고도 한다.
   * **명령제어(C&C:Command & Control) 서버** : 공격자로부터 직접 공격 명령을 전달받는 시스템을 말하며 전달받은 명령은 관리하는 다수의 좀비 PC/디바이스에 전달한다. 마스터 또는 C2 서버라고도 한다.
   * **좀비(Zombie) PC/디바이스** : C&C 서버로부터 전달받은 명령을 실행하여 공격대상에 실제 공격을 수행하는 PC/디바이스를 말한다. 봇, 슬레이브, 에이전트라고도 한다.
   * **공격대상(Target)** : 공격의 대상이 되는 시스템을 말한다.
3. 일반적인 공격 절차는 다음과 같다.
   * 공격자는 각 봇을 관리하고 명령을 내리는 C&C 서버를 구축한다.
   * 스팸 메일이나 악의적인 웹사이트 등을 통해 불특정 다수의 PC에 봇을 배포해 감염을 시도한다.
   * 사용자가 봇 프로그램을 다운로드해 실행하면 봇에 감염된다.
   * 봇이 C&C 서버에 접속함으로써 감염 PC는 봇넷의 일원으로 추가된다.
   * 공격자가 C&C 서버에 명령을 내리면 C&C 서버는 봇에 명령을 전달한다.
   * 봇은 명령에 따라 다양한 공격을 수행하며 스스로 다른 PC로 봇의 전파를 시도한다.
  
### 2) 봇(Bot)/봇넷(Botnet) 살펴보기
#### (가) 개요
1. 봇은 소프트웨어적 로봇을 줄임말로 보안상 결합을 이용해 원격에서 해당 시스템을 제어할 수 있는 프로그램을 말한다. 이러한 악성 봇에 감염된 PC/디바이스를 "좀비 PC/디바이스"라고 한다.
   * 일반적으로 봇은 웜/바이러스, 백도어, 스파이웨어, 루트킷 등 다양한 악성코드들의 특성을 복합적으로 가지고 있다.
   * 봇은 공격자의 명령에 따라 활동하며 공격자가 감염된 PC/디바이스를 제어하여 정보 유출, 스팸 메일 발송, 디도스 공격, 트래픽 스니핑, 키 로깅 등 다양한 형태의 공격을 수행한다.
2. 봇넷이란 악성코드 스파이웨어인 봇에 감염된 다수의 좀비 PC/디바이스로 구성된 네트워크를 말한다. 좀비들은 C&C 서버와 직접 통신하거나 좀비들 간에 서로 통신을 수행하면서 공격자의 명령을 수행한다.
   * 합법적인 분산 네트워크로 봇넷 기술을 활용할 수 있지만 일반적으로 봇넷이라 하면 악의적인 의도를 가진 불법 네트워크를 의미한다.
3. 봇넷은 명령/제어를 위해 사용하는 프로토콜에 따라 IRC 봇넷, HTTP 봇넷, P2P 봇넷으로 분류할 수 있으며 네트워크 구성에 따라 중앙 집중형 방식(IRC 봇넷, HTTP 봇넷)과 분산형 방식(P2P 봇넷)으로 분류할 수 있다.

#### (나) 봇넷 명령 제어 방식
1. **중앙 집중형 명령/제어**(Command/Control) 방식
   * 초기에는 구조가 유연하고 널리 사용되는 IRC의 특성을 이용한 IRC 봇넷이 주를 이루었으나 탐지 및 대응을 보다 어렵게 하기 위해 인터넷상에서 많이 사용되는 웹 프로토콜인 HTTP를 기반으로 진화하였다.
   * 다수의 도메인을 확보하여 중앙 집중형 명령/제어를 하기 위한 C&C 서버로 등록하고 다수의 좀비가 C&C 서버와 연결되어 명령을 수행하는 구조이다.
   * 명령/제어 구조가 비교적 간단하지만, C&C 서버가 탐지 및 차단되면 전체 봇넷이 중단될 가능성이 있다.
   * 대표적인 봇넷 유형에는 IRC 봇넷(Rbot 등), HTTP 봇넷(Robax 등)이 있다.
2. **분산형 명령/제어** 방식
   * 참여 멤버(좀비/봇)들이 모두 C&C 역할을 하여 그룹에 명령을 전파하는 분산 제어 방식으로 중앙 관리를 위한 별도의 도메인 및 C&C 서버가 불필요하다.
   * 주로 봇넷을 보호하고 네트워크가 끊어지는 것을 방지하기 위한 방식으로 참여 멤버 모두 C&C 역할을 하므로 탐지 및 차단이 어렵다.
   * 대표적인 봇넷 유형에는 P2P 봇넷(Storm, Peacomm 등)이 있다.

#### (다) DNS 싱크홀 서비스
* 악성 봇에 감염된 PC가 해커의 명령을 받기 위해 C&C 서버로 연결을 시도할 때 C&C 서버 대신 싱크홀 서버로 우회시켜 더 이상 해커로부터 조종 명령을 받지 않도록 해주는 시스템/서비스를 말한다.
* 싱크홀의 사전적 의미는 땅이 가라앉아 생긴 구덩이를 의미한다. 악성 봇을 미리 파놓은 구덩이(싱크홀 서버)로 유도하는 방식으로 이해할 수 있다.
* 한국인터넷진흥원에서 국내 주요 ISP 업체 및 가입기관과의 협력을 통해 DNS 싱크홀을 운영하고 있다.
* DNS 싱크홀 동작 과정은 다음과 같다.
   1. 사전 단계로 KISA에서 배포한 알려진 C&C 서버 목록을 ISP 등 DNS 싱크홀 적용기관의 DNS 서버에 주기적으로 업데이트한다.
   2. 악성봇에 감염된 PC가 싱크홀이 적용된 DNS에 C&C 서버에 대한 질의를 요청한다.
   3. DNS는 악성 봇 PC에 싱크홀 서버 IP 주소를 반환한다.
   4. 이를 통해 악성 봇 PC는 C&C 서버가 아닌 싱크홀 서버로 접속하여 공격자의 명령으로부터의 피해를 방지할 수 있다.
 
### 3) 봇넷의 보안장비 우회 기법
#### (가) 개요
1. 일반적으로 봇넷을 구성하는 좀비 PC나 랜섬웨어 등의 악성코드는 C&C 서버에 접속하는 과정에서 C&C 서버 도메인에 대한 질의를 수행한다.
   * 보안장비 관점에서는 C&C 서버 도메인이나 IP 주소 등이 알려지면 이를 블랙리스트로 등록하여 탐지 및 차단 수행
   * 공격자 관점에서는 확보한 봇넷 멤버들의 지속적 유지를 위해 보안장비를 통해 탐지되지 않도록 하는 것이 중요
2. 따라서 공격자들은 봇넷 참여 멤버들의 **C&C 서버 접속 과정에서 보안장비에 의해 탐지되지 않도록 하기 위한 다양한 보안장비 우회 기법**들을 적용하고 있다. 대표적인 기법은 다음과 같다.
   * **Fast Flux 기법**
   * **DGA 기법**
   * **Domain Shadowing(도멩니 쉐도잉) 기법**

#### (나) Fast Flux 기법
1. 하나의 C&C 서버 도메인에 다수의 IP 주소를 할당하여 DNS 질의 시마다 지속적으로 IP 주소가 변경되도록 하는 기법을 말한다.
   * Flux의 사전적 의미는 지속적인 변화이다. 즉, 도메인 질의 시마다 C&C 서버 IP 응답을 빠르게 지속적으로 변화시킨다는 의미이다.
   * 미리 확보해 둔 다수의 C&C 서버 IP 주소들을 DNS 레코드(A 레코드)에 추가하고 TTL 값을 매우 작게 주어 빠르게 라운드 로빈 방식으로 응답이 되도록 한다.
2. 만약 보안장비에 의해 Fast Flux IP 중에 어느 하나가 차단된다고 해도 다른 IP를 통해 지속적으로 C&C 서버에 접속할 수 있다.
   * DNS 질의 자체를 탐지할 수 있는 7계층 보안장비가 없는 상황이라면 Fast Flux IP 일부만 차단해서는 C&C 서버로의 접속을 완전히 차단할 수 없다.
3. 정리하면 미리 확보해 둔 다수의 C&C 서버 IP 주소들을 A 레코드를 통해 DNS 레코드에 추가하고 TTL 값을 매우 작게 주어 빠르게 라운드 로빈 방식 응답. 도메인 질의 시마다 C&C 서버 IP 응답을 빠르게 변화

#### (다) DGA(Domain Generation Algorithm) 기법
1. 약속된 규칙에 따라 C&C 서버 도메인을 지속적으로 동적 생성하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다.
   * 다수의 임시 C&C 서버 도메인이 동적으로 생성되기 때문에 보안장비 입장에서는 이를 모두 탐지하고 차단하기가 매우 어렵다.
   * 컨피커 웜에 의해 DGA 기법이 처음 알려졌으며 Locky(시스템 날짜 기반으로 도메인명 생성), WannyCry 랜섬웨어 등에서 사용됨
2. 알고리즘에 따라 도메인을 다수 생성하기 때문에 공격자는 해당 알고리즘에 따라 생성될 수 있는 도메인 중 하나를 DNS 서버에 새롭게 등록하는 방식을 사용한다. 만약 등록한 도메인이 블랙리스트로 차단된다면 다른 도메인명을 재등록한다.
3. 정리하면 알고리즘에 따라 다수의 도메인을 동적 생성하여 DNS 서버에 등록하여 사용하고 차단되면 새로운 도메인을 등록하여 사용한다.

#### (라) Domain Shadowing 기법
1. 알려진 합법적인 도메인의 서브 도메인을 C&C 서버 도메인으로 사용하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다.
   * 적법한 절차로 도메인을 소유하고 있는 도메인 관리자의 개인정보 등을 탈취하여 도메인 소유자 몰래 많은 서브 도메인을 등록시켜놓고 사용하는 기법
   * 드라이브 바이 다운로드(DBD:Drive By Download) 공격 도구인 앵글러 익스플로잇 도구에서 탐지 회피를 위한 기술로 사용되어 알려짐
2. 주로 드라이브 바이 다운로드 공격에서 악성코드 유포지로 흘러가는 길목에 사용되는 경유지 도메인을 서브 도메인으로 사용한다.
3. 정리하면 합법적인 도메인 관리자의 개인정보 등을 탈취하여 많은 서브 도메인을 등록시켜 사용하는 기법

### 4) DDoS 공격 유형
|문자값|대역폭 소진공격|서비스(어플리케이션) 마비공격|
|:-:|:-|:-|
|대표 공격 유형|UDP/ICMP Flooding, SYN Flooding|HTTP GET Flooding|
|공격 형태|1. UDP/ICMP Traffic Flooding </br>* UDP/ICMP Flooding, DNS Query Flooding 등 </br>2. TCP Traffic Flooding </br>* SYN Flooding, SYN+ACK Flooding </br>3. IP Flooding </br>* Land Attack, Tear Drop, HTTP Continuation 등|1. HTTP Traffic Flooding </br>* GET Flooding, CC Attack 등 </br>2. HTTP Header/Option Spoofing </br>* Slowloris, Pyloris 등 </br>3. TCP Traffic Flooding </br>* TCP Session, SYN Flooding, TCP Slow Read 등 </br>4. Other L7 Service Flooding </br>* Hash Dos, Hulk DoS, FTP/SMTP Attack 등|
|프로토콜|3~4계층 (Network, Transport 계층) : IP, ICMP, IGMP, UDP, TCP 등|7계층 </br>(Application 계층) : HTTP, DNS, FTP, SMTP 등|
|증상|* 회선대연폭고갈 </br>* 동일 네트워크를 사용하는 모든 서비스에 대한 접속장애 발생|* HTTP 서버 과다 접속(또는 서비스 부하)으로 인한 장애발생 </br>* 공격대상 시스템만 피해|
|공격대상|네트워크 인프라|웹서버, 정보보호 장비 등|

1. UDP/ICMP Flooding : 공격자는 다량의 UDP/ICMP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 가득 채워 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격
2. DNS Query Flooding : 공격자는 UDP 프로토콜 기반의 서비스를 제공하는 DNS에 대해 DNS 쿼리 데이터를 다량으로 서버에 전송하여 DNS의 정상적인 서비스를 방해하는 공격
3. TCP SYN Flooding : 공격자는 다량의 SYN 패킷을 서버로 전달하여 서버의 대기큐를 가득 채워 새로운 클라이언트의 연결 요청을 무시하도록 하여 장애를 유발시키는 공격
4. TCP Flag Flooding : TCP의 Flag값(Control Bit)을 임의로 조작하면 SYN, ACK, FIN, RST와 같이 여러 형태의 패킷을 생성할 수 있으며, 서버는 이러한 패킷을 수신하는 경우 해당 패킷을 검증하기 때문에 서버 자원을 소모시키는 공격이다.
5. TCP Session Flooding : TCP 3-Way Handshake 과정을 과도하게 유발함으로써 서비스의 과부하를 유발하는 공격
6. HTTP Continuation : 서버로 전달되는 패킷에 HTTP 헤더 없이 Data만 채워 웹서버가 지속적으로 데이터 수신을 위해 TCP 자원을 사용하도록 하는 공격
7. HTTP GET Flooding : 공격자는 동일한 URL을 반복 요청하여 웹서버가 URL에 해당하는 데이터를 클라이언트에게 회신하기 위해 서버 자원을 사용하도록 하는 공격
8. HTTP GET Flooding with Cache-Control(CC Attack) : 공격자는 HTTP 메시지의 캐시 옵션(Cache-Control:no-store, must-revalidated)을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도하여 캐싱 서버의 기능을 무력화하고 웹서버의 자원을 소모시키는 공격
9. Slow HTTP POST(rudy) : HTTP POST 메소드를 이용하여 서버로 전달할 대량의 데이터를 장시간에 걸쳐 분할 전송하면 서버는 POST 데이터가 모두 수신하지 않았다고 판단하여 연결을 장시간 유지하게 하는 공격
10. Slow HTTP Header DoS(Slowris) : 웹서버는 HTTP 메시지의 헤더 부분을 먼저 수신하여 이후 수신할 데이터의 종류를 판단하게 되는데, 헤더 부분을 비정상적으로 조작하여 웹서버가 헤더 정보를 구분할 수 없도록 하면 웹서버는 아직 HTTP 헤더 정보가 모두 전달되지 않은 것으로 판단하여 연결을 장시간 유지하게 된다.
11. Slow HTTP Read DoS : 공격자는 웹서버와 TCP 연결 시, TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신하여 웹서버가 정상적으로 응답하지 못하도록 DoS 상태를 유발한다.
12. 해시도스(HashDoS) 공격 : 웹서버는 클라이언트로부터 전달받은 HTTP 메시지의 매개정보를 관리하기 위해 해시테이블을 사용한다. 조작된 매개정보를 포함한 다량의 메시지는 해시테이블 검색을 위한 인덱스로 사용되는 해시값에 충돌을 발생시켜 정확한 값을 찾기 위해 모든 해시테이블을 검사하게 되는데 이때 웹서버의 CPU 자원을 소진하게 되어 정상적인 서비스를 방해한다.
13. 헐크도스(HulkDoS) 공격 : GET Flooding 공격유형으로 동일 URL을 지속적으로 요청 시 차단될 수 있기 때문에 이를 우회하기 위해 URL을 지속적으로 변경하면서 공격하는 방식
