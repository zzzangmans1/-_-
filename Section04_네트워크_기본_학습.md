# 1. 프로토콜
## (1) 개요
1. 시스템 간에 통신하기 위한 규약
2. 프로토콜은 구문, 의미, 타이밍으로 이루어져 있다.

## (2) 프로토콜의 구성요소
1. 구문 : 송수신 데이터 포맷을 의미한다.
2. 의미 : 데이터의 각 항목이 가지는 의미를 의미한다.
3. 타이밍 : 데이터 송수신 동작 방식을 정의하는 것을 의미한다.

# 2. OSI 7 Layer
## (1) 개요
1. 국제 표준화 기구(ISO)에서 제정한 개방형 시스템 간의 상호연결(OSI: Open System Interconnection) 모델
2. 분산된, 이기종 시스템 간의 네트워크 상호호환을 위해 필요한 표준 아키텍처를 정의한 참조모델
3. 기능에 따라 계층적으로 표준화 되어 있다. 어떤 목적을 수행하기 위해서 하나의 큰 프로토콜을 설계하는 것이 아니라 계층적으로 나누어진 여러 프로토콜을 조합하여 그 목적을 수행하는 방식이다. 이러한 접근 방식을 "분할 정복"이라 한다.
4. 계층별로 표준화를 함으로써 상하위 계층 간에 인터페이스만 충족시켜주면 다양한 제조자들에 의한 독자적인 계층별 프로토콜의 구현 및 발전을 이룰 수 있다.

## (2) 계층별 특징
### 1) Pysical Layer (물리 계층, L1)
#### (가) 개요
1. 물리적 장치의 전기적, 전자적 연결에 대한 명세
2. 디지털 데이터를 전기적인, 광학적인 신호로 변환하여 입출력을 담당하는 계층으로 1계층에는 주소 정보가 없다. 따라서 목적지를 인식할 수 없고 전기적인 신호만을 연결된 모든 노드에 전달한다.
3. 물리 계층의 데이터 단위를 **비트**라 한다.

#### (나) 주요 네트워크 장비
1. HUB(허브) : 들어온 신호를 연결된 모든 포트로 전달하는 중계 장치이다. 이러한 허브를 Dummy Hub라고 한다.(2계층 장비는 Switching Hub로 구별)
    * Switching Hub : Dummy Hub는 연결된 모든 노드에게 신호를 전달하는 반면에 Switching Hub는 목적지 주소(2계층 장비이므로 MAC 주소를 의미)를 식별하여 해당 목적지 노드가 연결된 포트로만 신호를 전달하는 장비를 말합니다.
2. REPEATER(리피터) : 감쇠된 전송신호를 새롭게 재생하여 다시 전달하는 재생 중계 장치이다.

#### (다) 허브(Dummy Hub) 환경에서의 스니핑(Sniffing)
1. 더미 허브는 전달받은 패킷을 단순히 연결된 모든 노드로 전송하기 때문에 허브에 연결되어있는 모든 노드는 스니퍼를 통한 스니핑이 용이하다. 단, 네트워크 카드의 기본동작모드가 자신을 목적지 주소로 하는 패킷이 아니면 모두 폐기하기 때문에 패킷을 볼 수 있는 것은 아니다.
2. 네트워크 카드(NIC)의 동작모드를 **무차별 모드(Promiscuous Mode)**로 설정하면 자신이 목적지가 아닌 패킷도 모두 수신하기 때문에 더미 허브 환경에서 손쉽게 스니핑할 수 있다. 일반적으로 스니퍼가 동작할 때 네트워크 카드의 동작모드를 무차별 모드로 설정한다.

### 2) Data Link (데이터 링크 계층, L2)
#### (가) 개요
1. Node-To-Node Delivery, 인접한 노드 간의 신뢰성 있는 프레임 전송을 담당하는 계층이다. 데이터링크 계층은 인접노드 간의 통신이며 최종 목적지 노드에 도달하기 위해서는 각각의 노드 간에 프레임에 대한 주소설정(MAC 주소)이 이루어진다.
2. 목적지 노드를 찾아가기 위해서는 목적지 노드에 대한 물리적인 주소가 필요하며 네트워크 카드(NIC)의 MAC 주소가 해당 역할을 한다.
3. IEEE 802 표준에서는 LAN 상의 데이터링크 계층을 LLC(Logical Link Control) 와 MAC(Media Access Control) 두 개의 하위 계층으로 세분화한다.
    * LLC (Logical Link Control) : 네트워크 계층과의 연결을 담당하는 계층으로 상위 계층으로 안전하고 정상적인 데이터를 전달하기 위해 데이터 오류 검출 및 상위 프로토콜에 대한 타입 확인
    * MAC (Media Accesss Control) : 물리적 계층과의 연결을 담당한느 계층으로 신호변환을 통해 물리적 계층과 연결하고 MAC 주소를 통해 주소를 확인하여 정상적으로 데이터가 송수신되고 있는지 확인
4. 데이터링크 계층의 데이터 단위를 **프레임**이라 한다.
5. 데이터링크 계층의 대표적 프로토콜로 Eternet, TokenRing, FDDI, X.25, Frame Relay 등이 있다.

#### (나) 신뢰성 있는 전송을 위한 기능
1. 신뢰성 있는 전송이란 데이터의 안전한 전송을 보장해준다는 의미로 이러한 기능들을 일반적으로 데이터링크 컨트롤이라 한다.
2. **흐름제어 (Flow Contorl)** : 송신 노드가 수신 노드의 처리 속도를 고려하여 이를 초과하지 않도록 전송을 제어한다. 이러한 흐름제어는 수신 노드가 수신확인응답을 송신 노드에 제공함으로써 흐름제어를 수행하는데 다음 2가지 방식이 있다.
    * **정지-대기 (Stop and Wait)** : 송신 측에서 프레임을 전송한 후 확인응답(ACK)을 받을 때까지 대기하는 방식
    * **슬라이딩 윈도우 (Sliding Window)** : 송신 측에서 수신 측의 수신확인응답을 받기 전에 수신 가능한 범위 내에서 여러 프레임을 전송하는 방식
3. **오류제어 (Error Control)** : 전송 중에 여러 가지 원인(주파수 혼란, 감쇠, 잡음 등)에 의한 오류나 손실 발생 시 이를 해결하기 위한 제어방식이다. 오류제어 방식에는 다음 2가지 방식이 있다.
    * **후진 오류 수정방식 (BEC, Backward Error Correction)** : 송신 측에서 데이터전송 시 오류를 검출할 수 있는 부가 정보를 함께 전송하여 수신 측에서 이를 점검하여 오류 발생 시 재전송을 요청하는 방식으로 이러한 요청을 ARQ(Automatic Repeate Request)라 한다.
    * **전진 오류 수정방식 (FEC, Forward Error Correction)** : 재전송이 불필요한 방식으로 송신 측에서 데이터 송신 시에 오류의 검출 및 수정까지 가능한 부가 정보를 담아서 보내는 방식
4. **회선제어 (Line Control)** : 점-대-점(Point-to-Point) 또는 다중점 회선 구성 방식 과 단방향, 반이중 및 전이중 등의 전송 방식에 따라 사용되는 전송링크에 대한 제어 규범이다.

#### (다) 주요 네트워크 장비
1. L2 Switch
    * 스위치 장비는 내부적으로 MAC Address Table을 가지고 있다. 이 테이블에는 스위치 포트에 연결된 노드의 MAC 정보를 담고 있다. 이 정보를 참조하여 목적지 MAC 주소의 포트에 연결된 노드에게만 패킷을 전송한다.
    * 스위치 환경에서 특정 포트를 모니터링하고자 한다면 모니터링 포트 또는 네트워크 트래픽을 모니터링할 수 있는 탭 장비를 통해 패킷을 복제해서 트래픽 분석 장비로 전달한다.
    * 스위치 환경에서는 기본적으로 목적지로만 패킷을 전송하기 때문에 스니핑이 불가능하다. 이러한 환경에서 스니핑을 하기 위해서는 스위치 재밍, ARP 스푸핑, ARP 리다이렉트, ICMP 리다이렉트, 스위치의 SPAN/Monitoring Port 이용 등이 있다.
2. Bridge
    * 물리적으로 떨어진 동일한 LAN을 연결해주는 장비

#### (라) 스위치 환경에서의 스니핑 공격 기법
1. **스위치 재밍(Switch Jamming)/MAC Flooding 공격**
   * 스위치 MAC Address Table의 버퍼를 오버플로우 시켜서 스위치가 허브처럼 동작하게 강제적으로 만드는 기법을 말한다. 스위치는 Fail Safe/Open 정책을 따르는 장비이므로 장애가 발생하면 더미 허브처럼 연결된 모든 노드에 패킷을 전송한다.
   * MAC Address Table을 채우기 위해(오버플로우 시키기 위해) Source MAC 주소를 계속 변경하면서 패킷을 지속적으로 전송하는 방식을 사용한다.
2. **ARP 스푸핑 공격**
   * **공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply 패킷을 만들어 희생자에게 지속적으로 전송하면 희생자의 ARP Cache Table에 특정 호스트의 MAC 정보가 공격자의 MAC 정보로 변경된다.** 이를 통해서 희생자로부터 특정 호스트로 나가는 패킷을 공격자로 향하도록 하여 스니핑하는 기법이다.
   * 희생자와 특정 호스트 간의 송수신 패킷을 모두 스니핑하기 위해서는 희생자와 특정 호스트 모두 ARP 스푸핑을 수행한다.
   * **희생자들이 스누핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화**한다.
      * IP Forwarding 기능 : 일반적인 호스트 설정의 경우 자신을 목적지 주소로 하지 않는 IP 패킷을 수신한 경우 모두 폐기하지만 IP Forward 기능을 활성화하면 라우터처럼 동작하여 자신이 목적지가 아닌 IP 패킷에 대해서는 라우팅 테이블을 참조하여 해당 목적지로 전송하게 됩니다.
3. **ARP 리다이렉트 공격**
   * **ARP 스푸핑 공격의 일종으로 공격자가 자신이 라우터/게이트웨이인 것처럼 MAC 주소를 위조하여 ARP Reply 패킷을 대상 네트워크에 지속적으로 브로드캐스트하면 해당 로컬 네트워크의 모든 호스트의 ARP Cache Table에 라우터/게이트웨이의 MAC 정보가 공격자의 MAC 정보로 변경**이 된다. 이를 통해 호스트에서 라우터로 나가는 패킷을 공격자가 스니핑하는 기법이다.
   * 희생자들이 스니핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화한다.
4. **ICMP 리다이렉트 공격**
   * **ICMP Redirection 메시지는 호스트-라우터 또는 라우터 간에 라우팅 경로를 재설정하기 위해 전송하는 메시지**이다. 공격자가 이를 악용하여 특정 IP 또는 IP 대역으로 나가는 패킷의 라우팅 경로를 **자신의 주소로 위조한 ICMP Redirect 메시지를 생성하여 희생자에게 전송함으로써 희생자의 라우팅 테이블을 변조하여 패킷을 스니핑하는 공격**기법이다.
   * 희생자들이 스니핑을 인식하지 못하고 정상적인 통신이 될 수 있도록 IP Forward 기능을 활성화한다.
5. **스위치의 SPAN (Switch Port ANalyzer)/Port Mirroring 기능 이용**
   * 스위치의 SPAN/Port Mirroring 기능은 스위치를 통과하는 모든 트래픽을 볼 수 있는 기능으로 특정 포트에 분석 장비를 접속하고 다른 포트의 트래픽을 분석 장비로 자동 복사해주는 기술이다.
   * 관리적인 목적으로 사용하지만, 공격자가 물리적으로 해당 포트에 접근할 수 있다면 손쉽게 패킷을 스니핑 할 수 있다.

### 3) Network Layer (네트워크 계층, L3)
#### (가) 개요
1. End-To-End Delivery, End 노드(종단노드) 간의 라우팅을 담당하는 계층으로 Host-To-Host Delivery라고도 한다.
2. 라우팅이란 라우팅 알고리즘에 의해 목적지로 전송하기 위한 최적의 경로를 설정하고 패킷을 교환하는 기능을 제공하는 것을 말한다.
3. 최종 목적지 노드를 찾아가기 위해서는 노드에 대한 논리적인 주소가 필요한데 TCP/IP 프로토콜에서는 IP 주소가 이 역할을 한다.
4. 네트워크 계층의 데이터 단위를 **패킷**이라 한다.
5. 대표적으로 IP(TCP/IP), IPX(Novel Netware) 등이 있다.

#### (나) 주요 네트워크 장비
1. 라우터 / L3 Switch
   * 라우팅(최적의 경로를 선정해서 패킷을 포워딩하는 기능)을 담당하는 장비
   * 데이터 링크 계층의 브로드캐스트와 멀티캐스트를 포워딩 하지 않으며, 서로 다른 VLAN간에 통신을 가능하게 하고, 기본적인 보안 기능과 QoS관련 기능을 지원하는 장비

### 4) Transport Layer (전송 계층, L4)
#### (가) 개요
1. End-To-End Reliable Delivery, End 노드 간의 신뢰성 있는 데이터전송을 담당하는 계층이다. 좀 더 구체적으로 말하면 각 End 노드의 해당 Process 간 신뢰성 있는 데이터전송을 담당하는 계층이다. (Process-To-Process Communication)
2. 목적지 Node(Process)를 찾아가기 위해서는 Process를 식별하기 위한 논리적인 주소가 필요하며 TCP/IP 프로토콜에서는 Port Address가 이 역할을 한다.
3. 전송 계층의 데이터 단위를 **세그먼트**라 한다.
4. 대표적 프로토콜로 TCP/IP의 TCP, UDP, SCTP와 Novel Netware의 SPX 등이 있다.

#### (나) 신뢰성 있는 데이터 전송을 보장하기 위한 기능
1. **분할 (Segmentation)과 재조합 (Reassembly)**
   * 조건에 따라 원본 데이터를 전송 가능한 세그먼트 단위로 분할하여 전송하면 목적지에서는 이를 재조합하여 원본 데이터를 복원한다.
2. **연결제어 (Connection Control)**
   * 연결지향(TCP) 과 비연결지향(UDP) 방식을 제공한다.
3. **흐름제어 (Flow Control)**
   * 흐름제어를 한다는 것은 상호 간에 수신할 수 있는 만큼만 전송해서 데이터의 손실이 발생하지 않도록 하는 제어방식을 말한다.
   * 종단 노드 간 흐름제어를 수행한다. **데이터링크 계층은 바로 인접한 노드 간에 흐름제어**를 했다면 **전송 계층에서는 양 종단노드 간에 흐름제어를 수행하므로 그 범위가 넓다**.
4. **오류제어 (Error Control)**
   * 종단노드 간 전송 중 오류 발생 시 이를 교정한다.
5. **혼잡제어 (Congestion Contorl)**
   * 네트워크 혼잡도를 계산하여 전송량을 제어한다.

#### (다) 주요 네트워크 장비
1. L4 Switch : SLB (Server Load Balancing) 즉 서버 트래픽 부하분산과 Failover 기능을 제공한다.
   * **장애 조치 (Failover)** : 시스템에 장애가 발생했을 때 예비 시스템으로 자동 전환되는 기능을 말한다.
  
### 5) Session Layer (세션 계층, L5)
#### (가) 개요
1. Application간 논리적인 연결인 세션의 생성, 관리 및 종료를 담당하는 계층

### 6) Presentation Layer (표현 계층, L6)
#### (가) 개요
1. 데이터 표현방식 변환을 담당하는 계층
2. 인코딩/디코딩, 압축/압축해제, 암호화/복호화 등을 담당한다.

### 7) Application Layer (응용 계층, L7)
#### (가) 개요
1. 사용자가 네트워크에 접근할 수 있는 인터페이스를 담당하는 계층
2. 네트워크 서버/클라이언트 프로그램
3. 응용 계층의 데이터 단위를 **데이터**라고 한다.
   * 일반적으로 5,6,7 계층 데이터 단위를 모두 데이터라 한다.

# 3. OSI 모델 데이터 교환 방식
### 1) Encapsulation(캡슐화)/Decapsulation(역캡슐화)
1. 상위 계층의 데이터가 하위계층으로 보내지면, 하위 계층 프로토콜은 자신의 기능 수행을 위해 필요한 부가 정보(헤더)를 추가해서 새롭게 전송 메시지를 완성한다. 이를 캡슐화라고 한다.
2. 수신 측에서는 상위 계층으로 데이터를 보낼 때 해당 계층의 헤더 정보를 확인한 후 제거하고 상위 계층으로 데이터를 보낸다. 이를 역캡슐화 라고 한다.

### 2) Multiplexing(다중화)/Demultiplexing(역다중화)
1. 다중화는 하나의 기능(매체)을 여러 영역에서 동시에 사용하는 기법을 말한다. 상위 계층의 여러 프로토콜이 하위 계층의 하나의 프로토콜을 이용하여 데이터를 전달하는 방식으로 수신 측에서 상위 프로토콜을 구별할 수 있도록 프로토콜 식별자 정보를 헤더에 추가한다.
2. 역다중화는 공유하는 기능(매체)으로부터 개별 영역으로 분할하는 기법을 의미한다. 하위계층의 프로토콜이 여러 상위 계층 프로토콜 중 하나를 식별하여 데이터를 전달하는 방식으로 이를 위해서는 상위 프로토콜을 구별하기 위한 프로토콜 식별자 정보(다중화 시에 헤더에 설정된 정보)를 이용한다.

# 4. TCP/IP 프로토콜
### 1) Application Layer (응용 계층)
#### (가) 개요
1. 네트워크 서버/클라이언트 프로그램을 담당하는 계층
2. 사용자와의 인터페이스를 담당하는 계층

#### (나) 주요 프로토콜
1. HTTP(80/tcp) : Hyper-Text Transfer Protocol
2. FTP(20/21/tcp) : File Transfer Protocol, 데이터 포트(20), 제어 포트(21)
3. SSH(22/tcp) : Secure Shell, 암호화된 원격 터미널 접속 프로토콜
4. SFTP(22/tcp) : SSH File Transfer Protocol, SSH를 이용한 암호화된 파일 송수신 프로토콜
5. TELNET(23/tcp) : TELe NETwork, 암호화하지 않은 원격 터미널 접속 프로토콜
6. SMTP(25/tcp) : Simple Mail Transfer Protocol, 메일 전송용 프로토콜
7. POP3(110/tcp) : Post Office Protocol Version3, 메일 수신용 프로토콜
8. IMAP(143/tcp) : Internet Message Access Protocol, 메일 수신용 프로토콜
9. DNS(53/tcp,udp) : Domain Name System, 도메인명에 대한 호스트 정보를 제공해주는 프로토콜
10. DHCP(67,68/udp) : Dynamic Host Configuration Protocol, 서버(67), 클라이언트(68), 동적으로 호스트 네트워크 설정을 제공해주는 프로토콜
11. TFTP(69/udp) : Trivial FTP, 단순 파일 송수신 프로토콜
12. SNMP(161/udp) : Simple Network Management Protocol, 네트워크 관리 프로토콜

### 2) Transport Layer(전송 계층)
#### (가) 개요
1. Process-To-Process Communication, 프로세스 간 신뢰성 있는 데이터전송을 담당하는 계층으로 신뢰성 있는 전송이란 전송 중에 발생하는 오류, 누락 및 흐름제어, 혼잡제어 등을 적절히 수행하여 데이터의 안전한 전송을 보장함을 말한다.
2. 프로세스를 식별하기 위한 논리적인 주소로 Port(16bit) 주소를 사용한다.

#### (나) 주요 프로토콜
1. TCP(Transmission Control Porotocl) : 신뢰성 있는 연결지향 프로토콜(스트림 기반 전송)
2. UDP(User Datagram Protocol) : 비신뢰적인 비연결형 프로토콜(데이터그램 기반 전송)
3. SCTP(Stream Control Protocol) : TCP와 UDP의 조합형

### 3) Internet Layer(인터넷 계층)
#### (가) 개요
1. Host-To-Host Communication, 호스트 간의 라우팅을 담당하는 계층
2. 호스트를 식별하기 위한 논리적은 주소로 IP(IPv4:32bit, IPv6:128bit) 주소를 사용한다.

#### (나) 주요 프로토콜
1. IP(Internet Protocol) : 비신뢰적인 비연결형 데이터그램 프로토콜
2. ICMP(Internet Control Message Protocol) : 에러 및 상태진단 메시지 프로토콜
3. IGMP(Internet Group Management Protocol) : 멀티캐스트용 프로토콜
4. ARP(Address Resolution Protocl) : 주소변환(논리주소(IP) -> 물리주소(MAC)) 프로토콜
5. RARP(Reverse Address Resolution Protocol) : 역주소변환(물리주소(MAC) -> 논리주소(IP)) 프로토콜

### 4) Network Interface Layer(네트워크 인터페이스 계층)
#### (가) 개요
1. Node-To-Node Delivery, 인접한 노드 간에 신뢰성 있는 데이터전송을 담당하는 계층
2. Node를 식별하기 위한 물리적인 주소로 MAC(48bit) 주소를 사용한다. 물리적 MAC 주소는 상위 24비트와 하위 24비트로 이루어져 있으며 상위 24비트는 제조사(벤더) 식별코드이고 하위 24비트는 제조사가 할당한 일련변호를 의미한다.

#### (나) 주요 프로토콜
1. LAN(Local Area Network) 프로토콜 : Ethernet, TokenRing, FDDI 등
2. WAN(Wide Area Network) 프로토콜 : X.25, Frame Relay, PPP, SLIP 등

# 5. ARP/RARP 프로토콜(TCP/IP 인터넷 계층)
### 1) ARP 및 RARP 프로토콜 특징
1. 논리적인 주소와 물리적인 주소 사이의 변환을 담당하는 프로토콜
2. ARP(Address Resolution Protocol) : 논리적인 IP 주소를 물리적인 MAC 주소로 변환해주는 역할을 하는 프로토콜
3. RARP(Reverse ARP)
   * 물리적인 MAC 주소를 논리적인 IP 주소로 변환해주는 역할을 하는 프로토콜
   * 일반적으로 IP 주소는 시스템의 하드디스크 내 설정 파일에 저장되어 있지만 하드디스크가 없는 터미널의 경우에 초기 가동될 때 자신의 MAC 주소를 담아 RARP 요청을 만들어 자신의 IP 주소 정보를 받아오게 된다. MAC에 해당하는 IP 주소 정보를 관리하는 RARP 서버가 구성되어 있어야 한다.
  
### 2) ARP 동작방식
1. **최초 상대방의 물리적인 주소를 알지 못하기 때문에(논리적인 IP 주소만 알고 있는 상태) ARP 요청 메시지를 만들어 브로드캐스트**한다.
   * ARP 요청 메시지를 캡슐화한 이더넷 프레임의 목적지 MAC 주소를 살펴보면 브로드캐스트 주소인 ```FF:FF:FF:FF:FF:FF``` 로 전송한다.
2. **Target 호스트에서는 ARP 응답 메시지를 만들어서 응답**한다. **응답메시지에는 Target 호스트의 MAC 주소 정보가 담겨있으며 응답자는 요청자의 MAC 주소를 알고 있으므로 유니캐스트 방식으로 응답**한다. Target이 아닌 호스트들은 수신한 브로드캐스트 요청 메시지를 폐기한다.
   * ARP 응답메시지를 캡슐화한 이더넷 프레임의 목적지 MAC 주소를 살펴보면 요청 메시지를 보낸 호스트의 MAC 주소로 설정된 것을 확인할 수 있다.
3. 각 시스템은 ARP Cache가 있고 Cache에 이 정보를 보관해 둔다. 물론 일정 시간 경과 후에는 삭제된다.

### 3) RARP 동작방식
1. **최초 자신의 논리적인 IP 주소를 알지 못하기 때문에(물리적인 MAC 주소만 알고 있는 상태) 자신의 MAC 정보를 담고 있는 RARP 요청 메시지를 만들어서 브로드캐스트**한다.
2. **RARP Server는 요청자의 IP 주소 정보를 담은 RARP 응답 메시지를 만들어 요청자의 MAC 주소로 유니캐스트 방식으로 응답**을 준다.

### 4) ARP cache table 살펴보기
#### (가) 개요
1. ARP 요청을 통해 알아낸 MAC 정보는 OS에 따라 다르지만 통상 1~2분 정도 메모리에 저장한다.
2. arp -a 명령을 통해 ARP cache table을 살펴보면 타입이 dynamic 또는 static으로 지정이 되어 있다. dynamic으로 된 것은 arp에 의해 동적으로 설정된 것으로 일정 시간 동안 유지된다. static으로 된 것은 관리자에 의해 정적으로 설정된 것으로 관리자가 삭제하거나 시스템이 종료하기 전까지 지속적으로 유지된다.

#### (나) 관련 명령어
1. arp -a : 캐시 내용 보기
   * 윈도우의 경우 MAC 주소 구분자 "-" 사용
   * 리눅스의 경우 MAC 주소 구분자 ":" 사용
2. arp -d : 캐시 내용 삭제
   * 윈도우의 경우 arp cache에 저장된 모든 내용 삭제
   * 리눅스의 경우 IP를 명시해야 하고 삭제된 항목은 일정 시간 <incomplete> 상태로 보인 후 삭제된다.
3. arp -s : 캐시 정적 설정
   * 윈도우의 경우 static으로 설정된 정보는 시스템 종료 시까지 유지된다.
   * 리눅스의 경우 PERM으로 설정된 정보는 시스템 종료 시까지 유지된다.

### 5) ARP Spoofing 공격(ARP Cache Poisoning)
#### (가) 개요
1. 공격자가 희생자의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply를 만들어 희생자에게 지속적으로 전송하면 희생자 ARP Cache Table의 MAC 정보가 공격자의 MAC 정보로 지속적으로 변경된다. 이를 통해서 희생자 간의 송수신 패킷을 공격자가 스니핑하는 기법이다.
2. 공격자는 희생자간에 정상적인 통신이 이루어질 수 있도록(스니핑을 눈치채지 못하도록) IP Forward 기능을 활성화한다.
3. **일반적으로 희생자 ARP Cache의 Gateway(Router) 주소를 공격자 MAC 주소로 변조시켜서 외부로 나가는 데이터를 스니핑하는데 이를 특별히 ARP Redirect 공격**이라 한다.
4. **ARP Spoofing은 2계층 주소인 MAC 주소를 속여서 트래픽을 스니핑하는 것이므로 2계층에서 동작하게 된다. 2계층 주소는 서로 다른 네트워크로 라우팅되지 않기 때문에 공격 대상도 동일 네트워크 대역에 있어**야 한다.

#### (나) 실습
1. 희생자PC ARP Cache Table 변조
   * 공격 전 : 첫 번째 "arp -a" 명령 결과를 살펴보면 희생자PC의 MAC 주소가 정상적으로 설정되어 있음을 확인할 수 있다.
   * 공격 후 : 두 번째 "arp -a" 명령 결과를 살펴보면 희생자PC의 MAC 주소가 공격자PC의 MAC 주소와 동일하게 설정되어 있음을 확인할 수 있다. 즉 공격자에 의해 조작된 arp reply 패킷에 의해 cache 정보가 변조되었음을 알 수 있다.
   * 희생자PC에서 패킷 캡처한 결과를 살펴보면 공격자에 의해 주기적으로 arp reply 패킷이 발생하고 있으며 arp 프로토콜의 sender MAC과 IP를 보면 희생자 PC의 MAC 주소가 공격자의 MAC 주소로 조작되어 있다.
2. 희생자 PC ARP Cache Table 변조
   * 희생자PC와 동일하게 공격자PC에 의해 Cache 정보가 변조되었음을 확인할 수 있다.

#### (다) 대응방법
1. ARP 요청 및 응답 과정에서 별도의 인증과정이 없는 ARP 프로토콜 자체의 취약점을 이용한 공격이기 때문에 완벽한 방어는 없다. 일반적인 대응 방법은 ARP 캐시를 정적으로 설정하여 ARP 응답을 수신해도 캐시 정보를 갱신하지 않도록 한다.
2. 캐시 정보는 시스템 종료 시 삭제되므로 시스템 기동 시마다 ARP 캐시를 정적으로 구성해 주어야 한다.
3. 네트워크상의 ARP 트래픽을 실시간으로 모니터링하는 프로그램(ARP Watch 등)을 이용하여 IP와 MAC 주소의 매핑을 감시, 변경 발생 시 즉시 확인하도록 한다.

### 6) GARP (Gratuitous ARP)
#### (가) 개요
1. Gratuitous란 "불필요한"이란 의미이다. GARP는 별도의 프로토콜이 아니고 Sender IP와 Target IP가 동일한 ARP 요청을 GARP라고 한다.
2. 장비가 ARP 요청 브로드캐스트를 통해 다른 장비에게 네트워크에 있는 자신의 존재를 알리는 목적으로 사용되는 패킷이다. 이 패킷을 수신한 장비는 자신의 ARP Cache에 해당 정보가 있다면 이를 갱신한다.
3. 자신의 MAC 정보를 동일 네트워크상의 다른 장비들에 알려 ARP Cache를 갱신하도록 하는 목적이다.

#### (나) 목적
1. IP 충돌 감지
   * IP 충돌 여부를 GARP를 통해 검색한다. 즉 자신과 동일한 IP가 설정된 호스트가 있다면 해당 호스트로부터 ARP 응답이 오기 때문에 충돌 여부를 확인할 수 있다.
   * 일반적으로 호스트 IP를 변경하거나 재부팅 시에 GARP 패킷이 생성된다.
2. 상대방의 ARP Cache 정보 갱신
   * GARP 메시지를 수신한 쪽에서는 자신의 ARP Cache에 Sender IP 정보를 갱신한다.
   * 이 부분이 취약점이 될 수 있다. 즉 상대방을 인증하지 않고 Cache 정보를 갱신하게 되므로 악의적인 목적의 공격자에 의해 MAC 정보가 위변조될 수 있다.

# 6. IP(IPv4) 프로토콜
### 1) 개요
1. 비연결형 프로토콜로 연결 상태를 유지하지 않기 때문에 패킷 전송 순서를 보장하지 않는다.
2. 비신뢰적 프로토콜로 신뢰성 있는 통신을 보장하지 않는다.
3. IP는 목적지 주소를 기반으로 라우팅을 담당하는 인터넷 계층의 대표 프로토콜이다. 라우팅은 라우팅 알고리즘을 통해 최적의 경로를 선정하여 목적지를 찾아가는 것을 말한다.

### 2) IP 프로토콜 구조
1. VER(4 bits) : IP의 버전 정보, 일반적으로 IPv4 사용
2. HLEN(4 bits) : 헤더 길이, 4 bytes 단위로 표현
3. Service type(8 bits) : 서비스 품질(QoS)을 위한 용도이지만 현재 사용하지 않음
4. Total length(16 bits) : 헤더부와 데이터부를 포함한 전체 IP Packet의 길이
5. **Identification(16 bits)** : 단편화/재조합 관련 필드
   * IP 데이터그램을 여러 조각으로 분할하는 것을 단편화라 하고 분할된 단편들을 조합하여 원본 IP 데이터그램을 완성하는 것을 재조합이라 한다.
   * 단편화 전 원본 IP 데이터그램을 식별하기 위한 ID
6. **Flags(3 bits)** : 단편화/재조합 관련 필드
   * 첫 번째 비트 : 사용 안 함(예약)
   * 두 번째 비트 : Don`t fragment bit(1 설정 시 패킷을 단편화하지 말라는 의미)
   * 세 번째 비트 : More fragment bit(1 설정 시 재조합할 단편이 남아 있다는 의미이고 0 설정 시 단편이 더 이상 없다는 의미이다.)
7. **Fragmentation offset(13 bitsx)** : 단편화/재조합 관련 필드
   * IP의 특성상 원본 IP 데이터그램의 단편들이 순서대로 전송되는 것이 아니므로 이를 순서대로 조합하기 위한 현재 단편의 상대위치를 저장한 필드
   * 8 bytes 단위로 표현한다.
8. **Time to live(8 bits)** : IP 패킷의 생존시간을 지정하는 필드
   * 최초에 초 단위로 생존시간을 명시할 의도였으나 시간 측정의 어려움으로 인해 라우터/L3스위치 통과 횟수(hop count라고 함)로 그 의미가 바뀜
   * 패킷이 라우터/L3스위치에 도착하면 TTL값을 1 감소시키고 그 값이 0이 되면 해당 패킷을 폐기한다.
   * TTL을 설정하는 목적은 라우터/L3스위치를 통해 패킷 라우팅을 하던 중 무한 루핑이 발생하여 목적지에 도달할 수 없는 패킷이 무한히 생존하여 네트워크 대역만 차지하는 상태를 방지하기 위함이다.
   * 일반적으로 Linux는 64, Windows는 128, Unix는 255를 설정한다. 운영체제별로 부여하는 기본 TTL값이 다르기 때문에 해당 필드를 "OS 핑거프린트" 목적으로 사용할 수 있다.
9. Protocol(8 bits) : 상위 프로토콜을 식별하기 위한 프로토콜 번호를 저장하는 필드
   * 상위 프로토콜과 다중화, 역다중화를 식별값으로 ICMP(1), TCP(6), UDP(17) 등이 있다.
10. Header checksum(16 bits) : 데이터부를 제외한 헤더 부분의 오류 검사값
11. Source IP address(32 bits) : 출발지 IP 주소
12. Destination IP address(32 bits) : 목적지 IP 주소
13. 주요 IP 옵션 헤더
   * Loose Source Route : Source Route는 라우팅 경로를 라우터/L3 스위치가 아닌 출발지에서 지정하는 옵션으로 느슨한(Loose) 소스 라우팅은 경우에 따라 다른 경로로 라우팅할 수 있다.
   * Strict Source Route : 엄격한(Strict) 소스 라우팅은 출발지에서 지정한 경로로 무조건 라우팅하는 옵션이다.

### 3) IP 단편화(Fragmentation)
#### (가) 개요
1. IP 패킷/데이터그램은 MTU에 따른 단편화가 발생한다.
   * MTU(Maximum Transmission Unit) : 물리적인 네트워크 프로토콜 프레임의 데이터부의 최대 크기를 말한다.
   * 물리적인 네트워크 프로토콜들은 각자 물리적인 특성에 맞게 정의된 MTU를 가진다. IP 패킷이 LAN 또는 WAN의 다양한 프로토콜의 상위 프로토콜로 사용할 수 있는 이유가 이 단편화를 이용한 패킷 크기 조절이 가능하기 때문이다. 가장 많이 사용하는 이더넷의 경우 MTU는 1,500바이트이다.
   * IP 패킷이 프레임으로 캡슐화되기 때문에 MTU를 초과하는 크기가 될 수 없다. 예를 들어 대표적인 이더넷의 경우 MTU가 1,500바이트이기 때문에 IP 패킷이 이보다 크다면 1,500바이트 이하의 크기로 단편화하여 전송해야 한다.
2. 단편화는 최초 출발지뿐만이 아니라 라우터/L3스위치 중계 구간의 MTU에 따라 추가적으로 발생하지만, 단편화된 패킷은 통신 효율을 위해 중계 구간의 MTU가 달라진다고 해도 재조합되지 않으며 최종 목적지에만 재조합된다.

#### (나) 동작방식
1. 첫 번째 단편을 살펴보면 데이터부는 1480byte(IP 헤더 20byte를 포함하여 1500byte)이고 두 번째 단편이 있기 때문에 "More fragments bit(3번째 Flag)"가 1이고 Offset은 첫 번째 단편이기 때문에 0으로 설정되어 있다. 모든 단편이 동일한 원본 IP 데이터그램의 단편이기 때문에 단편 ID가 22666으로 동일하다.
2. 두 번째 단편을 살펴보면 데이터부는 1480byte이고 세 번째 단편이 있기 때문에 "More fragments bit(3번째 Flag)"가 1이고 두 번째 단편은 첫 번째 단편 다음에 위치하기 때문에 1480으로 Offset이 설정된다.
3. 세 번째 단편을 살펴보면 데이터부는 48byte이고 마지막 단편이기 때문에 "More fragments bit(3번째 Flag)"가 0이고 세 번째 단편은 두 번째 단편 다음에 위치하기 때문에 2960이 Offset으로 설정되어 있다.
4. tcpdump의 IP 단편화 관련 출력 형식은 다음과 같다.
```
(frag:"단편 ID":"단편의 크기(IP 헤더 제외)"@"오프셋"+)
+ 있음 : 추가 단편 있음(More Fragments bit : 1)
- 없음 : 마지막 단편(More Fragments bit : 0)
```

### 4) IP 라우팅
#### (가) 라우팅 규칙
1. 첫째로 목적지 주소가 자신과 동일한 네트워크에 있다면 직접 전송한다.
2. 둘째로 목적지 주소가 자신과 동일한 네트워크에 속하지 않는다면 직접 전송이 불가하기 때문에 1차 경유지 주소를 라우팅 테이블을 참조하여 찾는다.
   * 라우팅 테이블은 임의의 목적지로 가기 위한 경로 정보를 저장하고 있는 자료구조이다. "netstat -rn" 명령을 통해 호스트의 라우팅 테이블 정보를 확인할 수 있다.
3. 셋째로 목적지 주소와 자신의 주소가 서로 동일한 경우 목적지가 자신이므로 상위 계층으로 데이터를 전달한다.

#### (나) 라우팅 테이블 검색 방식 및 우선순위
1. 검색 방식 : IP 패킷의 목적지 IP와 라우팅 테이블의 netmask/genmask를 bit and(&) 연산 수행 후 라우팅 테이블의 destination 필드와 비교, 일치하는 경로를 선택하여 패킷을 전송한다.
   * 패킷의 목적지 IP와 netmask/genmask간에 bit and 연산을 한다는 의미는 목적지 IP에서 네트워크 ID 부분만을 추출하기 위한 과정이다.
2. 검색 우선순위
   * 먼저 목적지 호스트 주소와 일치하는 경로를 찾는다.
   * 목적지 호스트 주소와 일치하는 경로가 없으면 목적지 네트워크 주소와 일치하는 경로를 찾는다.
   * 일치하는 경로가 없으면 default gateway(0.0.0.0)로 보낸다.

#### (다) 실습
1. 라우팅 테이블 설정 일부(netstat -rn 명령)
   * Dstination : 목적지 호스트 또는 네트워크 주소
   * Gateway : 목적지로 전송하기 위한 Gateway 주소
   * Genmask : 범용 목적의 마스크로 다음과 같은 역할을 한다.
      * 목적지 Host를 식별하기 위한 마스크 : 255.255.255.255
      * 목적지 Network를 식별하기 위한 마스크 : 넷마스크를 의미
      * default gateway를 식별하기 위한 마스크 : 0.0.0.0
   * Flags : 해당 경로에 대한 상태정보 플래그
      * U(route is Up) : 경로가 활성화되어 있음
      * G(use Gateway) : gateway를 사용함
      * H(target is a Host) : 목적지가 호스트를 의미
2. 라우팅 경로 계산 I : 10.0.96.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.96.100)와 첫 번째 행의 Genmask(255.255.255.255) 간에 bit and 연산 수행
   * 연산 결과(10.0.96.100)와 해당 Destination 주소(10.0.96.100)가 일치하므로 해당 경로의 Gateway(10.0.160.1)로 전송
3. 라우팅 경로 계산 II : 10.0.122.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.122.100)와 세 번째 행의 Genmask(255.255.192.0) 간에 bit and 연산 수행
   * 연산 결과(10.0.64.0)와 해당 Destination 주소(10.0.64.0)가 일치하므로 해당 경로의 Gateway(10.0.160.3)로 전송
4. 라우팅 경로 계산 III : 10.0.192.100 목적지로 패킷 전송 시 gateway 주소
   * 목적지 주소(10.0.192.100)와 모든 행의 Genmask 간에 bit and 연산 수행 결과 일치하는 Destination 주소가 없으므로 default gateway(10.0.160.5)로 패킷 전송

### 5) IP Spoofing
#### (가) 개요
1. IP 스푸핑은 IP를 속이고 통신하는 공격으로 1995년 '캐빈 미트닉'이 이를 이용하여 실제 해킹을 시도함으로써 널리 알려진 공격방식이다.
2. 시스템 간의 트러스트 관계를 이용, 트러스트 관계가 맺어진 서버와 클라이언트를 확인한 후 신뢰 관계가 있는 클라이언트를 연결 불가능한 상태로 만들고 공격자가 클라이언트의 IP로 위조하여 서버에 접속하는 공격방식이다.
   * 트러스트 관계 설정은 아이디, 패스워드 기반의 로그인이 아닌 신뢰 관계에 있는 IP를 등록하여 해당 IP로 접근하는 것을 허용해주는 방식이다. 즉 IP 주소로 인증하고 로그인 없이 접속할 수 있도록 해주는 방식이다.
   * 트러스트 설정은 다수의 시스템을 관리하는 관리자의 입장에서 아이디와 패스워드를 관리해야 하는 어려움을 해결하고 접속과정에서 아이디, 패스워드가 스니핑되는 위험성을 차단하지만, IP 스푸핑에는 매우 취약하기 때문에 보안상 사용하지 않는 것을 권장한다.

#### (나) 실습(리눅스 환경)
1. 트러스트 설정
   * 유닉스, 리눅스 시스템에서 트러스트 관계 설정 파일로 /etc/hosts.equiv와 $HOME/.rhost 파일이 있다. hosts.equiv 파일은 시스템 전체에 영향을 주는 파일이고 .rhost 파일은 사용자별로 설정하는 파일이다.
   * 설정 방식은 다음과 같다.
|레코드 형식|의미|
|-|-|
|host_name|해당 호스트(IP 또는 호스트명)의 접근 허용|
|host_name user_name|해당 호스트에 해당 사용자로 접근 허용|
|+|모든 호스트의 접근을 허용(계정은 아이디, 패스워드 인증 필요)|
|+ user_name|모든 호스트의 해당 사용자로 접근 허용|
|-host_name|해당 호스트의 접근 차단|
|host_name -username|해당 호스트에서 해당 사용자만 접근 차단|
|+ @group|모든 호스트에서 해당 group 사용자로 접근 허용|
   * 설정 방식을 보면, 앞에 있는 것이 호스트명, 띄어쓰기 후 나오는 것이 사용자명(계정명)이다. +는 모두 허용한다는 의미이고 -(호스트명 또는 계정명)는 차단한다는 의미이다.
   * 만약 "+ +"로 설정한다면 모든 호스트에 대해서 모든 계정을 신뢰한다는 의미이므로 매우 취약한 설정이다.
2. rlogin 서비스 활성화
   * r 계열 서비스(rlogin, rsh, rexec 등)는 인증 없이 신뢰 관계에 있는 시스템들의 원격 접속을 허용해주는 서비스들이다. rlogin의 경우 telnet과 유사하지만, 인증 없이 접속할 수 있다.
   * xinetd 데몬의 rlogin 서비스를 활성화한 후 xinetd 데몬을 재기동한다. netstat 명령으로 소켓 상태를 확인해보면 513/tcp(login 서비스) 포트가 리슨 상태에 있는 것을 확인할 수 있다.
3. rlogin 클라이언트 명령을 통한 원격 접속
   * 원격 클라이언트에서 "rlogin 서버IP" 명령을 통해 접속하면 아이디, 패스워드 확인 없이 바로 연결되는 것을 확인할 수 있다.
4. 공격자는 신뢰 관계에 있는 클라이언트를 사용 불능 상태로 만든 후 해당 클라이언트의 IP로 위조하여 서버에 접속할 수 있다.

#### (다) 대응책
1. 시스템 간 트러스트 설정을 사용하지 않는다.
2. 반드시 사용해야 할 경우에는 트러스트된 시스템의 MAC 주소를 정적으로 구성하여 단순히 IP만을 위조한 접속을 차단한다.

#### (라) $HOME/.rhosts, hosts.equiv 사용금지(시스템 취약점 분석,평가 항목)
1. 개요
   * r 계열 서비스(rlogin, rsh, rexec 등)를 통한 원격 접속은 보안상 매우 취약하여 서비스 포트가 열려있을 경우 중요 정보 유출 등 침해사고의 원인이 될 수 있다. 따라서 r 계열 서비스를 허용하지 않는다.
   * 만약 불가피하게 사용할 경우에는 트러스트 관계 설정 파일인 $HOME/.rhosts, hosts.equiv에 적절한 보안 조치를 해야 한다.
2. 보안조치
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일 소유자를 root 또는 해당 계정으로 변경한다.
      * (예시) ```chown root /etc/hosts.equiv```
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일 권한을 600 이하로 변경한다.
      * (예시) ```chmod 600 /etc/hosts.equiv```
   * /etc/hosts.equiv 및 $HOME/.rhosts 파일에서 "+"를 제거하고 반드시 필요한 호스트 및 계정만 등록한다.
  
### 6) IPv6 살펴보기
#### (가) 개요
1. IPv6는 IPv4 주소가 고갈되는 문제를 해결하기 위하여 새로운 128비트 체계로 2^128개의 주소를 갖는 인터넷 프로토콜 주소를 말한다.
2. IPv6 주소는 16비트 단위로 구분하며 각 단위는 16진수로 변환되어 클론(:)으로 구분하여 표기한다.
3. 128비트의 IPv6 주소에서 앞의 64비트는 네트워크 주소를 의미하고 뒤의 64비트는 네트워크에 연결된 통신장비 등에 할당되는 인터페이스 주소를 의미한다.

#### (나) IPv6의 장점
|구분|주요 내용|
|-|-|
|확대된 주소 공간|주소길이가 128비트로 증가하여 2^128개의 주소 사용 가능|
|단순해진 헤더 포맷|IPv4 주소 헤더의 불필요한 필드를 제거하여 보다 빠른 처리 가능|
|간편해진 주소 설정 기능|IPv6 프로토콜에 내장된 주소 자동 설정 기능을 이용하여 플러그 앤 플레이 설치가 가능|
|강화된 보안성|IPv6 주소에서는 IPsec 기능을 기본 사항으로 제공|
|개선된 모바일 IP|IPv6 주소 헤더에서 이동성 지원|

#### (다) IPv6 전환 기술
1. 듀얼스택(Dual Stack)
   * IPv4와 IPv6 프로토콜을 동시에 설정하여 통신 상대에 따라 선택적으로 사용할 수 있도록 하는 방식
   * 호스트, 라우터 등에 듀얼스택을 적용하여 IPv4와 IPv6 패킷을 모두 처리할 수 있도록 해준다. 장기적으로 보았을 때 가장 추천되는 방식이다.
2. 터널링(Tunneling)
   * IPv4 네트워크를 경유하여 IPv6 네트워크 간 통신을 위한 방식으로 IPv4 네트워크를 통과하는 가상의 경로를 만들어 통신하는 방식을 말한다.
   * 터널링 기술은 호스트와 라우터에서 IPv6 패킷을 IPv4 패킷으로 캡슐화하여 전송함으로써 캡슐화된 IPv6 패킷이 IPv4 네트워크를 통과하게 하는 기술이다.
3. 주소 변환(Address Translation) 또는 헤더(Header) 변환
   * 주소변환 방식은 IPv4 주소를 IPv6 주소로 변환하거나 IPv6 주소를 IPv4 주소로 변환하여 통신하는 방식을 말한다.
   * 패킷의 앞부분에 변환 헤더를 추가함으로써 주소를 변환하여 송신하고 수신측에서 변환 헤더를 제거하는 방식으로 통신한다.
   * 소수의 IPv6 사이트가 대규모의 IPv4 인터넷에 연결되는 전환의 초기 단계와 소수의 IPv4 사이트가 대규모의 IPv6 인터넷에 연결되는 전환의 마지막 단계에서 사용할 수 있다.

# 7. ICMP 프로토콜
### 1) 개요
1. 3계층의 IP 프로토콜은 신뢰할 수 없는 프로토콜이다. 즉 전송상태에 대한 관리가 이루어지지 않는다. 이러한 IP 프로토콜의 단점을 보완하기 위한 프로토콜 ICMP 프로토콜이다.
2. IP 패킷 전송 중 에러 발생 시 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공해준다. 정리해보면 아래와 같다.
   * Error-Reporting Message 기능 : 전송 중 오류 발생 시 에러 메시지를 생성하여 응답
   * Query Message 기능 : 네트워크 상태를 진단하기 위한 쿼리 요청 및 응답메시지 생성
3. ICMP 메시지는 메시지의 유형을 의미하는 Type 필드와 유형별 세부 내용을 담고 있는 Code 필드로 구성이 된다.

### 2) ICMP 프로토콜 구조
1. Type(8 bits) : ICMP 메시지의 유형/용도
   * 예) Type 3 : Destination Unreachable(목적지 도달 불가)
2. Code(8 bits) : Type의 세부 내용으로 Type과 Code가 조합되어 ICMP 메시지의 목적과 용도를 나타낸다.(Code가 없는 Type도 존재)
   * 예) Type 3의 Code 3 : Port Unreachable(UDP 포트가 열려있지 않음)
3. Checksum(16 bits) : ICMP 메시지 오류를 검사하기 위한 값
4. Rest of the header : Type과 Code에 따라 추가되는 헤더
5. Data section : 데이터가 위치하는 영역

### 3) 주요 ICMP Error-Reporting 메시지
#### (가) Destination Unreachable(Type 3)
1. 해당 목적지에 도달할 수 없음을 의미한다.
2. 목적지 도달 불가 사유에 따라 다양한 Code(상세 유형)로 구성이 되어 있다. 주요 Code를 살펴보면 다음과 같다.
   * Code 1(Hosts Unreachable) : 최종 단계의 라우터가 목적지 호스트로 패킷 전송에 실패한 경우
   * Code 2(Protocol Unreachable) : 목적지 호스트에서 특정 프로토콜을 사용할 수 없는 경우
   * Code 3(Port Unreachable) : 목적지 호스트에 해당 UDP 포트가 열려있지 않은 경우, TCP의 경우에는 포트가 열려있지 않으면 TCP RST 패킷을 반환한다.
   * Code 4(Fragmentation needed and don\`t fragment was set) : IP 패킷의 단편화가 필요하지만, IP 헤더의 Don\`t fragment was set) : IP 패킷의 단편화가 필요하지만, IP 헤더의 Don\`t fragment(DF) 플래그가 설정되어 단편화할 수 없는 경우 라우터에 의해 반환된다.

#### (나) Redirection(Type 5)
1. 라우팅 경로가 잘못되어 새로운 경로를 이전 경유지 또는 호스트에게 알려주는 메시지이다.
2. ICMP Redirect 공격 시 이용하는 메시지이다.

#### (다) Time Exceeded(Type 11)
1. 타임아웃이 발생하여 IP 패킷이 폐기되었음을 알리는 메시지이다. 타임아웃 사유는 Code를 통해 알 수 있다.
   * Code 0(Time To Live exceeded in Transit) : IP 패킷이 최종 목적지에 도달하기 전에 TTL 값이 0이 되어 해당 패킷이 폐기되었음을 알리는 메시지이다.
   * Code 1(Fragment reassembly time exceeded) : IP 패킷이 재조합 과정에서 타임아웃이 발생하여 해당 IP 데이터그램이 모두 폐기되었음을 알리는 메시지이다. 일반적으로 IP 데이터그램의 일부 단편이 전송과정에서 손실될 경우 재조합에 실패하여 발생한다.
  
### 4) 주요 ICMP Query 메시지
#### (가) Echo Request(Type 8) and Reply(Type 0)
1. ping 유틸리티 프로그램에 사용되는 메시지로 종단노드 간에 네트워크 및 호스트 상태진단을 목적으로 사용한다.
2. 별도의 Code는 없으며 이외의 쿼리 타입들은 거의 사용되지 않는다.
3. Echo Request 메시지 캡처 예
   * ICMP 기본 헤더 이외에 전송한 Echo Requestg 메시지를 식별하기 위한 Identifier(ID) 필드와 메시지 순번을 식별하기 위한 Sequence number 필드가 추가된 것을 볼 수 있다.
   * TTL 값이 128(윈도우 기본 TTL) 이하인 것으로 보아 윈도우 시스템에서 보낸 메시지임을 추측할 수 있다.
4. Echo Reply 메시지 캡처 예
   * Echo Request 메시지 전송 시 설정한 id와 sequence number가 동일하게 설정되어 있는 것을 볼 수 있다.
   * TTL 값이 64(리눅스 TTL) 이하인 것으로 보아 리눅스 시스템에서 보낸 메시지임을 추측할 수 있다.

### 5) ICMP 리다이렉트 공격
#### (가) 개요
1. ICMP Redirect 공격이란 ICMP Redirection 메시지(Type 5)를 이용하여 패킷 경로를 악의적으로 재설정하는 공격을 말한다. ICMP Redirection 메시지를 수신한 호스트는 자신의 라우팅 테이블에 특정 목적지로 나가는 gateway 주소를 변경하는데 공격자는 이를 이용하여 자신이 원하는 형태의 ICMP Redirection 메시지를 만들어 특정 목적지로 가는 패킷을 공격자로 향하도록 한다.
2. ARP Redirect와 ICMP Redirect 공격의 차이점을 살펴보면 ARP Redirect는 희생자의 ARP Cache Table정보를 변조하여 스니핑하는 것이고, ICMP Redirect는 희생자의 라우팅 테이블을 변조하여 스니핑 한다는 차이점이 있다.

#### (나) 공격결과
1. ICMP Redirect 공격 시 희생자 PC 패킷 캡처
   * 공격자에 의해 조작된 ICMP Redirection 메시지(Type : 5, Code : 1)가 희생자에게 전달되고 있다. ICMP Redirection 메시지는 게이트웨이/라우터만이 보낼 수 있으므로 공격자는 출발지 IP를 희생자의 게이트웨이 주소로 위조하고 있다.
   * ICMP Redirection 메시지를 분석해보면, 목적지 주소에 대한 gateway 주소를 공격자의 주소로 조작한 것을 알 수 있다.
2. 공격 후 희생자PC의 라우팅 테이블 정보
   * 희생자PC의 라우팅 테이블 정보를 살펴보면 8.8.8.8 목적지의 경로가 정상적인 gateway 주소가 아닌 공격자의 주소로 변경된 것을 확인할 수 있다.
   * 따라서 희생자PC에서 8.8.8.8 목적지로 패킷 전송 시 공격자 PC로 패킷이 전달되어 공격자는 스니핑이 가능하게 된다

#### (다) 대응방법
1. ICMP Redirection 메시지에 의해 라우팅 테이블이 변경되지 않도록 ICMP Redirect 옵션을 해제한다.
2. 현재 대부분의 OS에서 보안상의 이유로 ICMP Redirect 옵션을 기본적으로 해제하고 있다.
   * 리눅스 커널 파라미터 중 ICMP Redirect 설정인 accept_redirects를 0(허용안함)로 설정한다.

# 8. TCP 프로토콜
### 1) 개요
#### (가) Connection Oriented Protocol (연결 지향 프로토콜)
1. 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정해서 통신하는 방식으로 가상의 연결통로를 가상회선이라 한다.
   * 가상회선방식 : 물리적으로 전용회선이 연결되어 있는 것처럼 논리적으로 동작하는 방식을 말한다.
2. 논리적인 연결통로를 통해 데이터를 주고받음으로써 데이터의 전송순서를 보장해준다. 이를 순서제어라고 한다.
3. 스트림 기반의 전송방식을 사용한다. 즉 데이터를 정해진 크기로 전송하는 것이 아니라 임의의 크기로 나누어 연속해서 전송하는 방식을 사용한다.

#### (나) Reliable Protocol (신뢰할 수 있는 프로토콜)
1. 흐름제어(Flow Control) 수행
   * 흐름제어란 **상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송하는 것**을 말한다.
   * 흐름제어를 위해 슬라이딩 윈도우 제어방식을 사용한다. 이는 상대방이 수신 가능한 크기 내에서 데이터를 연속해서 전송하는 방식으로 세그먼트 전송 시마다 수신확인응답(ACK)을 수신한 후 전송하게 되면 왕복시간(RTT: Round Trip Time)이 길 경우 단위 시간당 데이터 전송량이 매우 떨어지므로 효율적으로 전송하기 위해 상대방이 받을 수 있는 범위 내에서 연속적으로 전송한다.
2. 오류제어(Error Control) 수행
   * 오류제어란 **데이터의 오류나 누락없이 안전한 전송을 보장해주는 것**을 말한다.
   * 오류 또는 누락 발생 시 재전송을 수행하여 이를 보정한다.
3. 혼잡제어(Congestion Control) 수행
   * **혼잡제어란 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어하는 것**을 말한다.
   * 혼잡 정도에 대한 판단기준은 데이터의 손실 발생 유무로 판단한다. 전송한 데이터에 누락이 발생하면 네트워크가 혼잡한 상태로 판단하여 전송량을 조절한다.

### 2) TCP 프로토콜 구조
1. Source Port(16 bits) : 출발지(송신) 포트 번호
2. Destination Port(16 bits) : 목적지(수신) 포트 번호
3. Sequence Number(32 bits) : 송신 데이터 순서번호
   * 송신 시 전송하는 데이터의 시작 바이트 순번을 담는다. 바이트 순번은 전송하는 데이터의 바이트 단위로 부여하는 연속된 번호를 의미한다.
   * 연결설정 단계에서 초기 순서번호(ISN: Initial Sequence Number)를 상호 간에 주고받는다. 초기 순서번호는 0부터 시작하는 것이 아니라 임의의 수를 할당해서 사용한다.
4. Acknowledgment Number(32 bits) : 상대방이 다음에 전송할 순서번호
   * 수신 확인 응답(ACK)과 함께 해당 필드에 상대방이 다음에 전송할 순서번호를 담아서 보낸다.
5. HLEN(4 bits) : 헤더의 길이
   * 4 bytes 단위로 표시(20~60 bytes)하며 헤더는 기본 헤더 20 bytes와 옵션 헤더 최대 40bytes로 구성된다.
6. Reserved(6 bits) : 예약(사용하지 않음)
7. Control Flags(6 bits)
   * URG(Urgent pointer is valid) : 긴급 데이터(OOB: Out Of Band) 설정
   * ACK(Acknowledgment is valid) : 수신 확인 응답(ACK) 설정
   * PSH(Request for push) : 송수신 버퍼에 있는 데이터를 즉시 처리
   * RST(Reset the connection) : 연결 중단(강제 종료)
   * SYN(Synchronize sequence numbers) : 연결 설정
   * FIN(Terminate the connection) : 연결 종료(정상 종료)
8. Windows Size(16 bits)
   * 수신 측에서 송신 측에 보내는 Receiver Windows size로 수신버퍼의 여유 공간 크기를 의미한다. 송신 측에서는 상대방의 여유 공간 크기를 통해서 흐름제어를 수행할 수 있다.
   * 따라서 **송신 측에서는 상대방의 윈도우 크기 범위 내에서 수신 측의 수신 확인 응답을 기다리지 않고 연속적으로 전송할 수 있는데 이를 슬라이딩 윈도우 제어방식**이라 한다.
9. Checksum(16 bits)
   * 헤더를 포함한 전체 세그먼트에 대한 오류를 검사하기 위한 필드
10. Urgent Pointer(16 bits)
   * 세그먼트가 긴급 데이터(URG 플래그 설정)를 포함하고 있는 경우에 사용되는 필드로 긴급 데이터의 위치값을 담고 있다.

* well-known port(0 ~ 1023) : 잘 알려진 서비스에 예약된 포트
* registered port(1024 ~ 49151) : 제조사가 IANA에 용도를 등록해서 사용하는 포트
* dynamic port(49152 ~ 65535) : 동적으로 사용하는 포트로 일반적으로 클라이언트 포트로 사용
* privileged port(0 ~ 1023) : 관리자 권한으로 사용 가능한 포트
* unprivileged port(1024 ~ 65535) : 일반 사용자 권한으로 사용 가능한 포트

### 3) TCP 분할과 재조합
1. MSS(Maximum Segment Size)
   * TCP 세그먼트 데이터부의 최대 바이트 수를 의미하며 연결 설정 과정에서 상호 간에 MSS 정보를 주고받는다.
   * MSS는 Frame의 MTU에 영향을 받는다. MTU 크기에서 IP 헤더(20byte)와 TCP 헤더(기본 20byte)를 빼면 MSS 크기를 알 수 있다.
2. Application 계층에서 전달된 데이터는 TCP 계층에서 MSS 크기에 따라 분할이 발생한다. 분할된 세그먼트는 수신 측에서 재조합되어 Application 계층으로 전달된다.

### 4) 연결 설정 과정(3-Way Handshake)
1. 첫 번째 단계
   * 최초 클라이언트는 서버와 연결설정을 위한 연결 요청 패킷을 보낸다. 연결 요청을 위해 능동적으로 포트를 열고 있는 상태를 "Active Open", 연결 요청을 수용하기 위해 수동적으로 포트를 열고 있는 상태를 "Passive Open"이라 한다.
   * SYN은 synchronize(동기화)의 줄임말로 상호 간에 순서번호를 동기화하자는 의미이다. 상호 간의 초기 순서번호(ISN)는 0부터가 아닌 랜덤한 값으로 시작한다.
   * 최초 SYN 패킷을 보낸 TCP 상태를 "SYN_SENT" 상태라 한다.
2. 두 번째 단계
   * 클라이언트의 연결 요청(SYN 패킷)에 대한 수신 확인 응답(ACK)과 함께 서버에서 클라이언트로 연결 요청을 보내 상호 간에 연결 요청을 수행한다.
   * 수신 확인 응답을 하게 되면 반드시 Acknowledgment Number를 설정하는데 그 의미는 상대방이 다음에 보낼 패킷의 순서번호를 의미한다. 위 예를 보면 Ack.Num:1001로 설정되어 있는데 그 의미는 1000번까지 수신 완료했고 1001번을 보내라는 의미가 된다.
3. 세 번째 단계
   * server의 연결 요청(SYN 패킷)에 대해 수신 확인 응답(ACK)을 전송한 후 최종적으로 연결설정이 완료된다.
   * 연결설정이 완료되면 TCP 상태는 "ESTABLISHED" 상태가 된다.

### 5) 데이터 송수신 과정
#### (가) 재전송 과정
1. TCP는 모든 세그먼트 전송 시마다 재전송 타이머가 동작한다. 재전송 타임아웃(RTO: Retransmission Time Out)동안 상대방으로부터 ACK 응답이 없으면 송신자는 해당 패킷이 누락된 것으로 판단하여 재전송을 수행한다.
2. 위 예를 보면, 클라이언트가 Data-B 전송 후 재전송 타임아웃이 발생하여 Data-B를 다시 전송하고 있다.
3. 재전송은 일정 시간/횟수 동안 발생하며 더 이상 상대방으로부터 ACK 응답이 없으면 연결을 종료한다.
4. 혼잡제어 관점에서는 재전송 타이머 만료에 따른 재전송이 발생하는 상황은 매우 혼잡한 상태로 판단한다.

#### (나) 빠른 재전송 과정
1. TCP는 수신 측이 기대했던 순서번호가 아닌 그 이후 순서번호의 세그먼트를 수신하면 즉시 기대하는 순서번호의 세그먼트를 요청하는 ACK 패킷을 전송한다.
2. 위 예를 보면, 클라이언트가 전송한 세그먼트 중 B 세그먼트의 손실이 발생했으며 그 이후 순서번호를 가진 C, D, E 세그먼트가 도착할 때마다 서버는 B 세그먼트를 요청하는 ACK 패킷을 클라이언트에 즉시 전송하고 있다.
3. 클라이언트는 중복 ACK가 두 번 발생할 때까지는 일시적으로 서버에 전달한 세그먼트의 순서가 맞지 않는 상태로 판단하다가 세 번 발생하면 해당 세그먼트가 누락된 것으로 판단하여 재전송을 수행한다. **재전송 타임아웃 발생 이전에 중복 ACK가 세 번 발생하면 즉시 재전송을 수행하므로 이를 빠른 재전송**이라 한다.
4. 혼잡제어 관점에서는 중복 ACK 3회 발생에 따른 빠른 재전송이 발생하는 상황은 재전송 타이머 만료에 따른 재전송에 비해 덜 혼잡한 상태로 판단한다. 이는 일부 세그먼트의 누락은 발생했지만, 나머지 세그먼트는 정상적으로 수신되었기 때문에 덜 혼잡한 상태로 본다.

### 6) 연결 종료 과정(4-Way Handshake)
#### (가) 연결 종료 단계
1. 첫 번째 단계
   * 클라이언트는 서버와의 연결설정을 종료하기 위한 연결 종료 패킷(FIN+ACK 패킷)을 보낸다. 능동적인 연결 종료 수행을 "Active Close", 수동적으로 수행하는 것을 "Passive Close"라 한다.
2. 두 번째/세 번째 단계
   * 클라이언트의 연결 종료 요청에 대한 수신 확인 응답(ACK)을 보낸다.
   * 서버는 해당 서버 애플리케이션에서 TCP 연결 종료를 할 때까지 대기한 후 종료되면 클라이언트에 연결 종료 패킷(FIN+ACK 패킷)을 보낸다.
3. 네 번째 단계
   * 서버의 연결 종료 패킷을 수신한 클라이언트는 즉시 연결을 종료하는 것이 아니라 서버에 마지막 ACK를 보낸 후 2MSL(Maximum Segment Lifetime) 시간 동안 대기한다.
   * 2MSL 동안(통상 1~4분) 대기하는 이유는 마지막 ACK 응답이 안전하게 상대방에게 전송됨을 보장해주기 위한 것으로 만약 서버가 마지막 ACK를 수신하지 못했다면 FIN+ACK 재전송이 발생할 것이고 이를 처리하기 위해 일정 시간 대기한다.

#### (나) 연결 종료 단계의 TCP 상태
|상태|설명|
|:-:|:-|
|FIN_WAIT_1|첫 번쨰 FIN+ACK 패킷에 대한 ACK를 대기하는 상태|
|FIN_WAIT_2|첫 번쨰 FIN+ACK 패킷에 대한 ACK 수신 후 두 번째 FIN+ACK 패킷을 수신할 때까지 대기하는 상태|
|TIME_WAIT|마지막 ACK 전송 후 2MSL 동안 대기하는 상태|
|CLOSE_WAIT|상대방의 첫 번째 FIN+ACK 패킷에 대한 ACK 응답 후 두 번째 FIN+ACK 패킷을 전송할 때까지 대기하는 상태|
|LAST_ACK|두 번째 FIN+ACK 패킷 전송 후 마지막 ACK를 대기하는 상태|
|CLOSE|종료된 상태|

### 7) 연결 요청 거부(강제 종료)
1. 클라이언트 TCP가 연결을 위해 SYN 요청을 전송했으나 서버에 해당 포트가 준비되어 있지 않으면 "RST+ACK" 패킷을 클라이언트에 전송하여 연결 쵸엉을 거부하게 된다.
2. "RST+ACK"를 수신한 클라이언트 TCP는 즉시 종료(CLOSED) 상태가 된다.

### 8) 연결 중단(abort)
1. 연결 상태에 있는 클라이언트가 연결을 즉시 중단해야 할 필요가 있을 경우 "RST+ACK" 또는 "RST" 패킷을 서버에 전송할 수 있다. TCP 표준(RFC 793)에 따른 차이점은 다음과 같다.
   * RST 플래그만 설정하는 경우 : 상대방으로부터 수신한 세그먼트에 Acknowlegment Number 필드가 설정되어 있는 경우 RST 플래그와 Sequence NUmber 필드를 설정하여 응답한다.
   * RST+ACK 플래그를 설정하는 경우 : 상대방으로부터 수신한 세그먼트에 Acknowlegment Number 필드가 설정되어 있지 않은 경우 Sequence NUmber 필드를 0으로 설정하고 Acknowlegment Number 필드를 수신한 세그먼트의 Sequence Number와 세그먼트 길이의 합으로 설정하여 응답한다.
2. "RST+ACK" 또는 "RST" 패킷을 수신한 서버 TCP는 즉시 종료(CLOSED) 상태가 된다.

### 9) TCP 세션 하이재킹
#### (가) 개요
1. 세계적으로 유명한 해커 "케빈 미트닉"이 사용했던 공격 방법의 하나로 TCP의 세션 관리 취약점을 이용한 공격이다.
2. TCP는 연결설정 과정을 통해 상호 간에 세션을 생성한 후 다음 식별자를 통해 상호 간에 인식하게 된다.
   * 출발지 IP와 Port,목적지 IP와 Port
   * Sequence Number와 Acknowledgment Number
3. TCP 세션 하이재킹은 위와 같은 세션 식별정보를 공격자가 위조하여 세션을 탈취하는 공격이다. 즉 **공격자는 정상적인 사용자의 출발지 IP와 Port로 위조하고 sequence Number를 예측하여 세션을 탈취**하게 된다.

#### (나) 실습
1. 실습 환경
   * Telnet Client : 192.168.159.134
   * Telnet Server : 192.168.159.141
   * 공격 툴 : Hunt
2. 정상적으로 클라이언트와 서버가 통신하고 있는 상황
   * 공격자는 클라이언트와 서버 사이에서 ARP 스푸핑을 통해 둘 사이의 TCP 식별정보를 탈취하기 위한 스니핑을 진행한다.
3. 패킷을 스니핑하던 공격자는 정상적인 클라이언트의 IP 주소로 위장한 TCP 패킷에 정상적인 클라이언트의 TCP 식별정보를 담아서 서버로 전달한다.
4. 서버는 공격자의 위조된 패킷에 대해 정상 응답을 준다. 해당 응답은 공격자뿐만 아니라 정상 클라이언트에게도 전달되고 클라이언트 입장에서는 데이터를 보내지 않았는데 Acknowledgment Number가 증가한 응답을 받게 되는 상황이 발생한다.
5. 잘못된 응답을 받은 정상 클라이언트는 이를 교정하기 위한 ACK를 보낸다.
6. 서버 입장에서는 정상 클라이언트가 보낸 잘못된 ACK 패킷을 다시 교정하기 위해 ACK 메시지를 보내게 된다. 이러한 과정이 반복적으로 대량 발생하게 되는데 이를 "ACK STORM"이라 한다.
   * 공격자에 의해서 해당 세션의 Sequence Number와 Acknowlegment Number가 조작된 것이기 때문에 정상 클라이언트와 서버 간에는 아무리 교정을 위한 ACK를 보낸다고 해도 이를 해결할 수 없다.
7. 공격자는 최종적으로 정상 클라이언트에게 RST(강제 종료) 메시지를 전달하여 연결을 강제 종료하고 자신은 서버와의 세션을 유지한다.

# 9. UDP 프로토콜
### 1) 개요
#### (가) Connectionless Protocol (비연결형 프로토콜)
1. 논리적인 연결설정 과정이 없으므로 데이터그램 전송 시마다 주소정보를 설정해서 전송한다.
2. 데이터의 순차적 전송을 보장해주지 않는다.
3. 데이터그램 기반의 전송방식을 사용한다. 즉 데이터를 정해진크기로 전송하는 방식을 사용한다.

#### (나) Unreliable Protocol (신뢰할 수 없는 프로토콜)
1. 신뢰성 있는 TCP와는 달리 흐름제어, 오류제어, 혼잡제어 등을 수행하지 않는다.
2. 실질적으로 IP 기반에 포트 정보를 이용하여 상위 송수신 애플리케이션(IP/Port를 통한)을 식별해주는 역할 정도만 수행한다.

#### (다) UDP 프로토콜의 장점
1. 단순하고 가벼운 프로토콜로 전송속도가 빠르다.
   * TCP의 경우 내부 처리 메커니즘에 의해 프로토콜이 복잡하고 무거운 반면에 UDP의 경우에는 상대적으로 가볍고 단순한 프로토콜로 빠른 전송이 장점이다.
2. 비신뢰적인 특성으로 인해 대량 데이터의 송수신은 부적절하며 주로 한 번의 패킷 송수신으로 완료되는 서비스에 많이 사용된다.
   * 예) DNS 서비스(53/udp), NTP 서비스(123/udp), DHCP 서비스(67,68/udp) 등

### 2) UDP 프로토콜 구조
1. Source Port(16 bits) : 출발지(송신) 포트 번호
2. Destination Port(16 bits) : 목적지(수신) 포트 번호
3. Total Length(16 bits) : 헤더와 데이터부를 포함한 전체 길이
4. Checksum(16 bits) : 전체 데이터그램에 대한 오류를 검사하기 위한 필드

# 10. 네트워크 관리 명령어
## (1) ping 명령어
### 1) 개요
1. 종단 노드 간에 네트워크 상태를 관리하기 위한 명령어
2. Target 시스템에 대한 접근성, 해당 구간에 대한 네트워크 속도 및 품질(손실률)을 검사하기 위한 명령어
3. ICMP Echo Request(Type\:8)와 ICMP Echo Reply(Type\:0) 메시지 이용

### 2) 실습
1. 윈도우 ping 명령 테스트

![image](https://github.com/zzzangmans1/boangisa_practice/assets/52357235/1c7627cc-bf1b-458b-9954-24d2241294f3)
   * -n : 패킷 전송 횟수 설정(default 4회)
   * -l : 패킷 크기(bytes) 설정(default 32 bytes)

2. 리눅스 ping 명령 테스트
   * -c : 패킷 전송 횟수 설정(default 무한)
   * -s : 패킷 크기 bytes 설정(default 56 bytes)

## (2) traceroute/tracert 명령
### 1) 개요
1. 종단 노드 사이에 있는 여러 중계 노드(L3장비/라우터) 각 구간에 대한 네트워크 상태를 관리하기 위한 명령어로 네트워크의 라우팅 문제점을 찾아내는 목적으로 많이 사용한다.
   * 최종 목적지 노드에 도달하는데 경유하는 중계 노드(L3장비/라우터)의 개수, IP 주소, 응답시간 등을 파악할 수 있다.
2. 각 구간에 대한 접근성 및 네트워크 속도를 검사
3. 유닉스/리눅스의 경우 traceroute 명령어를 사용하고 윈도우의 경우 tracert 명령어를 사용한다.

### 2) 유닉스/리눅스 traceroute 동작방식
1. 각 중계 노드(L3장비/라우터) 구간에 대한 상태를 측정하기 위해 IP의 TTL 필드를 1로 설정한 UDP 패킷을 보낸다.
   * 라우터는 패킷의 생존 기간을 계산하기 위해 패킷을 수신하면 TTL 값을 1 감소 시킨 후 그 결과 0이 되면 TTL 초과로 판단하여 해당 패킷을 폐기한 후 ICMP Time Exceeded(Type 11) 패킷을 최초 출발지로 보낸다.
   * 따라서 TTL값을 1로 설정하면 첫 번째 라우터에서 패킷이 폐기되고 ICMP 응답이 오기 때문에 이를 이용하여 출발지 호스트와 첫 번째 라우터 간의 네트워크 상태를 판단한다.
   * 보안상의 이유로 라우터에서 ICMP 응답을 주지 않는 경우가 많다. traceroute 명령 수행 시 응답시간이 \*로 표시되는 경우가 응답이 없는 경우로 보안상의 이유이거나 실제 해당 구간에 문제가 발생한 경우로 볼 수 있다.
2. TTL 값을 1씩 증가시키면서 UDP 패킷을 지속적으로 전송하여 다음 중계 구간에 대한 네트워크 상태를 판단한다.
3. **최종 목적지에 UDP 패킷이 도달하면 해당 UDP 포트(33434/udp 이상 포트 사용)가 닫혀있으므로 ICMP Destination Unreachable(Type 3) 패킷이 반환되며 최초 출발지 호스트는 이 정보를 이용하여 최종 목적지 호스트에 도달했음을 알 수 있게** 된다.

### 3) 윈도우 tracert 동작방식
1. 각 중계 노드(L3장비/라우터) 구간에 대한 상태를 측정하기 위해 IP의 TTL 필드를 1로 설정한 ICMP Echo Request(Type 8) 패킷을 보낸다.
   * 라우터는 패킷의 생존 기간을 계산하기 위해 패킷을 수신하면 TTL 값을 1 감소 시킨 후 그 결과 0이 되면 TTL 초과로 판단하여 해당 패킷을 폐기한 후 ICMP Time Exceeded(Type 11) 메시지를 최초 출발지로 보낸다.
   * 따라서 TTL 값을 1로 설정하면 첫 번째 라우터에서 패킷이 폐기되고 ICMP 응답이 오기 때문에 이를 이용하여 출발지 호스트와 첫 번째 라우터 간의 네트워크 상태를 판단한다.
   * 보안상의 이유로 라우터에서 ICMP 응답을 주지 않는 경우가 많다. tracert 명령 수행 시 응답시간이 * 로 표시되는 경우가 응답이 없는 경우로 보안상의 이유이거나 실제 해당 구간에 문제가 발생한 것으로 볼 수 있다.
2. TTL 값을 1씩 증가시키면서 ICMP 패킷을 지속적으로 전송하여 다음 중계 구간에 대한 네트워크 상태를 판단한다.
3. 최종 목적지에 ICMP Echo Request(Type 8) 패킷이 도달하면 ICMP Echo Reply(Type 0) 패킷이 반환되며 최초 출발지 호스트는 이 정보를 이용하여 최종 목적지 호스트에 도달했음을 알 수 있게 된다.

### 4) 실습
1. 윈도우 tracert 테스트
   * 기본 옵션으로 실행 시 구간별로 3번의 ICMP 패킷을 전송하고 응답시간을 보여준다.
   * "*"는 지정한 시간 내에(default 4초) 응답이 없음을 의미한다.
  
### 5) 윈도우 리눅스 차이점
* 리눅스는 최종 목적지에 도달하여 33434/udp 포트가 닫혀 있으므로 ICMP Destination unreachable(Type 3) 이 반환되어 목적지에 도달한 것을 알 수 있고 윈도우는 최종 목적지에 도달하면 ICMP Echo Reply(Type 0) 응답이 와서 목적지에 도달한 것을 알 수 있다.

## (3) netstat 명령
### 1) 개요
1. 시스템의 네트워크 관련 다양한 상태정보를 관리할 수 있는 명령어
2. 주요 제공정보는 다음과 같다.
   * 옵션 없음 : 모든 연결된(ESTABLISHED) 소켓 상태정보
   * -a 옵션 : 모든 소켓 상태정보
   * -i 옵션 : 네트워크 인터페이스 정보
   * -r 옵션 : 시스템 라우팅 테이블 정보
   * -s 옵션 : 프로토콜별(TCP, UDP, ICMP, IP 등) 통계정보
  
### 2) 실습(Linux)
1. 소켓 상태정보 확인하기
   * netstat -t : "t" 옵션은 TCP 소켓을 출력하라는 옵션이다. 따라서 TCP 소켓 중 연결된(ESTABLISHED) 소켓만을 출력한다. ("u" 옵션은 UDP를 의미)
   * 각 필드의 의미를 살펴보면 다음과 같다.

|필드|설명|
|-|-|
|Proto|사용한 프로토콜의 종류|
|Recv-Q|원격 호스트로부터 수신 버퍼에 저장한 데이터의 크기|
|Send-Q|원격 호스트로 전송하기 위해 송신 버퍼에 저장한 데이터의 크기|
|Local Address|로컬 호스트의 소켓 주소(IP : 포트)|
|Foreign Address|원격 호스트의 소켓 주소(IP : 포트)|
|State|소켓 상태|

   * netstat -at : TCP 소켓을 모두 출력한다. 모두 출력한다는 것은 연결된 상태(ESTABLISHED)뿐만이 아니라 연결 대기(LISTEN), 연결설정 및 종료 중인 소켓도 모두 출력한다는 의미이다.
   * netstat -ant : "n" 옵션은 네트워크 주소를 숫자 형식으로 출력하는 옵션이다. 따라서 숫자 형식의 네트워크 주소로 연결된 소켓과 연결 요청 대기 중인 TCP 소켓을 모두 출력한다.
   * netstat -antp : "p" 옵션은 해당 소켓의 프로세스명/pid 정보를 출력하는 옵션이다. TCP 소켓을 열고 있는 프로세스를 확인하는 데 유용하게 사용한다.
2. 네트워크 인터페이스 정보 확인하기
   * ```netstat -i```
   * RX-OK/RX-ERR/RX-DRP/RX-OVR : RX는 수신한(Received) 패킷 수를 의미한다. OK는 오류 없이 수신한 패킷 수, ERR는 오류가 발생한 수신 패킷 수, DRP는 폐기(Drop)된 수신 패킷 수, OVR은 과도한 양의 수신 패킷에 의한 오버플로우 발생으로 폐기된 패킷 수를 의미한다.
   * TX-OK/TX-ERR/TX-DRP/TX-OVR : TX는 전송한(transmitted) 패킷 수를 의미한다. OK는 오류 없이 전송한 패킷 수, ERR는 오류가 발생한 전송 패킷 수, DRP는 폐기(DROP)된 전송 패킷 수, OVR은 과도한 양의 전송 패킷에 의한 오버플로우 발생으로 폐기 수를 의미한다.
3. 시스템 라우팅 테이블 정보 확인하기
   * ```netstat -rn```
4. 프로토콜별 통계정보
   * ```netstat -s```
   * 시스템이 부팅된 이후부터 현재까지 누적된 프로토콜 통계정보를 출력한다.

## (4) ifconfig 명령(리눅스/유닉스)
### 1) 개요
1. 유닉스/리눅스 시스템에서 네트워크 인터페이스 설정 정보를 조회하거나 IP 주소나 서브넷 마스크 등의 설정을 변경할 때 사용한다.

### 2) 실습 I (Linux)
1. eth1 Link encap:Ethernet HWaddr 00\:0C\:29\:0C\:A6\:C6
   * eth1 이더넷 인터페이스가 연결되어 있고 MAC 주소 정보(HWaddr)를 보여주고 있다.
2. inet addr:192.168.197.133 Bcast:192.168.197.255 Mask:255.255.255.0
   * IP 주소(inet addr), 브로드캐스트 주소(Bcast), 넷마스크(Mast) 값을 보여주고 있다.
3. UP BROADCAST RUNNING MULTICAST MTU:1500 Metric\:1
   * UP은 현재 인터페이스가 활성화 상태임을 의미하며, BROADCAST는 인터페이스가 브로드캐스트를 지원하고 있음을 의미한다.
   * RUNNING은 인터페이스가 실행 중임을 나타내고 MULTICAST는 멀티캐스트를 지원하고 있음을 나타낸다.
   * MTU는 1500 bytes(이더넷)이고 메트릭 값은 1이다. 메트릭은 라우팅 경로의 효율성(우선순위)을 나타내는 값으로 이 값이 클수록 비용이 크다.(우선순위가 낮아진다)
  
### 3) 실습 II (Linux)
1. 인터페이스(eth1)에 Promiscuous 모드 설정
   * ```ifconfg eth1 promisc```
   * 인터페이스가 promiscuous 모드로 동작하게 되면 "PROMISC"로 표시
   * /var/log/messages 로그 파일에 eth1 인터페이스가 promiscuous mode로 전환되었음을 보여주고 있다.
   * 외부 침입자에 의한 불법적인 스니핑 목적의 모드 전환이 발생할 수 있으므로 주의가 필요하다.
2. 인터페이스(eth1)에 promiscuous 모드 해제
   * ```ifconfig eth1 -promisc```
   * ifconfig "인터페이스 명" -promisc 명령을 통해 해당 인터페이스에 설정된 promiscuous mode 설정을 해제할 수 있다.
   * /var/log/messages 로그 파일에 eth1 인터페이스가 promiscuous mode에서 해제되었음을 보여주고 있다.

# 11. 포트스캐닝
## (1) 개요
1. 포트 스캐닝은 공격자가 침입 전 대상 호스트에 어떤 포트(서비스)가 활성화되어 있는지 확인하는 기법으로 침입 전 취약점을 분석하기 위한 사전 작업 중 하나이다.
2. 포트 스캐닝을 통해 대상 호스트의 동작 여부와 제공하는 서비스 등을 확인할 수 있다. 일반적으로 포트 스캐닝을 수행하기 위한 포트 스캐너로 nmap을 많이 사용한다.

## (2) nmap 포트 스캐너 사용법
|문법|nmap [scan type] [options] <target>
|:-:|:-|
|Scan Type|-sS TCP SYN(Half-Open) Scan : TCP 포트 오픈 여부를 확인하는 스캔 </br>-sT TCP Connect(Open) Scan : TCP 포트 오픈 여부를 확인하는 스캔 </br>-sU UDP Scan : UDP 포트 오픈 여부를 확인하는 스캔 </br>-sF TCP FIN Scan : TCP FIN 제어비트 패킷을 이용한 스캔 </br>-sX TCP Xmas Scan : TCP FIN, PSH, URG 제어비트를 조합한 패킷을 이용한 스캔 </br>-sN TCP NULL Scan : TCP 제어비트 설정이 없는 NULL 패킷을 이용한 스캔 </br>-sA TCP ACK Scan : 방화벽 룰셋(필터링 정책)을 확인하기 위한 스캔 </br>-sP Ping(icmp/icmp echo) Scan : Ping을 이용한 호스트 활성화 여부를 확인하는 스캔 </br>-D Decoy Scan : 실제 스캐너 주소 외에도 다양한 주소로 위조하여 스캔하는 방식 </br>-b TCP FTP Bounce Scan, -b \<FTP bounce Proxy\>|
|Port Options|-p 22 : 22번 포트 스캔 </br>-p <service> : 특정 서비스명(e.g. ssh)으로 포트 스캔 </br>-p 20,25,80 : 20,25,80 포트 스캔, 여러 포트 스캔 </br>-p 1-1023 : 1-1023번 포트 스캔, 일정 범위로 포트 스캔 </br>-pT:21,23,110,U:53 : TCP 21,23,110번 포트와 UDP 53번 포트를 분리하여 포트 스캔|
|Output Options|-v : 상세 내역 출력 </br>-d : Debugging </br>-oN <file> : 결과를 일반 파일 형식으로 출력 </br>-oX <file> : 결과를 XML 파일 형식으로 출력 </br>-oG <file> : 결과를 Grepable(grep, awk등으로 분석하기 편한) 파일 형식으로 출력 </br>-oA <Directory> : 일반(.nmap), XML(.xml), Grepable(.gnmap) 파일로 출력|
|기타 Options|-O : 영문 대문자 O, 대상 호스트의 운영체제 정보를 출력 </br>-F : 빠른 네트워크 스캐닝 </br>-T0 ~ T5 : T0 아주느리게 ~ T5 아주 빠르게|
|Target|-hostname 지정 * ex) www.algisa.com </br> IP address, Network 등 가능 </br> * ex) 192.168.159.151 : 특정 IP 지정 </br> * ex) 192.168.159.0/24 : 192.168.159 대역 지정 </br> * ex) 192.168.159.100-150 : 특정 범위(100-150) 지정|

## (3) TCP Connect(Open) 스캔
### 1) 개요
1. 일반 사용자 권한으로 TCP 포트 오픈 여부를 확인하기 위해 connect 시스템 호출(system call)을 이용하는 방식으로 스캔 대상 포트별로 정상적인 TCP 연결설정을 수행하여 스캔하는 방식이다.
2. TCP 등 프로토콜 패킷 자체(raw packet)를 사용자가 직접 조작하여 생성하기 위해서는 관리자 권한이 필요하다. TCP SYN 스캔 등 대부분의 스캔 방식들이 관리자 권한으로 패킷을 직접 조작해서 스캔하는 방식이며 이러한 관리자 권한이 없을 경우에는 일반 사용자 권한으로 사용할 수 있는 시스템 호출을 이용하는 TCP Connect 스캔을 이용한다.
3. 포트 스캔 과정에서 connect 시스템 호출을 통해 TCP 연결설정 과정을 완전하게 수행하여 Target 호스트의 포트에 직접 연결되기 때문에 Open 스캔이라고도 하며 시스템 로그에 스캔한 흔적이 남는 특성이 있다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 SYN 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **SYN+ACK 응답을 수신한 후 ACK 패킷을 전송하여 TCP 연결을 완료**한다.(connect 시스템 호출 동작 방식)
   * 포트가 닫힌 상태 : **RST+ACK 응답을 수신**한다.
2. 대상 포트가 열린 상태에서 연결설정이 완료되고(3-way handshaking 과정) 나면 **포트 오픈 여부를 확인했기 때문에 연결을 즉시 중단하기 위해 RST+ACK 패킷을 전송한다.
3. TCP 연결 설정이 이루어지기 떄문에(이를 TCP 세션이 성립된 상태라고도 표현함) 대상 호스트의 시스템 로그에 스캔을 시도한 IP 주소가 남는 특징이 있다.
4. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 Connect 스캔(-sT) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열려있고 http(80/tcp) 포트는 닫혀 있는 것을 확인할 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 SYN+ACK 응답이 왔으며 ACK 전달 후(연결 설정 완료) RST+ACK로 연결을 즉시 중단하고 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.
  
#### (나) Filtered 상태
1. Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable)응답을 받을 수 있다. 방화벽 필터링(차단) 정책은 보안상의 이유로 응답을 하지 않도록 설정하는 것이 일반적이다.
   * iptables 방화벽의 경우 DROP 차단 정책을 사용하면 해당 패킷을 폐기한 후 아무런 응답을 하지 않고 REJECT 차단 정책을 사용하면 해당 패킷을 폐기한 후 설정된 ICMP 에러 메시지(Destination Unreachable)를 응답한다.
2. 실습
   * 스캔 결과를 살펴보면 Target 호스트의 ftp(21/tcp) 포트가 방화벽에 의해 차단(filtered)된 것을 알 수 있다.
   * (wireshark) 21/tcp 스캔 시 방화벽 룰세(필터링 정책)에 의해 차단되어 방화벽 차단 정책(REJECT(icmp-host-prohibited))에 설정된 ICMP 에러 메시지(Type: Destination Unreachable, Code:Host administratively prohibited) 응답이 온 것을 볼 수 있다.
  
## (4) TCP SYN(Half-Open) 스캔
### 1) 개요
1. 관리자 권한으로 TCP 패킷 자체(raw packet)를 직접 조작하여 TCP 포트 오픈 여부를 판단하는 스캔방식이다.
2. 포트 스캔 과정에서 TCP 패킷 헤더의 제어비트(control bit)를 조작, TCP 연결 설정 과정(3-Way handshaking)을 완전하게 수행하지 않기 때문에 Half-Open 스캔(반만 오픈하는 스캔) 이라고도 한다.
3. **스텔스 스캔(Stealth Scan)** 방식 : TCP 세션이 완전히 성립되지 않은 상태에서 (TCP 연결 설정 미완료 상태) 대상 시스템의 포트 활성화(오픈) 여부를 알아내는 스캔방식으로 TCP 연결설정이 완전히 이루어지지 않기 때문에 스캔 대상 시스템에 로그가 남지 않아 공격자는 자신의 IP를 노출시키지 않으면서 스캔할 수 있는데 이렇게 흔적을 남기지 않는다는 의미에서 스텔스 스캔이라 한다.
   * 대표적인 스텔스 스캔방식으로 TCP SYN Scan, TCP FIN Scan, TCP NULL Scan, TCP Xmas Scan 등이 있다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 SYN 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **SYN+ACK 응답을 수신**한다.
   * 포트가 닫힌 상태 : **RST+ACK 응답을 수신**한다.
2. 대상 포트가 열린 상태이면 Target 호스트로부터 SYN+ACK 응답이 오고 **해당 응답만으로도 포트가 열린 상태임을 알 수 있기 때문에 연결을 완료하지 않고 패킷 조작을 통해 즉시 중단하기 위한 RST 패킷을 전송**한다.
3. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 SYN 스캔(-sS) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열려 있고 http(80/tcp) 포트는 닫혀있는 것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 SYN+ACK 응답이 왔으며 연결 미완료 상태에서 RST로 즉시 연결을 중단하고 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (나) FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (5) TCP FIN/NULL/Xmas 스캔
### 1) 개요
1. 관리자 권한으로 TCP 패킷 자체(raw packet)를 직접 조작하여 TCP 포트 오픈 여부를 판단하는 스캔방식이다.
2. TCP 세션(연결)을 생성하지 않고 스캔하는 **스텔스 스캔**방식으로 TCP 패킷 헤더의 제어비트(control bit)를 비정상적으로 설정해서 스캔한다. 스캔방식에 따른 제어비트 설정 방식은 다음과 같다.
   * TCP FIN 스캔 : **FIN 제어비트만 설정**하여 스캔하는 방식으로 TCP 표준에서 연결 종료 패킷은 FIN+ACK 제어비트를 사용한다.
   * TCP NULL 스캔 : **제어비트 설정하지 않고 스캔**하는 방식으로 TCP 표준에서 사용하지 않는 설정이다.
   * TCP Xmas 스캔 : **URG, PSH, FIN 제어비트를 설정**하여 스캔하는 방식으로 TCP 표준에서 사용하지 않는 설정이다.
3. TCP 표준(RFC 793)의 다음 특성을 이용하여 포트 오픈 여부를 확인한다.
   * 닫힌(CLOSED) 포트로 RST 이외의 패킷을 수신한 경우 RST 패킷으로 응답한다.
   * 열린(OPEN) 포트로 SYN, ACK 또는 RST 이외의 패킷을 수신한 경우 이를 폐기하고 응답하지 않는다.
   * 따라서 위와 같은 TCP 표준 동작방식을 준수하는 시스템이라면 **SYN, ACK 또는 RST 이외의 패킷을 수신한 경우 닫힌 포트에서는 RST 패킷으로 응답하고 열린 포트에서는 응답하지 않는다.**

### 2) 동작방식
#### (가) TCP FIN 스캔 : OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 FIN 제어비트만 설정한 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 FIN 스캔(-sF) 수행
   * 스캔 결과를 살펴보면 Target 호스트이 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 http(80/tcp) 포트는 닫혀 있는(closed) 것을 알 수 있다.
   * 23/tcp 포트가 open|filtered 상태로 보이는 것은 응답이 없는 경우가 해당 포트가 열린 상태(open)뿐만이 아니라 방화벽에 의해 차단되는(filtered) 경우에도 응답이 없을 수 있기 때문이다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (나) TCP NULL 스캔 : OPEN/CLOSE 상태
1. 먼저 Target 호스트의 대상 포트로 제어비트를 아무것도 설정하지 않은 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 NULL 스캔(-sN) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 httpd(80/tcp) 포트는 닫혀 있는(closed)것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.
  
#### (다) TCP X-mas 스캔 : OPEN/CLOSE 상태
1. 먼저 Target 호스트의 대상 포트로 URG, PSH, FIN 제어비트를 설정한 패킷을 전송한다. Xmas라고 이름을 붙인 이유는 크리스마스트리처럼 제어비트를 반짝거리게 설정했다는 의미이다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 포트가 열린 상태 : **응답 없음**
   * 포트가 닫힌 상태 : **RST+ACK 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 23, 80 TCP 포트(-p)에 대한 Xmas 스캔(-sX) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 telnet(23/tcp) 포트는 열린 상태이거나 방화벽에 의해 차단된 상태(open|filtered)이고 http(80/tcp) 포트는 닫혀 있는(closed)것을 알 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 Target 호스트로부터 응답이 없는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 Target 호스트로부터 RST+ACK 응답이 온 것을 볼 수 있다.

#### (라) TCP FIN/NULL/Xmas 스캔 : FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (6) TCP ACK 스캔
### 1) 개요
1. Target 호스트의 포트 오픈 여부를 판단하는 것이 아니라 방화벽 룰셋(필터링 정책)을 알아내기 위한 스캔방식이다.
2. Target 호스트의 대상 포트로 **ACK 제어비트만 설정한 패킷**을 전송하면 방화벽 룰셋(필터링 정책)에 따라 다음과 같은 응답을 확인할 수 있다.
   * 방화벽에 의해 차단(filtered)된 상태 : **방화벽으로부터 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 수신**한다.
   * 방화벽에 의해 허용(unfiltered)된 상태 : **Target 호스트로부터 포트 오픈 여부와는 무관하게 RST 응답을 수**신한다. TCP 표준에 따르면 열린 포트에 ACK를 수신한 경우 RST로 응답하고 닫힌 포트에 ACK를 수신한 경우(RST 이외의 패킷)에도 RST로 응답한다.
3. 방화벽에서 허용된 경우, Target 호스트의 포트 오픈 여부에 상관없이 RST 응답을 수신하기 때문에 TCP ACK 스캔은 포트 오픈 여부를 판단할 수 없다.

### 2) 동작방식
1. 먼저 Target 호스트의 대상 포트로 ACK 제어비트만 설정한 패킷을 전송한다. 전송 후 방화벽 룰셋(필터링 정책)의 차단/허용 여부에 따라 다음과 같은 응답 패킷을 수신한다.
   * 차단(filtered) 상태 : 방화벽으로부터 **응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 수신**
   * 허용(unfiltered) 상태 : Target 호스트로부터 **RST 응답 수신**
2. 실습 환경
   * Target 호스트의 방화벽 설정을 살펴보면 telnet(23/tcp), http(80/tcp) 포트를 허용하고 그 이외의 접근에 대해서는 차단(REJECT)하고 있다.
   * Target 호스트의 포트 오픈 여부를 살펴보면 telnet(23/tcp) 포트만 열려있고 나머지 포트(21/tcp, 22/tcp, 80/tcp)는 닫혀있다.
3. 실습 결과
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 21, 22, 23, 80 TCP 포트(-p)에 대한 ACK 스캔(-sA) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 ftp(21/tcp), ssh(22/tcp) 포트는 방화벽에 의해 차단(filtered)되고 있고 telnet(23/tcp), http(80/tcp) 포트는 방화벽에 의해 허용(unfiltered)되고 있는 것을 알 수 있다.
   * (wireshark) 21/tcp, 22/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 차단되어 ICMP 에러 메시지(Destination Unreachable) 응답이 온 것을 볼 수 있다.
   * (wireshark) 23/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 허용되어 Target 호스트로 탐지 패킷이 전달되고 23/tcp 포트는 열려있지만, 정상적인 연결 요청을 위한 SYN 패킷이 아닌 ACK 패킷이기 때문에 RST 응답하는 것을 볼 수 있다.
   * (wireshark) 80/tcp 포트 스캔 시 방화벽 룰셋(필터링 정책)에 의해 허용되어 Target 호스트로 탐지 패킷이 전달되고 80/tcp 포트는 닫혀있기 때문에 RST로 응답하는 것을 볼 수 있다.

## (7) UDP 스캔
### 1) 개요
1. Target 호스트의 UDP 포트 오픈 여부를 판단하는 스캔방식으로 닫힌 UDP 포트로 패킷 수신 시 **ICMP 에러 메시지(Type3: Destination Unreachable, Code3:Port Unreachable)로 응답**하는 특성을 이용한다.

### 2) 동작방식
#### (가) OPEN/CLOSED 상태
1. 먼저 Target 호스트의 대상 포트로 UDP 패킷을 전송한다. 전송 후 포트 오픈 여부에 따라 다음과 같은 응답 패킷을 확인할 수 있다.
   * 포트가 열린 상태 : **UDP 응답을 수신하거나 응답 없음**
   * 포트가 닫힌 상태 : **ICMP 에러 메시지(Type3: Destination Unreachable, Code3: Port Unreachable) 응답 수신**
2. 실습
   * Scanner 호스트 : 192.168.57.100 / Target 호스트 : 192.168.56.100
   * Target 호스트(192.168.56.100)의 53, 123 UDP 포트(-p)에 대한 UDP 스캔(-sU) 수행
   * 스캔 결과를 살펴보면 Target 호스트의 dns(53/udp) 포트는 열려(open)있고 ntp(123/udp) 포트는 닫혀(closed)있는 것을 알 수 있다.
   * (wireshark) DNS(53/udp) 포트 스캔 시 Target 호스트로부터 DNS 응답이 온 것을 볼 수 있다. 만약 포트 스캔 시 UDP 요청 패킷이 해당 서비스에 적절한 요청이 아닐 경우 응답 없음이 발생할 수 있다.
   * (wireshark) NTP(123/udp) 포트 스캔 시 Target 호스트로부터 ICMP 에러 메시지(Type3: Destination Unreachable, Code 3: Port Unreachable) 응답이 온 것을 볼 수 있다.

#### (나) FILTERED 상태
1. TCP Connect 스캔과 동일하게 Target 호스트의 포트(서비스)가 방화벽에 의해 필터링(차단)되고 있다면 방화벽 차단 정책에 따라 응답이 없거나 ICMP 에러 메시지(Destination Unreachable) 응답을 받을 수 있다.

## (8) Decoy 스캔
### 1) 개요
1. Decoy 스캔은 다양한 포트 스캔을 수행할 때 스캔을 당하는 Target 호스트에서 스캐너 주소를 식별하기 어렵도록 실제 스캐너 주소 외에 다양한 위조된 주소로 스캔하는 방식을 말한다.
2. 다양한 IP로 스캐너 주소를 위조하여 Target 호스트의 관리자가 스캔을 누가 하는지 알아채기 어렵도록 한다.

### 2) 동작방식
1. 실습
   * Scanner 호스트 : 192.168.57.80 / Target 호스트 : 192.168.56.100
   * ```nmap -T4 -sF -p 23,80 192.168.56.100 -D RND```
   * Decoy(-D) 옵션을 통해서 공격자 IP(192.168.57.80) 외에 임의로 부여한(RND) 위조된 IP로 TCP FIN 스캔(-sF)을 수행
   * (wireshark) Source IP가 Scanner 호스트 IP(192.168.57.80)외에도 위조된 IP(26.7.176.84)로 스캔하는 것을 볼 수 있다.

## (9) 기타 옵션
### 1) 출력(Output) 옵션
1. -oN : 스캔 결과 일반 파일 형식으로 출력
2. -oX : 스캔 결과 XML 파일 형식으로 출력
3. -oG : 스캔 결과 Grepable(grep, awk 등으로 분석하기 편한) 파일 형식으로 출력

### 2) 기타 옵션
1. -O : 영 대문자 O, 대상 호트의 운영체제 정보를 출력

# 12.서비스 거부(DoS:Denial Of Service) 공격
## (1) 개요
1. 서비스 거부 공격은 공격 대상 시스템(Target)이 정상적인 서비스를 할 수 없도록 서비스를 마비시키는 형태의 공격을 말한다. 따라서 **서비스 거부 공격은 공격 대상 시스템의 서비스 가용성(Availability)을 떨어트리는 것이 공격의 목적**이다.
2. 서비스 거부 공격은 크게 다음 세 가지 유형으로 구분할 수 있다.
   * 파괴 공격 : 디스크, 데이터, 시스템 파괴
   * 시스템 자원 소진 공격 : CPU, 메모리, 디스크 등의 자원에 과도한 부하를 발생시키는 유형
   * 네트워크 자원 소진 공격 : 과도한 트래픽으로 네트워크 대역폭을 소진시키는 유형
3. 서비스 거부 공격(DoS: Denial Of Service) Vs 분산 서비스 거부(DDos:Distributed Denial Of Service) 공격의 차이점
   * 서비스 거부(DoS) 공격 : 공격자가 **단일 컴퓨터를 이용하여 공격**하는 형태
   * 분산 서비스 거부(DDoS) 공격 : 공격자가 **분산된 다수의 컴퓨터(좀비 PC) 또는 장치(좀비 Device)들을 이용하여 공격**하는 형태
  
## (2) Ping Of Death Attack
### 1) 개요
1. **ping 명령을 통해 ICMP(또는 ICMP Echo Request) 패킷(메시지)을 정상적인 크기보다 아주 크게 만들어 전송하면 MTU(Maximum Transmission Unit)에 의해 다수의 IP 단편화(fragment)가 발생**하게 한다.
   * MTU는 물리적인 네트워크 프로토콜 프레임의 데이터부(Payload)의 최대 크기를 의미한다.
   * 이더넷의 경우 1,500byte, 즉 IP 패킷의 최대 크기가 1,500byte이기 때문에 IP 헤더부(기본 20byte)를 제외하면 ICMP 패킷은 최대 1,480byte의 크기로 생성된다.
2. 수신 측에서는 단편화된 패킷을 재조합하는 과정에서 많은 부하가 발생하거나, 재조합 버퍼의 오버플로우가 발생하여 정상적인 서비스를 하지 못하도록 한다.

### 2) 대응책
1. Ping of Death 공격의 핵심은 Ping 패킷의 데이터 크기를 매우 크게 하여 패킷을 몇 개만 보내도 수십 개로 분할하여 목적지로 송신되는 것이다. 보통의 ICMP 패킷은 분할하지 않으므로 패킷 중 분할이 일어난 패킷을 공격으로 의심하여 탐지하는 방식을 사용한다.
2. 현재 대부분 시스템은 Ping of Death 공격을 받을 때 반복적으로 들어오는 일정 수 이상의 ICMP 패킷을 무시하게 설정되어 있다. 만약 여전히 취약점을 가지고 있다면 패치가 필요하다

### 3) 실습자료
1. 실습환경
   * Attacker : 161.X.X.210 , Target : 192.X.X.131
   * 최대 크기 65,535byte의 ICMP 패킷을 대량으로 희생자에게 전송
2. 패킷 캡처(Wireshark)
   * 다량의 단편화된 IP 패킷이 희생자 측에 발생하고 있음을 확인할 수 있다.

## (3) Land Attack
### 1) 개요
1. land는 착륙하다. 나쁜 상태에 빠지게 한다는 의미가 있다. 따라서 해당 시스템을 나쁜 상태에 빠지게 하는 도스 공격 기법이라 할 수 있다.
2. 공격자가 **출발지와 목적지 IP가 같은 패킷**을 만들어 공격 대상 시스템에 보냄으로써 수신자가 자기 자신에게 응답을 보내 무한 루프 상태에 빠지도록 하여 시스템 자원을 소모시키는 형태의 도스 공격을 말한다.

### 2) 대응책
1. 현재 대부분 운영체제는 Land Attack에 대한 보안패치가 적용되어 있다. 미적용 운영체제라면 **보안패치를 적용**한다.
   * 패치 적용 시 출발지와 목적지 IP 주소가 동일한 패킷의 경우 모두 폐기(Drop) 처리한다.
2. **침입차단시스템(방화벽), 라우터 등 패킷 필터링 장비를 통해 출발지 IP와 목적지 IP가 같으면 차단하도록(필터링하도록) 설정**한다.

### 3) 실습자료
1. 실습환경
   * Target IP(192.168.197.133)로 출발지 IP를 스푸핑한 ICMP 메시지 전송
2. 패킷 캡처(tcpdump)
   * Target IP와 동일한 출발지 IP의 패킷이 Target 측에 발생하고 있음을 확인할 수 있다.
  
## (4) Smurf Attack
### 1) 개요
1. 스머프 공격은 출발지 IP를 희생자 IP로 위조한 후 증폭 네트워크로 ICMP Echo Request를 브로드캐스트 함으로써, 다수의 ICMP Echo Reply가 희생자에게 전달되어 서비스 거부를 유발시키는 공격 기법이다.
2. Directed Broadcast
   * IP 주소의 호스트 ID 비트를 모두 1로 설정하여 브로드캐스트하는 방식을 Directed Broadcast라고 한다.
   * 원격지 네트워크에 broadcast를 해야 할 경우에 원격지 주소의 호스트 ID 비트를 모두 1로 설정하여 전송하게 된다. 이때 원격지 라우터의 Directed Broadcast가 활성화되어야 가능한데 일반적으로 보안상의 문제로 허용하지 않는다.
3. Amplifier(Bounce) Network(증폭 네트워크)
   * ICMP Echo Request 브로드캐스트 메시지를 받아서 희생자에게 다수의/증폭된 ICMP Echo Reply를 전송하는 네트워크를 말한다.

### 2) 대응책
1. 스머프 공격의 특성상 공격이 시작되면 단시간에 다수의 ICMP Echo Reply 패킷을 희생자에게 전송한다. 따라서 동일한 ICMP Echo Reply 패킷이 다량으로 발생한다면 해당 패킷들을 침입차단시스템으로 모두 차단(Drop)시킨다.
2. **증폭 네트워크로 사용되는 것을 막기 위해 다른 네트워크로부터(외부로부터) 자신의 네트워크로 들어오는 Directed Broadcast 패킷을 허용하지 않도록 라우터 설정**을 한다.
   * 라우터 명령어 : (config-if)# **no ip directed-broadcast**
3. 브로드캐스트 주소로 전송된 ICMP Echo Request 메시지에 대해 응답하지 않도록 시스템 설정을 한다.

### 3) 실습자료
1. 실습환경
   * 희생자 IP로 출발지 주소를 위조한 대량의 ICMP Echo Request 메시지를 브로드캐스트
2. 패킷 캡처(Wireshark) : 공격자 호스트 관점
   * 브로드캐스트 주소(192.168.56.255)로 희생자 주소(10.10.10.20)로 위조한 대량의 ICMP Echo Request 메시지가 전송되고 있음을 확인할 수 있다.
3. 패킷 캡처(Wireshark) : 희생자 호스트 관점
   * 브로드캐스트 주소(192.168.56.255)의 다양한 호스트로부터 희생자 주소(192.168.57.20)로 ICMP Echo Reply 메시지가 수신되고 있음을 확인할 수 있다.

## (5) Teardrop Attack
### 1) 개요
1. IP 패킷의 재조합 과정에서 **조작된 단편의 오프셋 정보로 인해 수신시스템에 오류나 부하가 발생**하도록 만드는 도스 공격을 말한다.
2. 공격자는 IP fragment offset값을 **서로 중첩되도록 조작하여 전송하고 이를 수신한 시스템이 재조합하는 과정에서 오류나 부하가 발생**, 시스템의 기능을 마비시키는 공격 방식이다.
3. 패킷의 fragment 관련 헤더 값을 조작하는 유사한 공격으로 Bonk, Boink가 있다.

### 2) 대응책
1. 운영체제의 보안패치를 모두 적용하여 OS의 취약점을 해소한다.

## (6) IP 단편화의 취약점을 이용한 우회 공격
### 1) 개요
1. IP 단편화의 취약점을 이용하여 **패킷 필터링 장비(방화벽, 침입탐지시스템 등)를 우회하기 위한 대표적인 공격 기법에는 "Tiny Fragment(작은 단편) 공격"과 "Fragment Overlap(단편 중첩) 공격"** 이 있다.
2. Teardrop 공격처럼 IP 단편의 오프셋을 조작하는 공격이지만 **도스 공격이 아닌 침입차단시스템 등을 우회하여 허용하지 않는 공격 대상 시스템의 서비스에 접근하기 위한 공격**이다.

### 2) Tiny Fragment (작은 단편) 공격
1. TCP/UDP 헤더가 2개의 IP 단편에 나누어질 정도로 최초의 단편을 아주 작게 만들어서 패킷 필터링 장비를 우회하는 공격 기법을 말한다.
2. 공격 원리
   * 공격자는 TCP/UDP 헤더가 2개의 IP 단편에 나누어질 정도로 작게 쪼개서 첫 번째 단편에는 목적지 포트가 포함되지 않고 두 번째 단편에 포함되도록 한다.
   * 패킷 필터링 장비는 첫 번째 IP 단편에 필터링할 정보가 없어 통과시키고 이후 두 번째 단편은 첫 번째 단편이 허용되었으므로 통과시킨다.
   * 목적지 서버에서 단편들이 재조합되어 공격자가 원하는 목적지 포트로 연결된다.
3. 정리하면 첫 번째 단편화에는 목적지 포트 정보가 없고 두 번째 단편화에는 목적지 포트 정보가 있다. 첫 번째 단편이 허용되었으므로 두 번째 단편도 통과

### 3) Fragment Overlap (단편 중첩) 공격
1. IP 단편의 오프셋을 조작하여 첫 번째 단편의 일부분을 두 번째 단편이 덮어쓰도록 함으로써 패킷 필터링 장비를 우회하는 공격 기법을 말한다.
2. 공격 원리
   * 공격자는 두 개의 IP 단편을 생성한 후 첫 번째 단편에는 패킷 필터링 장비에서 허용하는 목적지 포트(e.g. HTTP 80번포트)가 포함되도록 하고 두 번째 단편에는 공격자가 연결하기를 원하는 목적지 포트(e.g. Telnet 23번포트)가 포함되도록 한다.
   * 두 번째 단편의 목적지 포트가 첫 번째 단편의 목적지 포트를 덮어쓸 수 있도록 두 번째 단편의 오프셋을 조작한다.
   * 패킷 필터링 장비는 첫 번째 IP 단편에 있는 허용하는 목적지 포트 정보를 확인한 후 통과시키고 이후 두 번째 단편은 첫 번째 단편이 허용되었으므로 통과시킨다.
   * 목적지 서버에서 단편들이 재조합되어 공격자가 원하는 목적지 포트로 연결된다.
3. 정리하면 첫 번째 단편화에는 허용 가능한 목적지 포트 정보가 있고 두 번째 단편화에는 첫 번째 단편화의 목적지 포트 정보를 덮어쓸 원하는 목적지 포트 정보가 있다. 첫 번째 단편이 허용되었으므로 두 번째 단편도 통과되고 재조합 되는 과정에서 원하는 목적지 포트로 연결된다.

### 4) 대응책
1. **단편화된 패킷들을 재조합하여 IP 단편화를 이용한 우회 공격의 탐지가 가능한** 패킷 필터링 장비를 적용한다.

# 13. 분산 서비스 거부(DDoS:Distributed Denial of Service) 공격
### 1) 개요
1. 분산 서비스 거부 공격은 분산된 다수의 좀비 PC/디바이스에 의해 공격대상 시스템의 서비스를 마비시키는 공격 형태를 의미한다.
2. 일반적인 공격 구조를 살펴보면 다음과 같이 크게 4가지 구성 요소로 이루어져 있다.
   * **공격자(Attacker)** : C&C 서버에 공격 명령을 전달하는 해커의 컴퓨터를 말한다. 봇 마스터(Bot Master)라고도 한다.
   * **명령제어(C&C:Command & Control) 서버** : 공격자로부터 직접 공격 명령을 전달받는 시스템을 말하며 전달받은 명령은 관리하는 다수의 좀비 PC/디바이스에 전달한다. 마스터 또는 C2 서버라고도 한다.
   * **좀비(Zombie) PC/디바이스** : C&C 서버로부터 전달받은 명령을 실행하여 공격대상에 실제 공격을 수행하는 PC/디바이스를 말한다. 봇, 슬레이브, 에이전트라고도 한다.
   * **공격대상(Target)** : 공격의 대상이 되는 시스템을 말한다.
3. 일반적인 공격 절차는 다음과 같다.
   * 공격자는 각 봇을 관리하고 명령을 내리는 C&C 서버를 구축한다.
   * 스팸 메일이나 악의적인 웹사이트 등을 통해 불특정 다수의 PC에 봇을 배포해 감염을 시도한다.
   * 사용자가 봇 프로그램을 다운로드해 실행하면 봇에 감염된다.
   * 봇이 C&C 서버에 접속함으로써 감염 PC는 봇넷의 일원으로 추가된다.
   * 공격자가 C&C 서버에 명령을 내리면 C&C 서버는 봇에 명령을 전달한다.
   * 봇은 명령에 따라 다양한 공격을 수행하며 스스로 다른 PC로 봇의 전파를 시도한다.
  
### 2) 봇(Bot)/봇넷(Botnet) 살펴보기
#### (가) 개요
1. 봇은 소프트웨어적 로봇을 줄임말로 보안상 결합을 이용해 원격에서 해당 시스템을 제어할 수 있는 프로그램을 말한다. 이러한 악성 봇에 감염된 PC/디바이스를 "좀비 PC/디바이스"라고 한다.
   * 일반적으로 봇은 웜/바이러스, 백도어, 스파이웨어, 루트킷 등 다양한 악성코드들의 특성을 복합적으로 가지고 있다.
   * 봇은 공격자의 명령에 따라 활동하며 공격자가 감염된 PC/디바이스를 제어하여 정보 유출, 스팸 메일 발송, 디도스 공격, 트래픽 스니핑, 키 로깅 등 다양한 형태의 공격을 수행한다.
2. 봇넷이란 악성코드 스파이웨어인 봇에 감염된 다수의 좀비 PC/디바이스로 구성된 네트워크를 말한다. 좀비들은 C&C 서버와 직접 통신하거나 좀비들 간에 서로 통신을 수행하면서 공격자의 명령을 수행한다.
   * 합법적인 분산 네트워크로 봇넷 기술을 활용할 수 있지만 일반적으로 봇넷이라 하면 악의적인 의도를 가진 불법 네트워크를 의미한다.
3. 봇넷은 명령/제어를 위해 사용하는 프로토콜에 따라 IRC 봇넷, HTTP 봇넷, P2P 봇넷으로 분류할 수 있으며 네트워크 구성에 따라 중앙 집중형 방식(IRC 봇넷, HTTP 봇넷)과 분산형 방식(P2P 봇넷)으로 분류할 수 있다.

#### (나) 봇넷 명령 제어 방식
1. **중앙 집중형 명령/제어**(Command/Control) 방식
   * 초기에는 구조가 유연하고 널리 사용되는 IRC의 특성을 이용한 IRC 봇넷이 주를 이루었으나 탐지 및 대응을 보다 어렵게 하기 위해 인터넷상에서 많이 사용되는 웹 프로토콜인 HTTP를 기반으로 진화하였다.
   * 다수의 도메인을 확보하여 중앙 집중형 명령/제어를 하기 위한 C&C 서버로 등록하고 다수의 좀비가 C&C 서버와 연결되어 명령을 수행하는 구조이다.
   * 명령/제어 구조가 비교적 간단하지만, C&C 서버가 탐지 및 차단되면 전체 봇넷이 중단될 가능성이 있다.
   * 대표적인 봇넷 유형에는 IRC 봇넷(Rbot 등), HTTP 봇넷(Robax 등)이 있다.
2. **분산형 명령/제어** 방식
   * 참여 멤버(좀비/봇)들이 모두 C&C 역할을 하여 그룹에 명령을 전파하는 분산 제어 방식으로 중앙 관리를 위한 별도의 도메인 및 C&C 서버가 불필요하다.
   * 주로 봇넷을 보호하고 네트워크가 끊어지는 것을 방지하기 위한 방식으로 참여 멤버 모두 C&C 역할을 하므로 탐지 및 차단이 어렵다.
   * 대표적인 봇넷 유형에는 P2P 봇넷(Storm, Peacomm 등)이 있다.

#### (다) DNS 싱크홀 서비스
* 악성 봇에 감염된 PC가 해커의 명령을 받기 위해 C&C 서버로 연결을 시도할 때 C&C 서버 대신 싱크홀 서버로 우회시켜 더 이상 해커로부터 조종 명령을 받지 않도록 해주는 시스템/서비스를 말한다.
* 싱크홀의 사전적 의미는 땅이 가라앉아 생긴 구덩이를 의미한다. 악성 봇을 미리 파놓은 구덩이(싱크홀 서버)로 유도하는 방식으로 이해할 수 있다.
* 한국인터넷진흥원에서 국내 주요 ISP 업체 및 가입기관과의 협력을 통해 DNS 싱크홀을 운영하고 있다.
* DNS 싱크홀 동작 과정은 다음과 같다.
   1. 사전 단계로 KISA에서 배포한 알려진 C&C 서버 목록을 ISP 등 DNS 싱크홀 적용기관의 DNS 서버에 주기적으로 업데이트한다.
   2. 악성봇에 감염된 PC가 싱크홀이 적용된 DNS에 C&C 서버에 대한 질의를 요청한다.
   3. DNS는 악성 봇 PC에 싱크홀 서버 IP 주소를 반환한다.
   4. 이를 통해 악성 봇 PC는 C&C 서버가 아닌 싱크홀 서버로 접속하여 공격자의 명령으로부터의 피해를 방지할 수 있다.
 
### 3) 봇넷의 보안장비 우회 기법
#### (가) 개요
1. 일반적으로 봇넷을 구성하는 좀비 PC나 랜섬웨어 등의 악성코드는 C&C 서버에 접속하는 과정에서 C&C 서버 도메인에 대한 질의를 수행한다.
   * 보안장비 관점에서는 C&C 서버 도메인이나 IP 주소 등이 알려지면 이를 블랙리스트로 등록하여 탐지 및 차단 수행
   * 공격자 관점에서는 확보한 봇넷 멤버들의 지속적 유지를 위해 보안장비를 통해 탐지되지 않도록 하는 것이 중요
2. 따라서 공격자들은 봇넷 참여 멤버들의 **C&C 서버 접속 과정에서 보안장비에 의해 탐지되지 않도록 하기 위한 다양한 보안장비 우회 기법**들을 적용하고 있다. 대표적인 기법은 다음과 같다.
   * **Fast Flux 기법**
   * **DGA 기법**
   * **Domain Shadowing(도멩니 쉐도잉) 기법**

#### (나) Fast Flux 기법
1. 하나의 C&C 서버 도메인에 다수의 IP 주소를 할당하여 DNS 질의 시마다 지속적으로 IP 주소가 변경되도록 하는 기법을 말한다.
   * Flux의 사전적 의미는 지속적인 변화이다. 즉, 도메인 질의 시마다 C&C 서버 IP 응답을 빠르게 지속적으로 변화시킨다는 의미이다.
   * 미리 확보해 둔 다수의 C&C 서버 IP 주소들을 DNS 레코드(A 레코드)에 추가하고 TTL 값을 매우 작게 주어 빠르게 라운드 로빈 방식으로 응답이 되도록 한다.
2. 만약 보안장비에 의해 Fast Flux IP 중에 어느 하나가 차단된다고 해도 다른 IP를 통해 지속적으로 C&C 서버에 접속할 수 있다.
   * DNS 질의 자체를 탐지할 수 있는 7계층 보안장비가 없는 상황이라면 Fast Flux IP 일부만 차단해서는 C&C 서버로의 접속을 완전히 차단할 수 없다.
3. 정리하면 미리 확보해 둔 다수의 C&C 서버 IP 주소들을 A 레코드를 통해 DNS 레코드에 추가하고 TTL 값을 매우 작게 주어 빠르게 라운드 로빈 방식 응답. 도메인 질의 시마다 C&C 서버 IP 응답을 빠르게 변화

#### (다) DGA(Domain Generation Algorithm) 기법
1. 약속된 규칙에 따라 C&C 서버 도메인을 지속적으로 동적 생성하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다.
   * 다수의 임시 C&C 서버 도메인이 동적으로 생성되기 때문에 보안장비 입장에서는 이를 모두 탐지하고 차단하기가 매우 어렵다.
   * 컨피커 웜에 의해 DGA 기법이 처음 알려졌으며 Locky(시스템 날짜 기반으로 도메인명 생성), WannyCry 랜섬웨어 등에서 사용됨
2. 알고리즘에 따라 도메인을 다수 생성하기 때문에 공격자는 해당 알고리즘에 따라 생성될 수 있는 도메인 중 하나를 DNS 서버에 새롭게 등록하는 방식을 사용한다. 만약 등록한 도메인이 블랙리스트로 차단된다면 다른 도메인명을 재등록한다.
3. 정리하면 알고리즘에 따라 다수의 도메인을 동적 생성하여 DNS 서버에 등록하여 사용하고 차단되면 새로운 도메인을 등록하여 사용한다.

#### (라) Domain Shadowing 기법
1. 알려진 합법적인 도메인의 서브 도메인을 C&C 서버 도메인으로 사용하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다.
   * 적법한 절차로 도메인을 소유하고 있는 도메인 관리자의 개인정보 등을 탈취하여 도메인 소유자 몰래 많은 서브 도메인을 등록시켜놓고 사용하는 기법
   * 드라이브 바이 다운로드(DBD:Drive By Download) 공격 도구인 앵글러 익스플로잇 도구에서 탐지 회피를 위한 기술로 사용되어 알려짐
2. 주로 드라이브 바이 다운로드 공격에서 악성코드 유포지로 흘러가는 길목에 사용되는 경유지 도메인을 서브 도메인으로 사용한다.
3. 정리하면 합법적인 도메인 관리자의 개인정보 등을 탈취하여 많은 서브 도메인을 등록시켜 사용하는 기법

### 4) DDoS 공격 유형
|문자값|대역폭 소진공격|서비스(어플리케이션) 마비공격|
|:-:|:-|:-|
|대표 공격 유형|UDP/ICMP Flooding, SYN Flooding|HTTP GET Flooding|
|공격 형태|1. UDP/ICMP Traffic Flooding </br>* UDP/ICMP Flooding, DNS Query Flooding 등 </br>2. TCP Traffic Flooding </br>* SYN Flooding, SYN+ACK Flooding </br>3. IP Flooding </br>* Land Attack, Tear Drop, HTTP Continuation 등|1. HTTP Traffic Flooding </br>* GET Flooding, CC Attack 등 </br>2. HTTP Header/Option Spoofing </br>* Slowloris, Pyloris 등 </br>3. TCP Traffic Flooding </br>* TCP Session, SYN Flooding, TCP Slow Read 등 </br>4. Other L7 Service Flooding </br>* Hash Dos, Hulk DoS, FTP/SMTP Attack 등|
|프로토콜|3~4계층 (Network, Transport 계층) : IP, ICMP, IGMP, UDP, TCP 등|7계층 </br>(Application 계층) : HTTP, DNS, FTP, SMTP 등|
|증상|* 회선대연폭고갈 </br>* 동일 네트워크를 사용하는 모든 서비스에 대한 접속장애 발생|* HTTP 서버 과다 접속(또는 서비스 부하)으로 인한 장애발생 </br>* 공격대상 시스템만 피해|
|공격대상|네트워크 인프라|웹서버, 정보보호 장비 등|

1. UDP/ICMP Flooding : 공격자는 다량의 UDP/ICMP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 가득 채워 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격
2. DNS Query Flooding : 공격자는 UDP 프로토콜 기반의 서비스를 제공하는 DNS에 대해 DNS 쿼리 데이터를 다량으로 서버에 전송하여 DNS의 정상적인 서비스를 방해하는 공격
3. TCP SYN Flooding : 공격자는 다량의 SYN 패킷을 서버로 전달하여 서버의 대기큐를 가득 채워 새로운 클라이언트의 연결 요청을 무시하도록 하여 장애를 유발시키는 공격
4. TCP Flag Flooding : TCP의 Flag값(Control Bit)을 임의로 조작하면 SYN, ACK, FIN, RST와 같이 여러 형태의 패킷을 생성할 수 있으며, 서버는 이러한 패킷을 수신하는 경우 해당 패킷을 검증하기 때문에 서버 자원을 소모시키는 공격이다.
5. TCP Session Flooding : TCP 3-Way Handshake 과정을 과도하게 유발함으로써 서비스의 과부하를 유발하는 공격
6. HTTP Continuation : 서버로 전달되는 패킷에 HTTP 헤더 없이 Data만 채워 웹서버가 지속적으로 데이터 수신을 위해 TCP 자원을 사용하도록 하는 공격
7. HTTP GET Flooding : 공격자는 동일한 URL을 반복 요청하여 웹서버가 URL에 해당하는 데이터를 클라이언트에게 회신하기 위해 서버 자원을 사용하도록 하는 공격
8. HTTP GET Flooding with Cache-Control(CC Attack) : 공격자는 HTTP 메시지의 캐시 옵션(Cache-Control:no-store, must-revalidated)을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도하여 캐싱 서버의 기능을 무력화하고 웹서버의 자원을 소모시키는 공격
9. Slow HTTP POST(rudy) : HTTP POST 메소드를 이용하여 서버로 전달할 대량의 데이터를 장시간에 걸쳐 분할 전송하면 서버는 POST 데이터가 모두 수신하지 않았다고 판단하여 연결을 장시간 유지하게 하는 공격
10. Slow HTTP Header DoS(Slowris) : 웹서버는 HTTP 메시지의 헤더 부분을 먼저 수신하여 이후 수신할 데이터의 종류를 판단하게 되는데, 헤더 부분을 비정상적으로 조작하여 웹서버가 헤더 정보를 구분할 수 없도록 하면 웹서버는 아직 HTTP 헤더 정보가 모두 전달되지 않은 것으로 판단하여 연결을 장시간 유지하게 된다.
11. Slow HTTP Read DoS : 공격자는 웹서버와 TCP 연결 시, TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신하여 웹서버가 정상적으로 응답하지 못하도록 DoS 상태를 유발한다.
12. 해시도스(HashDoS) 공격 : 웹서버는 클라이언트로부터 전달받은 HTTP 메시지의 매개정보를 관리하기 위해 해시테이블을 사용한다. 조작된 매개정보를 포함한 다량의 메시지는 해시테이블 검색을 위한 인덱스로 사용되는 해시값에 충돌을 발생시켜 정확한 값을 찾기 위해 모든 해시테이블을 검사하게 되는데 이때 웹서버의 CPU 자원을 소진하게 되어 정상적인 서비스를 방해한다.
13. 헐크도스(HulkDoS) 공격 : GET Flooding 공격유형으로 동일 URL을 지속적으로 요청 시 차단될 수 있기 때문에 이를 우회하기 위해 URL을 지속적으로 변경하면서 공격하는 방식

### 5) 네트워크 대역폭 소진 공격 실습
#### (가) UDP Flooding 공격
1. 개요
   * 공격자는 다량의 UDP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 소진시켜 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격
2. 실습환경
   * Attacker : random IP(IP Spoofing), Target : 192.168.159.133
   * 53/udp(DNS 서비스) 포트로 다량의 UDP 패킷 발생
3. 패킵 캡처(도구: Wireshark)
   * Time 항목(초 단위)을 살펴보면 매우 짧은 시간 동안에 다량의 UDP 패킷이 Target 서버(192.168;.159.133)로 발생했음을 확인할 수 있다.
   * 출발지 IP를 보면 다양한 주소로 위조되어 있음을 확인할 수 있다. 다수의 좀비 PC에 의해 UDP 공격이 발생하게 되면 Target 네트워크에 대량의 트래픽이 발생하여 서비스가 불가한 상태가 된다.
4. 패킷 캡처(도구: tcpdump)
   * ```tcpdump -nn "udp"```
   * tcpdump의 BPF 옵션을 udp로 지정하여 해당 트래픽만 캡처함

#### (나) ICMP Flooding 공격
1. 개요
   * 공격자는 다량의 ICMP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 소진시켜 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격
2. 실습환경
   * Attacker : random IP(IP Spoofing), Target : 192.168.159.133
   * 다량의 ICMP 패킷(ICMP Echo Request/Ping) 발생
3. 패킷 캡처(도구: Wireshark)
   * Time 항목을 살펴보면 매우 짧은 시간 동안에 출발지 IP가 위조된 다량의 ICMP 패킷(ICMP Echo Request)이 Target 서버(192.168.159.133)로 발생했음을 확인할 수 있다.
4. 패킵 캡처(도구: tcpdump)
   * ```tcpdump -nn "icmp"```
   * tcpdump의 BPF 옵션을 icmp로 지정하여 해당 트래픽만 캡처함

### 6) 서버/서비스 자원 소진 공격 실습
#### (가) TCP SYN Flooding 공격
1. 개요
   * TCP SYN Flooding 공격은 TCP 연결설정 과정(3-Way Handshake)의 취약점을 이용한 공격으로 공격 대상 시스템의 TCP 연결자원을 소진시켜 외부로부터 TCP 연결 요청을 받을 수 없는 상태로 만드는 서비스 거부 공격 기법이다.
2. 공격원리
   * Client가 Server로 SYN 요청을 보내면 Server는 SYN+ACK 응답을 보내고 해당 연결 요청정보를 incomplete connection queue에 저장한다.
   * Client로부터 ACK를 받아 연결이 완료되면 incomplete connection queue에 있던 연결 요청정보를 completed connection queue로 이동, accept() 시스템콜을 통해 클라이언트와 통신할 연결소켓이 생성되면서 연결 요청정보는 삭제된다.
   * TCP SYN Flooding 공격은 다수의 TCP 연결을 완료하지 않아 incomplete connection queue를 꽉 차게 만들어 더 이상 새로운 연결 요청을 받을 수 없도록 하는 공격이다. backlog queue의 크기는 incomplete와 complete queue 크기의 합이다.
   * 공격자는 incomplete connection queue를 소진시키기 위해 출발지 IP를 도달 불가능한(존재하지 않는) IP로 위조한 SYN 요청을 보내 서버 측의 SYN+ACK 요청에 대한 ACK 응답이 발생하지 않도록 만든다.
3. 실습환경
   * Attacker : random IP(IP Spoofing), Target : 192.168.197.133
   * 80/tcp(HTTP 서비스) 포트로 다량의 TCP 연결 요청(SYN) 패킷 발생
4. 공격대상 측 소켓 상태
   * Client가 Server로 SYN packet을 보내면 Server는 SYN+ACK를 보내고 해당 연결설정이 완료될 때까지 Backlog queue(연결요청대기큐)에 담아둔다.
   * 정상적인 연결이라면 클라이언트로부터 SYN+ACK에 대한 ACK 응답을 받아 연결설정이 완료되지만, Syn Flooding 공격의 경우에는 ACK 응답이 오지 않아 Backlog queue에 연결정보가 계속 쌓이게 된다. ```netstat -ant``` 명령어를 통해 소켓상태를 살펴보면 다수의 SYN_RECV 상태의 tcp 소켓을 확인할 수 있는데 SYN_RECV 상태가 바로 ACK 응답을 대기하고 있는 상태이다.
   * Backlog queue가 꽉 차게 되면 더 이상 연결 요청을 받을 수 없어 정상적인 서비스 제공이 불가능한 상태가 된다.
5. 패킷 캡처(도구: Wireshark)
   * Time 항목을 살펴보면 매우 짧은 시간 동안에 다량의 TCP 연결 요청이 Target 서버로 발생했음을 확인할 수 있다.
   * 위조된 출발지 IP 중에는 실제 존재하는 IP도 있으며, 이 경우 상대방으로부터 RST 응답이 발생하는 것을 확인할 수 있다.
6. 패킷 캡처(도구: tcpdump)
   *```tcpdump -nn "tcp port 80"```
7. 대응책
   * 완전한 3-Way Handshaking이 이루어지지 않는다면 Backlog queue(연결요청대기큐)가 소비되지 않도록 설정한다. 대표적으로 Syn Cookie 설정을 이용할 수 있다. ex) ```[Linux]#sysctl -w net.ipv4.tcp_syncookies=1``` : Syn Cookie 기능을 활성화한다. (1은 true를 의미)
   * 방화벽 또는 DDoS 대응장비를 이용하여 동일 Client(IP)의 연결 요청에 대한 임계치 설정을 통해 과도한 연결 요청이 발생하는 것을 차단한다. iptables를 이용한 설정 예를 살펴보면 다음과 같다. ex) ```iptables -A INPUT -p tcp --dport 80 --syn -m connlimit --connlimit-above 5 -j DROP``` : TCP 80포트 연결 요청에 대하여 동일 출발지 IP로 동시 연결개수가 5개 초과 시 이를 차단한다.
   * First SYN DROP 설정을 한다. 연결 요청 패킷을 보내는 클라이언트가 실제로 존재하는지를 파악하는 방법으로 클라이언트로부터 전송된 첫 번째 SYN은 DROP하여 재요청 패킷이 도착하는지 확인하여 출발지 IP가 위조되었는지 판단한다. 대부분의 공격 툴이 다량의 SYN 요청을 생성할 뿐 패킷 DROP시 재전송을 수행하지 않는다는 점을 이용한 방법이다.
   * Backlog queue의 크기를 늘려준다. 이 방법은 임시적인 조치는 되지만 대규모 공격이 발생했을 때는 순식간에 queue가 full 상태가 되기 때문에 효과를 보기 어렵다. ex1) ```[Linux]#sysctl -w net.ipv4.tcp_max_syn_backlog = 1024``` : TCP Backlog queue의 크기를 1024로 늘린다. ex2) ```[Unix(솔라리스)]#ndd -set /dev/tcp tcp_conn_req_max_q0 1024``` : TCP Backlog queue의 크기를 1024로 늘린다.
   * SYN+ACK에 대한 대기 시간을 줄인다.(대기시간을 너무 줄이면 정상 요청에 문제가 생길 수 있음)
8. 정리하면 TCP SYN을 보내면 소켓은 SYN_RECV 상태가 되고 incomplete connection queue에 연결 요청 정보가 저장되고 3-Way Handshake를 완료하면 소켓은 ESTABLISHED 상태가 되고 complete connection queue에 연결 요청 정보가 저장되고 accept() 시스템 콜을 통해 연결 소켓이 생성되면 요청 정보는 삭제가 된다. 이를 악용하여 랜덤 IP의 클라이언트가 SYN을 서버에 보내어 서버에서 SYN+ACK응답을 받고 ACK를 보내지 않아 서버의 소켓에서는 SYN_RECV 상태의 소켓이 많아지고 incomplete connection queue가 꽉 차게 되어 더 이상 새로운 연결 요청을 받을 수 없게 된다. 이 때 존재하는 IP의 경우 RST를 보내게 된다. 대응책으로는 Backlog queue를 사용하지 않게 Syn  Cookie 사용 ```[Linux]#sysctl -w net.ipv4.tcp_syncookies=1``` 로 설정하거나 iptables 설정 ```iptables -A INPUT -p tcp --dport 80 --syn -m connlimit --connlimit-above 5 -j DROP```로 설정하거나 Backlog queue 크기 늘리거나 SYN+ACK에 대한 대기 시간 줄인다.

#### (나) HTTp GET Flooding 공격
1. 개요
   * HTTP GET Flooding 공격은 공격자가 동일한 동적 컨텐츠에 대한 HTTP GET 요청을 다량으로 발생시켜 공격 대상 웹서버가 해당 요청을 처리하기 위해 서버 자원을 과도하게 사용하도록 하여(부하를 유발하여) 정상적인 요청을 처리하지 못하도록 하는 서비스 거부 공격이다.
2. 실습 환경
   * Attacker : 192.168.197.134 , Target : 192.168.197.133
   * 동일 URL(http://192.168.197.133/home/index.php)로 다량의 GET 요청 발생
3. 웹서버 access 로그 분석
   * ```cat access_log-20160214 | grep "GET /home/index.php" | head -1```
   * ```cat access_log-20160214 | grep "GET /home/index.php" | awk '{print $1}' | sort | uniq -c | sort -rn```
   * 웹서버의 access 로그 분석 시 awk, sort, uniq 명령을 이용하여 요청 IP에 대한 분석을 손쉽게 할 수 있다.
   * access 로그 포맷을 보면, 첫 번째 칼럼이 "요청 클라이언트 IP"이다. 어떠한 IP로 요청이 발생했는지 분석할 때 위 명령을 자주 활용한다.
   * ```grep "GET /home/index.php"``` : access 로그에서 "GET /home/index.php"을 포함하는 행을 grep 한다.
   * ```awk '{print $1}'``` : grep한 행 중에 첫 번째 컬럼($1)을 출력(print)한다.
   * ```sort``` : 오름차순으로 정렬한다.
   * ```uniq -c``` : 연속된 중복 행을 제거한다. 즉 동일한 IP가 연속해서 나오면 이를 하나만 출력하고 -c 옵션을 통해 중복된 행의 개수를 출력한다. 위 예를 보면 결과의 첫 번째 필드가 중복된 행의 개수이다.
   * ```sort -rn``` : -r(reverse)은 역순(내림차순) 정렬을 의미하고, -n(number)은 정렬한 컬럼 값을 숫자 형식으로 보고 정렬하라는 의미이다.
4. 패킷 캡쳐(도구: ngrep)
   * ```ngrep -gtW byline```
   * ngrep 명령을 통해 HTTP 메세지를 손쉽게 캡처 및 분석할 수 있다.
   * -q : quiet 모드, 패킷 수신을 표시하는 #을 표시하지 않는다.
   * -t : timestamp를 표시한다.
   * -W : 덤프 포맷을 의미한다. normal, byline 등이 있다.
      * normal : 개행 부분을(\r\n) ..으로 표시한다.
      * byline : 개행 처리를 해준다.
   * ```ngrep -qtW byline | grep GET```
   * ngrep 명령과 GET 문자열 grep을 통해 얼마나 많은 GET 요청이 발생했는지 확인할 수 있다.
5. 패킷 캡쳐(도구: Wireshark)
   * Time 항목(초 단위)을 살펴보면 매우 짧은 시간 동안에 다량의 동일한 HTTP GET 요청이 Target 웹서버로 발생했음을 확인할 수 있다.
6. 정리하면 공격자가 웹서버에 다량의 HTTP GET 요청을 발생시키는 공격으로 웹서버가 해당 요청을 처리하기 위해 서버 자원을 과도하게 사용하도록 하여 부하를 유발시키는 서비스 거부 공격이다. ```cat access_log | grep "GET /home/index.php" | awk '{print $1}' | sort | uniq -c | sort -rn``` 명령어를 통해 access 로그 분석하거나 ```ngrep -qtW byline``` 명령어를 통해 패킷캡처를 할 수 있다.

#### (다) Hulk Dos 공격
1. 개요
   * HTTP GET Flooding 공격은 공격자가 동일한 주소 대한 HTTP GET 요청을 다량으로 발생시키지만, Hulk DoS 공격은 공격 대상 웹사이트 주소를 지속적으로 변경하면서 다량으로 GET 요청을 발생시키는 서비스 거부 공격이다.
   * 주소를 지속적으로 변경시키는 이유는 임계치(Threshold) 기반의 디도스 대응 장비를 우회하기 위함이다. 특정 자원에 접근하는 횟수를 제한하는 임계치 기반 디도스 대응 장비의 경우 주소가 계속 변경되면 서로 다른 주소로 인식하여 정상적인 차단이 불가능해진다.
2. 실습환경
   * Attack : 192.168.197.129 , Target : 192.168.197.133
   * 임의의 파라미터를 포함하는 URL(http://192.168.197.133/home/index.php?XXX=YYYY) 주소로 다수의 GET 요청 발생
3. 패킵 캡처(도구 : Wireshark)
   * 공격자의 HTTP 요청 URL 정보를 보면 파라미터를 계속 변경시키면서 다수의 요청을 발생시키고 있다. 주소에 대한 임계치 기반의 디도스 대응 장비의 경우 주소가 계속 변경되기 때문에 정상적인 차단이 불가능해진다.
4. 정리하면 HTTP GET Flooding 과 다른점은 파라미터의 값을 XXX=YYY 를 계속 변경시켜 다수의 GET 요청을 발생시켜 주소에 대한 임계치 기반의 디도스 대응 장비를 우회한다.

#### (라) Hash DoS 공격
1. 개요
   * 웹서버는 클라이언트 HTTP 요청을 통해 전달되는 파라미터를 효율적으로 저장하고 검색하기 위한 자료구조로 해시테이블을 주로 사용한다.
   * 공격자는 이러한 특성을 악용하여 조작된 많은 수의 파라미터를 POST 방식으로 웹서버로 전달, 웹서버는 다수의 해시 충돌이 발생하게 되고 결과적으로 정상적인 파라미터 조회 시 많은 CPU 자원을 소모하게 된다. 이러한 방식의 서비스 거부 공격을 Hash DoS 공격이라고 한다.
2. 실습환경
   * Attacler : 192.168.197.129 , Target : 192.168.197.133
   * 동일 URL(http://192.168.197.133/home/index.php)로 다량의 GET 요청 발생
3. 패킷 캡처(도구 : Wireshark)
   * 20번 패킷을 보면, 공격자가 POST 방식으로 데이터 전달을 요청하고 있다. 특히 Content-Length 헤더 필드를 보면 1375852 byte의 데이터 전달을 시도함을 알 수 있다.
   * 22번 패킷을 보면, 공격자가 요청 메시지 바디를 통해 전달하는 데이터를 볼 수 있다. 다수의 조작된 파라미터 정보가 보이고 있다.
   * 요청 파라미터 정보는 "파라미터명=파라미터값&(파라미터 구분자)"로 구성되어 있다.
   * 해당 TCP 연결에 대한 전체 스트림 정보를 살펴보면(Wireshark의 Follow TCP Stream 기능) 매우 많은 조작된 파라미터 정보가 전달되는 것을 확인할 수 있다.
4. 정리하면 HTTP POST는 매개변수의 수가 제한이 없기 때문에 공격자가 POST 방식으로 많은 매개변수를 웹서버에 보내어 Hash Table에 저장하여 Hash Table의 접근할 때 많은 자원 소모하여 서비스 거부 공격

### 7) Slow 계열 공격 유형 실습
#### (가) Slow HTTP Header DoS(Slowloris) 공격
1. 개요
   * HTTP 요청 메시지는 요청 라인, 요청 헤더, 빈 라인, 메시지 바디로 구성되어 있다. 개행은 CRLF(Carriage Return: 행의 맨 앞으로 이동, Line Feed: 다음 행으로 이동)를 의미하는 것으로 16진수 값으로 0x0d0a로 표현한다.
   * 요청 헤더를 보면 여러 헤더 필드들로 구성되어 있고 각 헤더 필드는 개행을 통해 구분된다. 마지막 헤더 필드에 대한 개행처리가 되고 나면 요청 헤더의 끝을 식별하기 위한 빈 라인이 추가된다.
   * 기본적으로 웹서버는 클라이언트의 HTTP 요청 메시지가 들어오면 먼저 요청 헤더부까지 모두 수신한 후 헤더 필드들을 분석하여 이후 메시지 바디부를 어떻게 처리할지 결정하게 되는데, 공격자는 이 부분의 취약점을 이용하여 공격을 수행할 수 있다.
   * 공격자가 만약 요청 헤더의 끝, 즉 빈 라인을 전달하지 않고 지속적으로 천천히 불필요한 헤더 필드 정보를 전달한다면 웹서버는 요청 헤더부를 모두 수신해야 요청 메시지 처리가 가능하기 때문에 이를 모두 수신할 때까지 연결 상태를 유지하면서 대기하게 된다. 이런 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원이 모두 소진되어 정상적인 요청을 받을 수 없는 상태가 된다.
   * 이와 같은 방식으로 HTTP 요청 헤더 정보를 조작해서 서비스 거부 공격을 수행하는 것을 Slow HTTP Header DoS, 일명 Slowloris 공격이라 한다. Slow 계열의 공격 특징 중의 하나는 기존의 다량의 트래픽을 발생시키는 DDoS 공격 기법과는 달리 웹서버와의 연결 상태를 지속시키는 방식이기 때문에 연결자원을 소진시킬 정도의 트래픽만을 필요하므로 저대역폭 공격이라는 특징이 있다.
2. 실습환경
   * Attacker : 192.168.197.129 , Target : 192.168.197.133
   * 공격 대상 URL : http://192.168.197.133/home/index.php
3. Target 측 패킷 캡처(도구: Wireshark)
   * 6번 패킷을 보면, HTTP 요청 메시지가 있음을 확인할 수 있다. "Content-Length:42"라는 헤더 필드와 개행(0x0d0a)이 보이면 빈 라인이 없기 때문에 웹서버 입장에서는 헤더 필드가 더 남아있을 것으로 판단하고 연결을 지속시키면서 다음 요청을 대기한다.
   * Time 항목을 보면 10초 간격으로 공격자가 요청정보를 보내는 것을 볼 수 있다. 1136번 패킷을 보면 'Pragma:13458'이라는 의미 없는 헤더 필드와 개행(0x0d0a)이 보이며 예상한 대로 빈 라인은 전송하지 않고 있다. 웹서버는 추가 헤더 필드가 있는 것으로 판단하고 연결을 지속하면서 대기한다.
   * 10초 간격의 2403번, 3222번 패킷을 보아도 동일하게 Pragma 헤더 필드만을 전송할 뿐 빈 라인은 전송하지 않으면서 연결을 지속시킨다.
   * 해당 TCP 연결에 대한 전체 스트림 정보를 살펴보면 의미 없는 pragma 헤더 필드만을 계속 전송하면서 빈 라인을 전송하지 않고 연결을 지속시키고 있음을 볼 수 있다.
4. 정리하면 HTTP 요청 메시지는 요청 라인, 요청 헤더, 빈 라인, 메시지 바디로 이루어져 있고, 요청 헤더를 다 수신하고 분석한 후 메시지 바디를 어떻게 할지 결정하는데, 요청헤더의 마지막에 개행문자(0x0d0a)를 2번 보내면 요청의 끝인데 개행문자 2번을 보내지 않아 지속적으로 연결되어 있는 상태로 저대역폭 공격이다.

#### (나) Slow HTTP POST DoS(RUDY) 공격
1. 개요
   * 클라이언트는 HTTP 요청을 통해 데이터를 웹서버로 전달하고자 할 때 POST 방식을 사용하고, 메시지의 유형과 크기 정보를 전달하기 위해 Content-Type 헤더 필드와 Content-Length 헤더 필드를 사용한다.
   * 기본적으로 웹서버는 Content-Type 헤더 필드를 참고해서 데이터의 유형을 파악하고, Content-Length 헤더 필드를 참고해서 데이터의 길이를 파악한 후 해당 데이터의 길이만큼 읽어 들이는 작업을 수행한다. 공격자는 이 부분의 취약점을 이용하여 공격을 수행할 수 있다.
   * 공격자는 Content-Length를 비정상적으로 크게 설정한 후 매우 소량의 데이터를 지속적으로 천천히 웹서버에 전송하면 웹서버는 Content-Length 헤더 필드에 명시된 크기만큼 데이터를 모두 수신하기 위해 연결 상태를 유지하면서 대기하게 된다. 이런 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원(가용량: 웹서버로 접속할 수 있는 최대 클라이언트 수)이 모두 소진되어 정상적인 요청을 받을 수 없는 상태가 된다.
   * 이처럼 POST 방식으로 데이터를 전송하면서 Content-Length 헤더 필드와 전송데이터를 조작해 서비스 거부 공격을 수행하는 것을 Slow HTTP POST DoS, 일명 RUDY 공격이라 한다.
2. 실습환경
   * Attacker : 192.168.197.129 , Target : 192.168.197.133
   * 공격 대상 URL : http://192.168.197.133/home/index.php
3. Target 측 패킷 캡처(도구: Wireshark)
   * 19번 패킷을 보면, POST 방식의 HTTP 요청 메시지가 있음을 확인할 수 있다. "Content-Length" 헤더 필드에 1000000 bytes라는 큰 값을 설정한 것이 보이고 "Content-Type" 헤더 필드를 마지막 헤더 필드로 하여 빈 라인이 추가된 것을 확인할 수 있다. 메시지 헤더부가 정상적으로 끝났기 때문에 Slowloris 공격과는 무관하다는 것을 예측할 수 있다.
   * 1000000 bytes라는 데이터를 전송한다고 했지만, 실제 전송데이터는 "A="만 전송하고 있으며 웹서버 입장에서는 아직도 수신할 데이터가 많이 남아있기 때문에 연결을 지속시키면서 다음 요청을 대기한다.
   * Time 항목을 보면 10초 간격으로 공격자가 요청정보를 보내는 것을 볼 수 있다. 1151번 패킷을 보면 여전히 1byte의 "A"라는 데이터를 전송하고 있다. 웹서버 입장에서는 1000000 bytes의 데이터를 모두 수신하기 위해 연결을 유지하면서 대기할 수밖에 없다.
   * 10초 간격의 2420번, 3236번, 4060번 패킷을 보아도 동일하게 "A"라는  1byte 데이터만을 전송하고 있다.
   * 해당 TCP 연결에 대한 전체 스트림정보를 살펴보면 Content-Length를 1000000 bytes로 설정했지만 실제로는 10초 간격으로 1byte씩 데이터(A)를 전달하여 연결을 지속시키고 있음을 볼 수 있다.
4. 정리하면 Content-Length 를 큰 값을 설정하고 1byte씩 보내어 웹서버는 content-Length 의 크기만큼 데이터를 수신해야 하기 때문에 연결을 유지하면서 대기시키는 공격이다.

#### (다) Slow HTTP Read DoS 공격
1. 개요
   * TCP의 흐름 제어(Flow Control)란 연결된 상호 간에 수신 가능한 양만큼만 데이터를 전송하는 제어방식을 의미한다. 즉, 수신 측의 수신 버퍼에 충분한 여유 공간이 없다고 송신 측에게 알려주면 송신 측은 수신측에서 여유 공간이 생겼다고 알려줄 때까지 대기함으로써 흐름 제어를 하게 된다.
   * TCP 헤더의 Windows 필드가 수신 측에서 수신 가능한 여유 공간의 크기를 담아서 송신 측에게 전달하는 헤더 필드이다. 만약 수신 측의 수신 버퍼에 여유 공간이 0이 되면 Windows 필드를 0으로 설정한 "Zero Window Packet"을 전달하고, 이를 수신한 송신 측에서는 일정 시간 대기후 수신측 상태를 확인하기 위한 "Zero Window Probe Packet"을 전달한다. 이를 수신한 수신 측에서는 여유 공간이 생겼다면 해당 공간의 크기만큼 Window 필드를 설정하여 응답하고 여전히 여유 공간이 없다면 "Zero Window Packet"으로 응답한다.
   * 공격자는 이러한 TCP 흐름 제어 특성을 이용해서 HTTP 요청을 보낸 후 Window 크기를 조작하여 0인 "Zero Window Packet"을 지속적으로 서버 측에 전달하여 서버가 요청에 대한 응답메시지를 전송하지 못하고 연결을 지속적으로 유지하도록 한다. 이런 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원(가용량: 웹서버로 접속할 수 있는 최대 클라이언트 수)이 모두 소진되어 정상적인 요청을 받을 수 없는 상태가 된다.
   * 공격자가 TCP 흐름 제어를 이용해서 요청에 대한 응답을 느리게 READ 하여 서비스 거부 공격을 수행하는 것을 Slow HTTP Read DoS 공격이라 한다.
2. 실습환경
   * Attacker : 192.168.197.134 , Target : 192.168.197.133
   * 공격 대상 URL : http://192.168.197.133/home/index.php
3. Target 측 패킷 캡처(도구: Wireshark)
   * 41번 패킷을 보면, TCP 헤더의 Window 필드가 0로 설정되어 있음을 확인할 수 있다. 웹서버에서 "Zero Window Packet"을 수신하게 되면 클라이언트의 수신버퍼에 여유 공간이 없다고 판단하여 연결을 유지하면서 응답 데이터 전송을 대기한다.
   * 322번 패킷을 보면, 웹서버는 일정 시간 대기후 클라이언트의 수신 버퍼 여유 공간을 확인하기 위한 "Zeor Window Probe Packet"을 보내고 클라이언트는 여전히 여유 공간이 없다는 "Zero Window Packet"으로 응답하고 있다.
4. 정리하면 Slow HTTP Read DoS 공격은 TCP 흐름 제어의 특성을 이용하는 공격이다. Windows 필드를 0으로 설정한 Zero Window Pakcet을 전송하면 서버는 일정 시간 대기후 Zero Window Probe Packet을 전송하여 다시 한번 크기를 확인한다. 지속적으로 Zero Window Packet을 서버에 전달하여 연결을 지속적으로 유지하여 서비스 거부 공격을 한다.

#### (라) Slow HTTP Header/POST 공격 대응책
1. 동시 연결에 대한 임계치 설정을 통한 찬다
   * 동일한 출발지 IP에서 동시에 연결할 수 있는 연결개수에 대한 임계치(Threshold)를 설정한다.
   * iptables 방화벽을 이용한다면 다음과 같은 룰 설정이 가능하다.
   * ```iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP``` : 30개 초과 동시 연결에 대해 차단
2. 연결 타임아웃 설정을 통한 차단(Apache 서버 예)
   * \<Apache httpd.conf\> 중 일부
   * ```Timeout 120```
   * 클라이언트와 웹서버 간에 아무런 데이터 송수신 없이 세션을 유지하는 시간에 대한 타임아웃을 설정하여 연결을 종료한다.
   * Apache 웹서버의 경우 httpd.conf의 Timeout 지시자를 120(default)에서 작은 값(5 추천)으로 설정한다. 설정값은 환경에 따라 적절한 값 설정한다.
   * 공격자가 방어 정책을 우회하기 위해 데이터 전송 주기를 짧게 가져갈 수 있으므로 이 방안에는 일정한 한계가 있다. 또 너무 작은 Timeout을 설정하면 정상적인 서비스에 영향을 줄 수도 있다.
3. 읽기 타임아웃 설정을 통한 차단(Apache 서버 예)
   * \<Apache httpd.conf\> 중 일루
   ```
   <IfModule reqtimeout_module>
      RequestReadTimeout header=5 body=10
   </IfModule>
   ```
   * Apache 2.2.15버전 이상에서 클라이언트의 요청에 대한 더욱 세부적인 제한을 줄 수 있다. 요청 헤더와 바디 각각에 대하여 타임아웃을 지정하여 지정한 시간 내에 read를 완료하지 못하면 클라이언트에게 오류코드를 반환한다.
   * 위 설정을 살펴보면 요청 헤더 정보가 5초 이내에 모두 수신되지 않거나(Slow HTTP Header 공격 대응:개행문자(0x0d0a)) 요청 바디 정보가 10초 이내에 모두 수신되지 않으면(Slow HTTP POST 공격 대응:content-Length) 오류 응답한다.
4. 정리하면 임계치 설정(```iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 30 -j DROP```, 연결 타임아웃 설정, 읽기 타임아웃 설정(헤더 정보가 5초이내 수신되지 않거나, 바디 정보가 10초 이내 모두 수신되지 않거나)

# 14. DRDoS(Distributed Reflected DoS)
### 1) 개요
1. 공격자는 출발지 IP를 공격대상 IP로 위조(IP Spoofing)하여 다수의 반사서버로 요청정보를 전송, 공격대상은 반사서버로부터 다수의 응답을 받아 서비스 거부 상태가 되는 공격유형을 말한다.
2. DRDoS공격은 다양한 형태로 나타날 수 있다. 몇 가지 유형을 살펴보면 다음과 같다.
   * TCP의 연결설정과정의 취약점을 이용, 위조된 출발지 주소의 SYN 패킷을 반사서버로 전달하여 SYN+ACK 응답패킷이 공격대상으로 향하도록 하는 방법
   * ICMP 프로토콜의 Echo Request와 Echo Reply를 이용, 위조된 주소의 Echo Request를 반사서버로 전달하여 Echo Reply가 공격대상으로 향하도록 하는 방법
   * UDP 프로토콜 서비스를 제공하는 서버를 반사서버로 이용하여 그 응답이 공격대상으로 향하도록 하는 방법
3. UDP 프로토콜을 사용하는 DNS, NTP, SNMP, CHARGEN 등의 서비스를 이용한 DRDoS 공격은 크게 반사(Reflection)와 증폭(Amplification) 공격 형태로 나타난다. 공격자는 출발지 IP를 공격대상 IP로 위조하여 취약한 서비스를 사용하는 서버에 대규모의 메시지를 보내고, 서버는 요청에 대한 응답메시지를 공격대상 IP에 반사 시도를 한다. 이때 반사된 응답메시지는 대량의 트래픽으로 증폭되어 공격 대상에게 전달된다.
   1. DNS 증폭 DRDoS 공격
      * DNS 서버(반사서버 역할)에 많은 양의 레코드 정보를 요구하는 DNS 질의타입(ANY, TXT 등)으로 요청하여 공격대상에게 대량의(증폭된) 응답 트래픽을 유발시킨다.
   2. NTP 증폭 DRDoS
      * NTP 서버(반사서버 역할)에 최근 접속한 클라이언트 목록(monlist 명령)을 요청하여 공격대상에게 대량의 응답 트래픽(증폭)을 유발시킨다.
   3. SNMP 증폭 DRDoS 공격
      * SNMP Agent(반사서버 역할)에 MIB와 같은 정보를 대량 요청(GetBulkRequest)하여 공격대상에게 대량의(증폭된) 응답 트래픽을 유발시킨다.
   4. CHARGEN 증폭 DRDoS 공격
      * CHARGEN 서버(반사서버 역할)에 접속하여 공격대상에게 대량의(증폭된) 문자열 응답 트래픽을 유발시킨다.

### 2) 공격방법 1 : TCP 기반 DRDoS 공격
#### (가) 개요
1. TCP 연결설정과정의 취약점을 이용한 디도스 공격
2. TCP 서버(e.g. 인터넷에 공개된 웹서버(HTTP/HTTPS), 메일서버(SMTP) 등)를 반사서버로 이용하는 공격으로 출발지 주소를 희생자의 IP로 위조한 후 다수의 연결 요청 패킷을 전송, 증폭된 대량의 SYN+ACK 응답 패킷이 희생자에 전달되어 서비스 거부 상태를 유발시킨다.
   * **(증폭되는 이유) SYN+ACK 패킷에 대한 응답이 없을 경우 TCP 동작 구조상 재전송을 다수 수행하기 때문에 응답이 증폭**된다.

#### (나) 공격 절차
1. 공격자는 출발지 IP를 희생자 IP로 위조한 후 대량의 SYN 패킷을 반사서버로 전송한다.
2. SYN 패킷을 받은 반사서버는 위조된 출발지 IP로 정상적인 SYN+ACK 응답 패킷을 다수 전송한다.
3. 희생자는 요청하지 않은 대량의 SYN+ACK 응답 패킷을 반사서버로부터 받아 서비스 거부 상태가 된다.

### 3) 공격방법 2 : DNS 증폭 DRDoS 공격
#### (가) 개요
1. DNS 서버(일반적으로 공개된 Recursive/Cache DNS 서버)를 반사서버로 이용하는 디도스 공격
2. **출발지 주소를 희생자의 IP주소로 위조한 후 요청 대비 응답이 큰 DNS 질의 타입(ANY 타입, TXT 타입)을 다수 요청**하여 희생자에 대량의 트래픽을 유발시킨다.

#### (나) 공격 절차
1. 공격자는 증폭된 DNS 응답이 희생자 서버로 전달될 수 있도록 출발지 IP를 희생자 IP로 위조한 ANY 타입 또는 TXT 타입 질의를 DNS 서버에 다수 요청한다.
2. DNS 서버는 다수의 DNS 질의에 응답을 위조된 출발지 IP인 희생자에 응답한다.
3. 희생자는 요청하지 않은 대량의 DNS 응답을 받아 서비스 거부 상태가 된다.
4. DNS 증폭 공격 시 주로 사용하는 IP 기반 공격기법과 그 이유
   * **IP 스푸핑 공격** : 출발지 IP 주소를 희생자 IP 주소로 위조
   * **요청에 대한 응답이 희생자 쪽으로 향하도록** 하기 위함이다.
5. DNS 증폭 공격 시 주로 사용하는 DNS 질의 유형과 그 이유
   * **ANY 타입 또는 TXT 타입** 질의
   * **요청 대비 응답이 매우 크기 때문**에 증폭 공격을 효과적으로 할 수 있다.

#### (다) 패킷 덤프 예시 1 : tcpdump 결과 화면
1. 위 예는 반사서버로 사용된 DNS 서버에 유입된 트래픽에 관한 정보이다. 위 정보를 통해 다음 사실을 확인할 수 있다.
   * DNS 서버 주소 : 192.168.56.100(목적지 포트가 53번 포트인 것으로 볼 때 DNS 서버임을 알 수 있다.)
   * 희생자(공격 대상 서버) 주소 : 10.10.10.10(출발지 포트는 동적으로 부여되므로(dynamic port) 다양하다.)
   * 질의 도메인 및 유형 : algisa.com 도메인에 대한 **ANY 타입(질의한 도메인과 일치하는 모든 레코드 정보를 반환하는 타입) 질의**
2. 트랜잭션 ID : DNS 질의와 해당 응답을 식별하기 위해 부여한 ID
   * (예시) 58361+ : 트랜잭션 ID가 58361이고 DNS 질의(+)를 의미
   * (예시) 58361* : 트랜잭션 ID가 58361이고 DNS 응답(*)를 의미

#### (라) 패킷 덤프 예시 2 : wireshark 결과 화면
1. 위 예는 반사서버로 사용된 DNS 서버에 유입된 트래픽에 관한 정보이다. 위 정보를 통해 다음 사실을 확인할 수 있다.
   * DNS 서버(반사 서버) 주소 : 192.168.56.100(목적지 포트가 53번 포트인 것으로 볼 때 DNS 서버임을 알 수 있다.)
   * 희생자(공격 대상 서버) 주소 : 10.10.10.10(출발지 포트는 동적으로 부여되므로(dynamic port) 다양하다.)
   * 질의 도메인 및 유형 : algisa 도메인에 대한 **TXT 타입(질의한 도메인의 텍스트 레코드 정보(TXT 레코드 정보)를 반환하는 타입으로 대표적인 텍스트 정보에는 SPF(발송자 메일서버 인증) 정보가 있음) 질의**
2. 위 예에서 요청(질의) 및 응답 데이터의 크기(Length 필드)를 살펴보면 요청 데이터의 크기는 47byte이고 응답 데이터의 크기는 1,891byte임을 알 수 있다. 즉, 요청 대비 응답이 증폭되어 매우 큰 것을 볼 수 있다.

### 4) DRDoS 공격과 일반적인 DoS(DDoS) 공격과의 차이점
1. DRDoS 공격은 일반적인 DoS 공격에서 더 발전된 공격 형태로 봇넷 기기들이 직접 공격을 수행하는 것이 아니라 **증폭 및 반사 공격에 활용되는 서비스를 제공하는 서버를 공격 기기로 이용**한다.
2. DRDoS 공격은 출발지 IP주소를 희생자 주소로 위조하고 다수의 반사 서버를 경유하기 때문에 **공격 근원지를 파악하는 것이(역추적하는 것이) 어렵다.**
3. DRDoS 공격은 요청(질의) 대비 응답이 크기 때문에(증폭되기 때문에) **공격 트래픽 효율이 증가한다.**
4. 따라서 공격자 입장에서 일반적인 DDoS 공격보다 DRDoS 공격을 선호하는 이유를 정리해보면 다음과 같다.
   * 공격의 근원지 파악이 어렵기 때문에 기기들이 노출될 가능성이 낮아진다.
   * 공격자의 요청 대비 응답이 크기 때문에 공격 트래픽 효율이 증가한다.
  
### 5) 대응방법
1. DRDoS 공격은 출발지 IP를 위조하는 공격이므로 IP 주소가 위조된 패킷이 인터넷망에 인입되지 않도록 인터넷 서비스 제공자(ISP:Internet Service Provider, 통신사)가 직접 차단(주로 Ingress Filtering 기법 적용)한다. **IP 스푸핑에 대응할 수 있는 라우터(패킷 필터링 장비)의 주요 기법**을 정리해보면 다음과 같다.
   * **Ingress 패킷 필터링** 기법 : 라우터를 이용하여 외부에서 내부 네트워크로 들어오는 패킷에 대해 출발지 IP를 체크하여 외부에 존재할 수 없는 IP(사설 IP, 루프백 IP 등 인터넷상에서 사용되지 않는 IP 대역이 대표적)를 필터링한다. ISP의 경우 연결된 사용자(기관/회사 등)에 할당한 IP 대역 이외의 출발지 IP로 들어오는 IP를 체크하여 위조 여부를 판단할 수 있다.
   * **Egress 패킷 필터링** 기법 : 라우터를 이용하여 내부에서 외부 네트워크로 나가는 패킷에 대해 출발지 IP를 체크하여 내부에서 관리하고 있는 IP 주소가 아니라면 위조된 주소로 판단하여 필터링한다.
   * **Unicast RPF(Reverse Path Forwarding)** 기법 : 라우터로 유입된 패킷의 출발지 IP에 대해 라우팅 테이블을 이용하여 유입된 인터페이스로 다시 전송되는지 여부를 체크(역경로(Reverse Path)가 존재하는지 체크)하여 유입된 인터페이스로 다시 전송되지 않는다면 위조된 주소로 판단하여 필터링한다.
2. ICMP 프로토콜을 이용하는 DRDoS 공격에(e.g. 스머프 공격) 반사서버로 악용되지 않도록 다음과 같이 대응한다.
   * ICMP 프로토콜을 사용할 필요가 없는 시스템의 경우 시스템 설정을 통해 해당 프로토콜을 차단한다.
   * 네트워크 보안 장비를 이용하여 사용할 필요가 없는 ICMP 패킷을 차단한다.
3. **DNS 증폭 DRDoS 공격의 반사서버로 DNS 서버가 악용되지 않도록 다음과 같이 대응**한다.
   * 공개용이 아닌 내부 사용자용 DNS 서버라면 서버 설정을 통해 내부 사용자 주소만 DNS 질의(Reverse Query(재귀 쿼리))가 가능하도록 제한한다.
   * DNS 서버의 서버방화벽(e.g. IPTABLES) 또는 네트워크 보안 장비 등을 이용하여 동일 출발지 IP에 대해 단위 시간(초)당 요청 개수 제한을 설정(임계치 설정)하거나 특정 바이트(byte) 이상의 DNS 응답을 차단하도록 설정한다.
4. 정리하면 DRDoS는 공격자는 출발지 IP를 공격대상 IP로 스푸핑하여 다수의 반사서버로 요청정보를 전송, 공격대상은 반사서버로부터 다수의 응답을 받아 서비스 거부 상태가 되는 공격유형이다. TCP의 연결설정과정 취약점을 이용한 위조된 출발지 주소의 SYN 패킷을 반사서버로 전달하여 SYN+ACK 응답패킷이 공격대상으로 향하도록 하는 방법(SYN+ACK 패킷에 대한 응답이 없을 경우 TCP 동작 구조상 재전송을 다수 수행하기 때문에 응답 증폭), 위조된 주소의 ICMP Echo Request를 반사서버로 전달하여 Echo Reply가 공격대상으로 향하도록 하는 방법, DNS 서버에 많은 양의 레코드 정보를 요구하는 DNS 질의타입(ANY, TXT 등(질의 대비 응답이 매우크 크기 떄문에 증폭 공격 효과적))으로 요청하여 공격대상에게 대량의 응답 트래픽(DNS 증폭 DRDoS 공격), NTP 서버에 최근 접속한 클라이언트 목록(monlist 명령)을 요청하여 공격대상에게 대량의 응답 트래픽(NTP 증폭 DRDoS 공격), SNMP Agent에 MIB와 같은 정보를 대량 요청(GetBulkRequest)하여 공격대상에게 대량의 응답 트래픽(SNMP 증폭 DRDoS 공격), CHARGEN 서버에 접속하여 공격대상에게 대량의 문자열 응답 트래픽(CHARGEN 증폭 DRDoS 공격), DDoS(DoS) 공격보다 DRDoS 공격을 사용하는 이유는 공격의 근원지 파악이 어렵기 때문이고 공격자의 질의 대비 응답이 크기 때문에(증폭되기 때문에) 공격 트래픽 효율이 증가하기 때문이다. 대응방법으로는 인터넷 서비스 제공자(ISP)가 직접 차단하거나, 라우터의 기법에는 Ingress(외부에서 내부 네트워크로 들어오는 패킷에 대해 출발지 IP를 체크하여 외부에 존재할 수 없는 IP를 필터링한다.), Egress(내부에서 외부 네트워크로 나가는 패킷에 대해 내부에서 사용하고 있는 IP주소가 아니라면 필터링한다.), Unicast RPF(유입된 인터페이스로 다시 전송되는지 여부를 체크(reverse Path)가 존재하는지 체크하여 필터링한다.), ICMP 프로토콜을 사용할 필요가 없는 경우 시스템 설정을 통해 차단하거나 네트워크 보안 장비를 이용하여 ICMP 패킷 차단한다. DNS 증폭 DRDoS 공격의 악용 방지는 공개용이 아닌 내부 사용자용 DNS 서버라면 서버 설정을 통해 내부 사용자 주소만 DNS 질의가 가능하도록 제한하거나 DNS 서버의 서버방화벽 또는 네트워크 보안 장비 등을 이용하여 동일 출발지 IP에 대해 단위 시간(초)당 요청 개수 제한을 설정하거나 특정 바이트 이상의 DNS 응답을 차단하도록 설정한다.

# 15. 무선랜(Wireless LAN) 보안
## (1) 무선랜 개요

|무선랜표준|표준 제정시기|주파수대역|데이터속도(최대)|서비스범위(실내~외부)|
|:-:|:-:|:-:|:-:|:-:|
|802.11|1997|2.4 GHz|2 Mbps|20~100M|
|802.11a|1999|5 GHz|54 Mbps|35~120M|
|802.11b|1999|2.4 GHz|11 Mbps|38~140M|
|802.11g|2003|2.4 GHz|54 Mbps|38~140M|
|802.11n|2009|2.4 ~ 5 GHz|300 Mbps|70~250M|

1. 무선랜에 관한 기술 표준은 국제표준기구인 IEEE에서 802.11 계열 표준으로 규정하고 있으며 무선랜 관련 장비들은 이 표준을 준수하고 있다.
2. 무선랜 활성화를 위해 설립된 와이파이연합(Wi-Fi Alliance)에서 무선 제품에 관한 기술 인증을 수행하고 인증에 통과한 제품에 대해 Wi-Fi 인증마크를 부여하고 있다. 따라서 무선랜과 와이파이 용어가 혼용되어 사용되고 있다.
3. 무선랜은 기존 유선랜의 확장 개념에서 가정 또는 일반 사무실 환경에서 사용되는 경우가 대부분이다. 기존 유선랜에 무선AP를 연결한 후 클라이언트에 무선 랜카드를 장착하여 접속하는 형태로 구성되어 있다.

## (2) 무선랜 환경 및 보안 취약점
### 1) 무선랜 환경
#### (가) 무선랜은 구축 주체, 관리 주체, 이용 주체 등과 같은 요소에 따라 상용 무선랜 환경, 공중 무선랜 환경, 사설 무선랜 환경, 기업 무선랜 환경으로 구분할 수 있다.
#### (나) 무선랜 환경별 특징을 살펴보면 다음과 같다.
1. 상용 무선랜 환경
   * 이동통신사가 고객 서비스용으로 구축한 무선랜 환경으로 자사 고객 인증을 위해 USIM(Universal Subscriber Identity Module), MAC(Media Access Control), ID/Password 등을 이용한다.
2. 공중 무선랜 환경
   * 공공기관, 호텔, 카페 등과 같은 서비스 업종에서 불특정 다수의 고객 편의를 위해 제공하는 무선랜 환경으로 대부분 소규모 환경에서 별도의 보안 관리자 없이 운영하므로 보안에 취약한 환경이다.
3. 사설 무선랜 환경
   * 일반 사용자가 무선 공유기를 통해 구축한 무선랜 환경으로 무선 공유기에서 제공하는 여러 보안기술을 이용할 수 있지만 보안 설정에 대한 인식 부족 등으로 인해 취약점이 발생할 수 있다.
4. 기업 무선랜 환경
   * 기업이 내부 업무용으로 구축한 무선랜 환경으로 최근 스마트폰을 이용한 스마트 오피스, 스마트 워크 등의 도입이 확산함에 따라 구축사례가 증가하고 있ㄲ다.

### 2) 보안 취약점
#### (가) 물리적인 취약점
1. 무선 AP의 외부 노출
   * 무선AP는 일반적으로 외부에 노출된 형태로 위치하기 때문에 비인가자에 의한 장비의 파손, 리셋을 통한 설정 초기화 등의 문제가 발생할 수 있다.
2. 무선 단말기의 분실위험 및 정보 유출
   * 이동성을 가진 무선 단말기는 항상 분실의 위험성이 존재하며 분실 시 저장 데이터 유출 및 무선랜 내부 보안 설정이 함께 유출될 가능성이 있다.
  
#### (나) 기술적인 취약점
1. 암호화하지 않은 통신 데이터에 대한 도청
   * 무선랜은 공기를 전송매체로 하여 브로드캐스트하는 특성을 가지고 있기 때문에 도청/스니핑에 매우 취약하다.
2. 무선전파 전송 장비에 대한 서비스 거부 공격(DoS)
   * 무선AP 장비에 대량의 무선 패킷을 전송하는 서비스 거부 공격을 통해 무선랜을 무력화하거나 무선랜이 사용하는 주파수 대역에 방해전파를 방사하여 통신에 영향을 줄 수 있다.
3. 비인증 AP(Rogue AP)를 통한 전송 데이터 수집
   * 공격자가 불법적으로 무선AP를 설치하여 무선랜 사용자들의 접속을 유도, 사용자 개인정보 등 전송 데이터를 수집할 수 있다.

#### (다) 관리적인 취약점 
1. 무선AP 장비에 대한 관리 미흡
   * 무선AP 장비에 대한 관리 소홀로 인해 장비가 파손되거나 도난당하여 무선랜 서비스를 제공하지 못하고 있어도 이를 파악하지 못하는 경우가 발생할 수 있다.
2. 사용자의 보안 의식 부족
   * 무선랜 보안정책과 보안 기능을 사용하지 않는 사용자가 있으면 전체 서비스의 보안에 허점이 발생할 수 있으며 보안 기능을 설정하지 않은 사용자는 공격자의 표적이 될 수 있다.
3. 전파 출력 관리 부족
   * 무선AP의 전파 출력 조정을 하지 않아 기관 외부로 무선랜 전파가 유출되는 경우 공격자는 전파 정보를 수집하여 취약점을 파악하고 이를 이용해 공격할 수 있다.
  
## (3) 주요 용어 설명
### 1) SSID : Service Set Identifier
1. 무선랜을 구분하기 위한 32byte 이름으로 서로 다른 무선랜을 식별하기 위한 용도로 사용한다.
2. 무선 장비(노트북, 스마트폰 등)에서 Wi-Fi를 활성화했을 때 나오는 무선랜 목록이 바로 SSID를 의미한다.

### 2) BSS : Basic Service Set
1. 무선랜의 가장 기본적인 망 구성단위로 특정 무선AP와 AP에 연결된 스테이션들이 결합된 놀리적인 망을 의미한다.
2. 무선AP(Access Point) : 무선 인터넷에 접속하기 위한 지점으로 유선랜의 마지막에 위치하여 무선랜과 유선랜의 연결을 중계해주는 장치를 말한다. 흔히 무선 공유기라고 말하는 장비가 무선AP에 해당한다.
3. 스테이션(Station) : 무선AP에 연결되는 노트북, 스마트폰, 태블릿PC 등 무선 장비를 말한다.

### 3) BSSID : Basic Service Set Identifier
1. BSS를 식별하기 위한 ID로 일반적으로 무선AP의 48bit MAC 주소를 사용한다.

### 4) ESS : Extended Service Set
1. 여러 BSS에 의해 구성된 네트워크로 무선 AP를 모두 엮는 논리적인 하나의 커다란 집합을 의미한다.

### 5) ESSID : Extended Service Set Identifier
1. ESS를 식별하기 위한 ID로 복수의 무선 AP를 설치한 무선랜 환경에서 사용가능한도록 SSID를 확장한 무선랜 이름이다.

### 6) DS : Distribution System
1. 무선 AP가 연결된 유선 네트워크를 의미한다. 스테이션이 통신할 때 무선AP 이후에 반드시 유선을 거쳐 통신하기 때문에 DS의 역할이 중요하다.

### 7) 비콘(Beacon) 프레임/메시지
1. 무선AP가 자신이 관리하는 무선랜(BSS)의 존재를 정기적으로 알리는 브로드캐스트 프레임/메시지로 스테이션으로 하여금 무선 네트워크를 찾도록 도와주는 역할을 수행한다.
2. IEEE 802.11 관리 프레임중 하나로 비콘 프레임을 보면 BSSID 정보가 들어 있으며 프레임 바디에는 SSID 정보가 들어있다.

## (4) 무선랜 보안 메커니즘
### 1) 개요
1. 무선랜 통신 방식은 공기를 전송매체로 하여 브로드캐스트하는 특성을 가지고 있기 때문에 무선AP의 비콘 프레임/메시지를 수신할 수 있는 범위 내에서는 무선 패킷을 도청/스니핑하고 위변조할 수 있는 문제점이 존재한다.
2. 따라서 안전한 무선랜 환경을 구축하기 위해서는 무선 패킷에 대한 기밀성과 무결성을 보장하기 위한 **무선전송 데이터 암호기술과 통신 상대방에 대한 신뢰성을 확인하기 위한 무선랜 접속 인증기술**이 필요하다.
3. 최초 무선랜 표준안인 IEEE 802.11에서는 별도의 무선랜 접속 인증기술과 전송 데이터 암호기술이 포함되지 않았기 때문에 인증절차 없이 접속이 가능하였고 평문 데이터가 전송되었다.
4. 1999년 제정된 IEEE 802.11b 표준부터는 무선전송 데이터 암호화와 인증을 제공하기 위해 **WEP(Wired Equivalent Privacy)** 보안규격을 규정하였으나 다양한 공격기법에 의해 WEP 취약성이 발견됨에 따라 이를 보완하기 위한 보안표준인 IEEE 802.11i가 제정되었다.
5. 2004년 제정단 IEEE 802.11i 표준은 **WPA(또는 WPA1), WPA2(Wi-Fi Protected Access)** 보안규격을 규정하여 보다 강화된 사용자 인증방식, 키 교환 방식 및 향상된 무선구간 암호 알고리즘을 제공하고 있다.

### 2) 무선랜 인증 및 전송 데이터 암호화 기술 정리

|보안 기술 유형|보안 기술|
|:-:|:-|
|무선랜 접속 인증 기술|SSID 숨김 설정을 통한 접속 제한 </br>MAC 주소 인증(MAC 주소 필터링) </br>공유키 인증(PSK:Pre-Shield Key) </br>IEEE 802.1x/EAP(인증서버 이용)|
|무선전송 데이터 암호기술|WEP(Wired Equivalent Privacy) </br>WPA1, WPA2(Wi-Fi Protected Access)|

## (5) WEP(Wired Equivalent Privacy) 보안 기술
### 1) 개요
1. "유선랜과 동등한 수준의 보안성 제공" 목적으로 만들어진 초기 무선랜 보안기술로 IEEE 802.11b 표준에서부터 적용되었으며 데이터 암호화와 사용자 인증, 두 가지 기능을 모두 제공한다.
2. WEP는 **고정된 공유키와 무작위로 생성한 초기벡터(IV:Initial Verctor)를 조합한 키를 이용한 RC4 알고리즘 기반의 데이터 암호화**를 제공하고 서로 같은 공유키를 갖는 사용자들은 정상적인 사용자로 인증하여 통신하는 공유키 인증방식을 제공한다.
3. RC4 기반 암호 알고리즘 자체 취약점과 인증 및 암호화에 사용되는 WEP 공유키가 쉽게 추출될 수 있는 취약점 등으로 인해 사용을 권장하지 않는다.

### 2) 암호 기술
#### (가) 암호화 동작방식
1. 무작위로 생성하는 24bit 초기벡터와 고정된 40bit 또는 104bit의 WEP 공유키를 조합하여 WEP 암호키를 생성한 후 RC4 암호알고리즘을 기반으로 한 난수발생기(PRNG:Pseudo Random Number Generator)에 입력하여 스트림 암호를 위한 키스트림을 생성한다.
2. 평문의 무결성을 보장하기 위해 CRC-32 알고리즘을 이용하여 무결성 체크값(ICV:Integrity Check Value)을 생성한 후 평문과 조합한다.
3. 평문과 ICV를 합친 데이터와 키스트림을 XOR하여 암호문을 생성한다.
4. 생성된 암호문에 초기벡터와 802.11 표준에서 사용하는 헤더를 추가하여 최종적으로 전송하고자 하는 패킷을 구성한다.
5. 무작위 24bit IV 와 WEP 공유키(40bit or 104bit) 조합하여 WEP 암호키 생성한 후 RC4 암호알고리즘 PRNG로 키스트림 생성, CRC-32 알고리즘을 이용하여 무결성체크값 ICV 생성 후 평문과 조합하고 키스트림과 XOR하여 암호문을 생성한 후 IV와 802.11 표준에서 사용 헤더를 추가하여 전송 패킷 생성

#### (나) 복호화 동작방식
1. 송신자가 보낸 패킷에서 IV를 추출하고 이를 자신이 갖고 있는 WEP 공유키와 조합하여 난수발생기(PRNG)를 통해 키스트림을 생성한다.
2. 암호문을 키스트림과 XOR하여 평문과 ICV를 생성한다.
3. 복호화된 평문의 무결성 체크를 위해 CRC-32 알고리즘을 이용하여 ICV를 구한 후 복호화된 ICV와 비교하여 패킷 무결성 여부를 검사한다.
4. 무결성 체크가 성공적으로 이루어지면 최종적으로 평문 데이터를 수신한다.
5. 송신자의 패킷에서 IV를 추출하고 자신이 갖고 있는 WEP 공유키(40bit or 104bit)와 조합하여 RC4 알고리즘 PRNG를 통해 키스트림을 생성 암호문을 키스트림과 XOR하여 평문과 ICV를 생성 후 CRC-32 알고리즘을 이용하여 ICV를 구한 후 무결성 체크 후 성공적이면 평문 데이터를 수신

#### (다) WEP 암호화/복호화 문제점
1. 통신과정에서 초기벡터(IV)는 무작위로 생성되지만 24bit의 짧은 길이를 사용하기 때문에 IV값이 재사용될 가능성이 높다.
   * IV 재사용으로 인해 동일한 키스트림으로 암호화된 암호문이 존재하고 어느 한 암호문의 평문을 알고 있다면 공격자는 암호키를 알지 못해도 평문을 알고 있는 암호문을 이용해 다른 암호문을 복호화할 수 있다.
   * 가정) 2개의 평문 (P1, P2)에 대하여 동일한 키스트림(KS)을 이용하여 암호문 (C1, C2)이 생성되었다고 가정할 경우(+: XOR 연산), C1 + C2 = (P1 + KS) + (P2 + KS) = P1 + P2 공격자가 평문 P1을 알고있다면 다음과 같은 방식으로 암호문을 복호화할 수 있다. C1 + C2 + P1 = P2
2. 불완전한 RC4 알고리즘 사용으로 인해 암호키 노출 가능성이 높다.
   * RC4 암호 알고리즘의 키 스케줄링 알고리즘과 IV 사용법의 취약점으로 인해 암호키가 노출되는 문제점이 공개됨
3. 짧은 길이의 암호키 사용으로 인한 공격 가능성이 높다.
4. 암호키 노출로 인해 무선전송 데이터의 노출 위험성이 높다.
5. 24bit 짧은 IV으로 인해 재사용 가능성 높고 불완전한 RC4 알고리즘 사용으로 인해 암호키 노출 가능성 높고, 짧은 길이의 암호키 사용으로 인한 공격 가능성이 높고, 암호키 노출로 인해 데이터 노출 위험성이 높다.

### 3) 인증 기술
#### (가) 동작방식
1. 무선단말은 무선AP에 연결요청 메시지를 전송
2. 연결요청 메시지를 받은 무선AP는 임의의 문장(Challenge)을 생성하여 원본을 저장하고 연결요청응답 메세지를 이용하여 그 사본을 전달
3. 연결요청응답 메시지를 받은 사용자는 무선AP가 보내온 임의의 문자(Challenge)를 자신이 가지고 있는 WEP 공유키를 이용하여 암호화한 후 암호문을 무선AP에 전송
4. 암호문을 전송받은 무선AP는 자신의 공유키로 복호화한 후 원본 문장과 비교하여 동일한 경우 무선단말로 인증
5. 정리하면 무선단말이 무선AP에 연결요청 메세지를 전송하면 무선AP는 임의의 문장을 생성하여 원본 저장 후 연결요청응답 메세지에 그 문장 사본을 전달하고 무선단말기는 그 문장 사본을 WEP 공유기로 암호화하여 전송 무선AP는 암호화된 문장을 WEP 공유키로 복호화하여 인증 후 연결 허용

#### (나) WEP 인증 문제점
1. 단방향 인증방식 제공으로 인한 취약성이 존재한다.
   * 무선AP에서 사용자를 인증하는 단방향 인증방식을 사용하므로 사용자 입장에서는 악의적으로 설치된 불법 AP인지 알 수 없기 때문에 피해가 발생할 수 있다.
2. 고정된 공유키 사용으로 인한 취약성이 존재한다.
   * 무선랜을 사용하는 모든 장비가 동일한 WEP 공유키를 사용하기 때문에 외부로 유출될 경우 많은 문제가 발생한다.
   * 위험 요소를 줄이기 위해 WEP 공유키를 주기적으로 변경해야 하지만 무선랜을 사용하는 장비가 많을 경우에는 각각 설정해야 하는 어려움이 발생한다.
3. 정리하면 무선단말기만 무선AP에서 인증을 하기 때문에 불법AP인지 확인 불가능, 무선랜을 사용하는 모든 장비가 동일한 WEP를 사용하기 때문에 하나만 유출되도 모든 공유키를 사용하는 무선단말기가 문제된다. WEP 공유키를 주기적으로 변경하면 위험 요소를 줄이지만 무선랜을 사용하는 장비가 많을 경우에는 각각 설정해야 하는 어려움이 발생한다.

## (6) IEEE 802.11i 보안 표준
### 1) 개요

|802.11i 표준|WPA|WPA2|
|:-:|:-|:-|
|암호방식|RC4-TKIP(Temporal Key Integrity Protocol|AES-CCMP(Counter mode with CBC-MAC Protocol)|
|인증방식|개인|PSK(Pre-Shared Key) 모드|
||기업|802.1x/EAP(Extensible Authentication Protocol) 모드|

1. IEEE 802.11i 표준은 초기 무선랜 보안 규격인 WEP의 취약성을 보완하기 위한 표준으로 2004년 제정되었다. 무선AP가 관할하는 기본 서비스 셋(BSS) 안에서 무선AP와 단말기 사이에 보다 강화된 인증 및 키교환 방식, 향상된 무선구간 암호 알고리즘을 정의하고 있다.
2. IEEE 802.11i 표준은 무선전송 데이터 암호 방식에 따라 WPA와 WPA2버전으로 분류한다. **WPA 버전은 암호알고리즘으로 RC4-TKIP을 사용하고 WPA2 버전은 AES-CCMP를 사용**한다.
3. WPA/WPA2 인증방식은 사용되는 모드에 따라 WPA/WPA2-개인과 WPA/WPA2-기업으로 구분한다.
   * WPA/WPA2-개인은 **PSK 모드로 무선AP와 단말이 사전에 공유한 비밀키를 가지고 있다는 것을 4-way handshake 절차에 의해 확인하는 방식**이다.
   * WPA/WPA2-기업은 **802.1x/EAP 모드로 RADIUS 인증서버를 이용하여 상호 인증을 수행하고 그 결과를 기반으로 AP 접근을 허용하는 방식**이다.
  
### 2) WPA 암호방식 : RC4-TKIP
#### (가) 개요
1. TKIP 방식은 사용자 인증 결과로부터 무선AP와 단말 사이의 무선 채널 보호용 공유 비밀키를 동적으로 생성하여 무선 구간 패킷을 암호화한다.
2. TKIP은 WEP를 소프트웨어적으로 확장하는 방법을 사용함으로써 WEP 방식 하드웨어 교체 없이 구혈할 수 있도록 설계되었다.
3. TKIP은 WEP와 동일하게 RC4 알고리즘을 기반으로 하며 다음 4가지 보안기술을 이용하여 WEP의 취약성을 보완하고 있다.
   * WEP의 24bit IV를 확장한 48bit의 IV를 사용
   * IV의 순차적 증가 규칙을 보완하고 있다.
   * WEP를 이용한 암호화 이전에 키 믹싱 함수를 이용한 별도의 키생성 과정을 거쳐 각 패킷/프레임마다 별도의 암호키를 적용
   * 메시지 무결성 검사를 위해 WEP에서 사용한 CRC-32 알고리즘보다 안전한 MIC(Message Integrity Check)를 각 패킷/프레임별로 적용한다.

#### (나) 동작방식
1. 48bit의 확장된 IV를 만들기 위해 임시 키, 전송 주소, TKIP 시퀀스 카운터를 입력으로 1단계 키 믹싱 함수를 통해 TTAK를 생성
   * 전송 주소 : 송신할 때 경유하는 AP의 MAC 주소
   * TTAK : TKIP-mixed Transmitter Address and Key
2. TTAK와 TKIP 시퀀스 카운터(TSC)를 입력으로 2단계 키 믹싱 함수를 통해 WEP 암호키를 생성한다.
3. 전송데이터에 MIC키, 출발지 주소, 목적지 주소를 이용하여 MIC값을 생성하고 생성된 MIC값을 전송하려는 데이터에 추가한 후 TKIP 시퀀스 카운터와 조각화하여 전송하기 위한 평문을 만든다. 평문과 앞에서 생성한 WEP 암호키를 이용하여 WEP 암호화 알고리즘에 적용, 암호문을 생성한다.
4. 정리하면 48bit IV를 만들기 위해 임시 키, 전송 주소(AP의 MAC주소), TSC(TKIP 시퀀스 카운터)를 입력으로 1단계 믹싱 함수를 통해 TTAK를 생성, TTAK와 TSC를 입력으로 2단계 믹싱 함수를 통해 WEP 암호키 생성, 전송데이터에 MIC 키, 출발지 주소, 목적지 주소를 이용하여 MIC값을 생성하고 생성된 MIC값을 전송하려는 데이터에 추가한 후 TSC와 조각화하여 전송하기 위한 평문을 만들고 평문과 앞에서 만든 WEP 암호키를 이용하여 WEP 암호화 알고리즘에 적용하여 암호문 생성

#### (다) WPA 암호화 문제점
1. TKIP 암호기술은 WEP의 취약점을 보완하고 있지만 여전히 취약한 RC4 암호 알고리즘을 사용하고, 키 관리 방법을 제공하지 않으며 무선 패킷 수집을 통한 키크랙 공격에 대한 취약성을 그대로 가지고 있다.
2. TKIP의 적용은 소프트웨어 업그레이드를 이용하고 있기 때문에 소프트웨어적인 처리에 따른 암호화와 복호화 시간지연 등의 성능상 문제점이 있다.
3. 정리하면 TKIP 암호기술은 여전히 취약한 RC4 암호 알고리즘을 사용하고, 키 관리 방법을 제공하지 않으며 무선 패킷 수집을 통한 키크랙 공격에 대한 취약성을 그대로 가지고 있고 소프트웨어적인 처리에 따른 암호화 복호화 시간지연 등의 성능상 문제점 존재

### 3) WPA2 암호 방식 : AES-CCMP
#### (가) 개요
1. IEEE 802.11i 규격을 완전히 수용하는 표준으로 WPA와 구분하기 위해 WPA2로 정의한다. AES-CCMP를 통한 암호화 기능향상, EAP를 통한 사용자 인증 강화 등이 포함된다.
2. AES가 제공하는 블록 암호 모드 중 CCMP는 Counter 모드 기반으로 CBC-MAC을 결합한 CCM을 기반으로 한다. 패킷의 데이터 영역과 IEEE 802.11 헤더의 무결성을 보장하고 패킷 번호를 이용하여 재전송 공격을 방지한다.
3. AES-CCMP는 기본적으로 키 관리에 있어서 TKIP과 유사하지만 AES 기반의 128bit 대칭키를 사용하고 블록 암호 모드로 CCM(Counter mode with CBC-MAC) 모드를 사용하는 차이점이 있다.
4. 정리하면 AES-CCMP(Counter모드(메시지 암호화), CBC-MAC(메시지 인증), 128bit 대칭키 사용)은 패킷의 데이터 영역과 IEEE 802.11 헤더의 무결성을 보장하고 패킷 번호를 이용해 재전송 공격 방지

### 4) WPA/WPA2-개인(Personal) 인증 방식 : PSK
#### (가) 개요
1. PSK 인증방식은 인증 서버가 설치되지 않은 소규모 망에서 사용되는 방식으로 무선AP와 단말기가 자신과 동일한 공유키(PSK: Pre-Shared Key)를 가지고 있는지 802.1x에 규정된 EAPoL-Key 프레임을 활용하여 4-Way Handshake 과정을 통해 확인하여 인증을 수행한다.

#### (나) 동작방식
1. 무선AP와 무선단말에 설정된 무선랜 접속 패스워드와 SSID 정보를 이용하여 256bit 사전 공유키(PSK)를 각자 생성한다. PSK(PMK)를 생성하는 방법은 다음과 같다.
   * PSK(PMK) = PBKDF2(PW, SSID, SSID길이, 4096 256)
   * PBKDF2(Password-Based Key Derivation Function Version 2) : 패스워드 기반 키 유도 함수
   * 입력값을 4096번 해시 반복을 수행한 후 256bit 키를 생성한다.
   * PSK(PMK)는 무선랜 접속 패스워드와 SSID 정보를 알고 있는 사용자에 의해서만 생성되므로 이를 알고 있는 사용자를 정당한 사용자로 인증한다.
   * PSK(PMK)는 이후 전송되는 파라미터와 조합하여 암호화 통신에 사용되는 임시 키인 PTK 생성에 사용된다.
2. 4단계 핸드쉐이크 과정을 통해 얻은 파라미터와 PSK(PMK)를 이용하여 512bit PTK를 생성한다. PTK를 생성한즌 방법은 다음과 같다.
   * PTK = PRF-512(PSK(PMK), "Parirwise key expansion", Min(AA, SA) || Max(AA, SA) || Min(SNonce, ANonce) || Max(SNonce, ANonce))
   * PRF-512(Pseudo Random Function) : 의사 난수 생성 함수
   * PSK(PMK)와 AA(무선AP MAC), SA(무선단말 MAC), ANonce(무선AP 난수), SNonce(무선단말 난수)를 조합한 입력값을 이용하여 512bit 난수를 생성
3. PTK는 이후 무선AP와 단말 통신을 위해 세션 동안 사용되는 3개의 키로 파생된다.
   * KCK(EAPoL-Key Confirmation Key) : 송수신 메시지의 무결성과 송신처 인증을 위한 MIC용 키
   * KEK(EAPoL-Key Encryption Key) : 부가적인 데이터 암호화/복호화용 키
   * TK(Temporal Key) : 송수신 데이터 암호화/복호화용 키
4. 동일한 PTK가 생성되었는지 여부는 MSG2와 MSG3에서 주고받은 MIC값을 상호간에 검증하여 확인할 수 있다. MIC는 PTK로부터 파생된 KCK와 주고받은 파라미터(AA, SA, ANonce, SNonce)를 HMAC 알고리즘(HMAC-MD5 또는 HMAC-SHA1)을 이용하여 생성한다.
   * MIC 검증에 성공했다는 것은 무선AP와 단말이 생성한 PTK가 동일하다는 것이고 결과적으로 PSK(PMK)가 동일하다는 의미이므로 정당한 사용자로 인증할 수 있다.
5. 정리하면 무선AP와 무선단말에 설정된 무선랜 접속 패스워드와 SSID 정보를 이용하여 256bit 사전 공유키(PSK)를 생성한다.(PBKDF2(PW, SSID, SSID길이, 4096, 256) 함수를 통해 4096번 해시 반복을 수행한 후 256bit 키 생성) 4단계 핸드쉐이크 과정을 통해 얻은 파라미터(AA(무선AP MAC), SA(무선단말 MAC), ANonce(무선AP 난수), SNonce(무선단말 난수))와 PMK를 이용하여 512bit PTK(암호화에 사용되는 임시 키) 생성한다.(PRF-512(PMK, "Parirwise key expansion", Min(AA, SA) || Max(AA, SA) || Min(ANonce, SNonce) || Max(ANonce, SNonce))를 통해 의사난수 생성한다.) PTK는 이후 무선AP와 단말 통신을 위해 세션 동안 사용되는 3개의 키로 파생된다.(KCK : 송수신 메시지의 무결성과 송신처 인증을 위한 MIC용키, KEK : 부가적인 데이터 암호화/복호화용 키, TK : 송수신 데이터 암호화 암호화/복호화용 키) 동일한 PTK가 생성되었는지 여부는 MIC 값을 상호간에 검증하여 확인할 수 있다. MIC는 PTK로부터 파생된 KCK와 주고받은 파라미터(AA, SA, ANonce, SNonce)를 HMAC 알고리즘(HMAC-MD5, HMAC-SHA1)을 이용하여 생성한다.
#### (다) WPA-PSK 인증방식 문제점
1. WPA-PSK를 이용하여 무선 네트워크를 구성할 떄 접속/인증 패스워드를 짧게 설정하거나 추측하기 쉬운 값으로 설정할 경우 사전 공격을 통해 손쉽게 패스워드를 크랙할 수 있는 취약점이 있다.
   * 인증 및 키 생성을 위한 4-Way Handshake 과정에서 PTK를 생성할 때 사용되는 파라미터 중 패스워드를 기반으로 생성한 PSK(PMK)를 제외하고 모두 네트워크상에 노출된다.
   * 따라서 공격자는 패스워드를 사전에서 추측하여 PSK(PMK)를 생성한 후 노출된 파라미터를 이용해 PTK를 생성하고 이를 노출된 MIC값을 통해 검증함으로써 패스워드를 크랙할 수 있다.
2. 패스워드 사전 공격 절차를 살펴보면 다음과 같다.
   * 공격자는 4-Way Handshake 과정을 스니핑한다.
   * 사전 파일에 있는 단어를 이용하여 PSK(PMK)를 추측하여 생성한다.
   * 생성한 PSK(PMK)와 스니핑한 무선패킷에 있는 파라미터를 이용하여 PTK를 생성한다.
   * 생성한 PTK를 이용하여 MIC값을 생성한 후 스니핑한 MIC값과 비교하여 검증한다. 일치할 경우 추측한 패스워드가 접속/인증 패스워드가 되고 일치하지 않을 경우 다른 단어를 이용하여 반복한다.
3. 정리하면 WPA-PSK를 이용하는 무선 네트워크는 짧은 패스워드나 추측하기 쉬운 값으로 설정할 경우 사전 공격을 통해 손쉽게 패스워드 크랙할 수 있는 취약점이 있다. 패스워드 사전 공격 절차를 살펴보면 공격자는 4-Way Handshake 과정을 스니핑한다. 사전 파일에 있는 단어를 이용하여 PMK를 추측하여 생성한다. 생성한 PMK와 스니핑한 무선패킷에 있는 파라미터를 이용하여 PTK 생성한다. 생성한 PTK를 이용하여 MIC 값을 생성한 후 스니핑한 MIC값과 비교하여 검증한다. 일치할 경우 성공, 일치하지 않을 경우 다른 단어를 이용하여 반복
